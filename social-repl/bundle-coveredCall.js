export default {"bundle":{"source":"function getExportWithNestedEvaluate(filePrefix) {\n  'use strict';\n  // Serialised sources.\n  if (filePrefix === undefined) {\n    filePrefix = \"/bundled-source/...\";\n  }\n  const moduleFormat = \"nestedEvaluate\";\n  const entrypoint = \"zoe/src/contracts/coveredCall.js\";\n  const sourceBundle = {\n  \"zoe/src/contracts/coveredCall.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../exported.js');var zoeHelpers = require('../contractSupport/zoeHelpers.js');\\n\\n\\n\\n\\n\\n\\nrequire('../contractSupport/index.js'); /* @ts-check*/ /**\\n * A call option is the right (but not the obligation) to buy digital\\n * assets at a pre-determined price, called the strike price. This\\n * call option is \\\"covered,\\\" meaning that the owner of the digital\\n * assets must put the assets in escrow. This guarantees that the\\n * assets can be transferred without relying on the owner of the\\n * digital assets to keep their promise.\\n *\\n * https://agoric.com/documentation/zoe/guide/contracts/covered-call.html\\n *\\n * The call option has an expiration date, when the opportunity is\\n * cancelled. The owner of the digital assets cannot remove the assets\\n * from escrow before the expiration date.\\n *\\n * The `creatorInvitation` of this contract is an invitation to escrow\\n * the underlying assets. The proposal to escrow assets can have any\\n * `give` and `want` with any keywords. Any number of assets of\\n * different brands can be escrowed under different keywords. The\\n * proposal must have an exit record with the key \\\"afterDeadline\\\":\\n * {\\n *    give: { ... }, want: { ... }, exit: {afterDeadline: { deadline:\\n *    time, timer: myTimer }\\n *    },\\n * }\\n *\\n * This deadline serves as the expiration date for the covered call\\n * option. After this deadline, if the option has not been exercised,\\n * the underlying assets are automatically paid out to the creator of\\n * the contract as a refund.\\n *\\n * After the owner of the digital assets escrows the assets in the\\n * initial offer, they receive a seat. The payout for this seat will\\n * either be a refund of the underlying assets (as mentioned above) or\\n * payments in the amount of the strike price. Zoe's enforcement of\\n * offer safety guarantees that the payout is either a refund or\\n * payments in the amount of the strike price, regardless of whether\\n * this contract is buggy.\\n *\\n * The offerResult of this initial seat resolves to the call option\\n * itself: an inspectable invitation to buy the underlying assets. The\\n * call option invitation has this additional information in the\\n * value: {expirationDate, timeAuthority, underlyingAssets,\\n * strikePrice }\\n *\\n * The invitation itself can be traded as a valuable digital asset: a\\n * covered call option.\\n *\\n * The recipient of a covered call option (buying it on some other\\n * exchange or through some other trading contract) can exercise the\\n * option before the deadline by using the option as an invitation to\\n * this contract, paying the strike price and receiving the underlying\\n * assets. The recipient of a covered call option can use whatever\\n * keywords they wish, as long as they give the strike price as\\n * specified in the invitation value, and want the underlying assets\\n * exactly.\\n *\\n * @type {ContractStartFn}\\n */\\nconst start = zcf => {\\n  const sellSeatExpiredMsg = `The covered call option is expired.`;\\n\\n  const makeOption = sellSeat => {\\n    zoeHelpers.assertProposalShape(sellSeat, { exit: { afterDeadline: null } });\\n\\n    const exerciseOption = buySeat => {\\n      try {\\n        zoeHelpers.swapExact(zcf, sellSeat, buySeat, sellSeatExpiredMsg);}\\n      catch (err) {\\n        console.log(\\n        'Swap failed. Please make sure your offer has the same underlyingAssets and strikePrice as specified in the invitation details. The keywords should not matter.');\\n\\n        throw err;}\\n\\n      zcf.shutdown('Swap completed.');\\n      return `The option was exercised. Please collect the assets in your payout.`;};\\n\\n\\n    const customProps = harden({\\n      expirationDate: sellSeat.getProposal().exit.afterDeadline.deadline,\\n      timeAuthority: sellSeat.getProposal().exit.afterDeadline.timer,\\n      underlyingAssets: sellSeat.getProposal().give,\\n      strikePrice: sellSeat.getProposal().want });\\n\\n    return zcf.makeInvitation(exerciseOption, 'exerciseOption', customProps);};\\n\\n\\n  const creatorInvitation = zcf.makeInvitation(makeOption, 'makeCallOption');\\n\\n  return harden({ creatorInvitation });};\\n\\n\\nharden(start);exports.start = start;\",\n  \"zoe/src/contractFacet/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {any} Completion\\n * Any passable non-thenable. Often an explanatory string.\\n *\\n * @typedef {Error|any} TerminationReason\\n * Something provided as an explanation to a termination request. Usually an\\n * Error but not required to be so.\\n */ /**\\n * @callback ZCFMakeEmptySeatKit\\n * @param {ExitRule=} exit\\n * @returns {ZCFSeatKit}\\n */ /**\\n * @callback GetAmountMath\\n * @param {Brand} brand\\n * @returns {DeprecatedAmountMath}\\n */ /**\\n * @typedef {Object} ContractFacet\\n *\\n * The Zoe interface specific to a contract instance. The Zoe Contract\\n * Facet is an API object used by running contract instances to access\\n * the Zoe state for that instance. The Zoe Contract Facet is accessed\\n * synchronously from within the contract, and usually is referred to\\n * in code as zcf.\\n *\\n * @property {Reallocate} reallocate - reallocate amounts among seats\\n * @property {(keyword: Keyword) => void} assertUniqueKeyword - check\\n * whether a keyword is valid and unique and could be added in\\n * `saveIssuer`\\n * @property {SaveIssuer} saveIssuer - save an issuer to ZCF and Zoe\\n * and get the amountMath and brand synchronously accessible after\\n * saving\\n * @property {MakeInvitation} makeInvitation\\n * @property {(completion: Completion) => void} shutdown\\n * @property {(reason: TerminationReason) => void} shutdownWithFailure\\n * @property {Assert} assert\\n * @property {() => ZoeService} getZoeService\\n * @property {() => Issuer} getInvitationIssuer\\n * @property {() => Terms} getTerms\\n * @property {(issuer: Issuer) => Brand} getBrandForIssuer\\n * @property {(brand: Brand) => Issuer} getIssuerForBrand\\n * @property {GetAmountMath} getAmountMath\\n * @property {(brand: Brand) => AmountMathKind} getMathKind\\n * @property {MakeZCFMint} makeZCFMint\\n * @property {ZCFMakeEmptySeatKit} makeEmptySeatKit\\n * @property {SetTestJig} setTestJig\\n * @property {() => void} stopAcceptingOffers\\n */ /**\\n * @typedef {(seatStaging1: SeatStaging, seatStaging2: SeatStaging,\\n * ...seatStagingRest: Array<SeatStaging>) => void} Reallocate\\n *\\n * The contract can reallocate over seatStagings, which are\\n * associations of seats with reallocations.\\n *\\n * The reallocation will only succeed if the reallocation 1) conserves\\n * rights (the amounts specified have the same total value as the\\n * current total amount), and 2) is 'offer-safe' for all parties\\n * involved. Offer safety is checked at the staging step.\\n *\\n * The reallocation is partial, meaning that it applies only to the\\n * seats associated with the seatStagings. By induction, if rights\\n * conservation and offer safety hold before, they will hold after a\\n * safe reallocation, even though we only re-validate for the seats\\n * whose allocations will change. Since rights are conserved for the\\n * change, overall rights will be unchanged, and a reallocation can\\n * only effect offer safety for seats whose allocations change.\\n */ /**\\n * @callback SaveIssuer\\n *\\n * Informs Zoe about an issuer and returns a promise for acknowledging\\n * when the issuer is added and ready.\\n *\\n * @param {ERef<Issuer>} issuerP Promise for issuer\\n * @param {Keyword} keyword Keyword for added issuer\\n * @returns {Promise<IssuerRecord>} Issuer is added and ready\\n */ /**\\n * @callback MakeInvitation\\n *\\n * Make a credible Zoe invitation for a particular smart contract\\n * indicated by the `instance` in the details of the invitation. Zoe\\n * also puts the `installation` and a unique `handle` in the details of\\n * the invitation. The contract must provide a `description` for the\\n * invitation and should include whatever information is\\n * necessary for a potential buyer of the invitation to know what they are\\n * getting in the `customProperties`. `customProperties` will be\\n * placed in the details of the invitation.\\n *\\n * @param {OfferHandler=} offerHandler - a contract specific function\\n * that handles the offer, such as saving it or performing a trade\\n * @param {string} description\\n * @param {Object=} customProperties\\n * @returns {Promise<Invitation>}\\n */ /**\\n * @callback MakeZCFMint\\n * @param {Keyword} keyword\\n * @param {AmountMathKind=} amountMathKind\\n * @param {DisplayInfo=} displayInfo\\n * @returns {Promise<ZCFMint>}\\n */ /**\\n * @callback SetTestJig\\n * @param {() => any} testFn\\n * @returns {void}\\n */ /**\\n * @callback ZCFMintMintGains\\n * @param {AmountKeywordRecord} gains\\n * @param {ZCFSeat=} zcfSeat\\n * @returns {ZCFSeat}\\n */ /**\\n * @typedef {Object} ZCFMint\\n * @property {() => IssuerRecord} getIssuerRecord\\n * @property {ZCFMintMintGains} mintGains\\n * All the amounts in gains must be of this ZCFMint's brand.\\n * The gains' keywords are in the namespace of that seat.\\n * Add the gains to that seat's allocation.\\n * The resulting state must be offer safe. (Currently, increasing assets can\\n * never violate offer safety anyway.)\\n *\\n * Mint that amount of assets into the pooled purse.\\n * If a seat is provided, it is returned. Otherwise a new seat is\\n * returned.\\n * TODO unimplemented\\n * This creation-on-demand is not yet implemented.\\n *\\n * @property {(losses: AmountKeywordRecord,\\n *             zcfSeat: ZCFSeat,\\n *            ) => void} burnLosses\\n * All the amounts in losses must be of this ZCFMint's brand.\\n * The losses' keywords are in the namespace of that seat.\\n * Subtract losses from that seat's allocation.\\n * The resulting state must be offer safe.\\n *\\n * Burn that amount of assets from the pooled purse.\\n */ /**\\n * @callback ZCFSeatFail\\n *\\n * fail called with the reason for this failure, where reason is\\n * normally an instanceof Error.\\n * @param {Error=} reason\\n * @returns {Error}\\n */ /**\\n * @callback ZCFSeatKickOut\\n *\\n * called with the reason for this failure,\\n * where reason is normally an instanceof Error. This method is\\n * deprecated as of 0.9.1-dev.3 in favor of fail().\\n * @param {Error=} reason\\n * @returns {Error}\\n */ /**\\n * @callback ZCFGetAmountAllocated\\n * The brand is used for filling in an empty amount if the `keyword`\\n * is not present in the allocation\\n * @param {Keyword} keyword\\n * @param {Brand=} brand\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} ZCFSeat\\n * @property {() => void} exit\\n * @property {ZCFSeatFail} fail\\n * @property {ZCFSeatKickOut} kickOut\\n * @property {() => Notifier<Allocation>} getNotifier\\n * @property {() => boolean} hasExited\\n * @property {() => ProposalRecord} getProposal\\n * @property {ZCFGetAmountAllocated} getAmountAllocated\\n * @property {() => Allocation} getCurrentAllocation\\n * @property {(newAllocation: Allocation) => boolean} isOfferSafe\\n * @property {(newAllocation: Allocation) => SeatStaging} stage\\n */ /**\\n * @typedef {Object} SeatStaging\\n * @property {() => ZCFSeat} getSeat\\n * @property {() => Allocation} getStagedAllocation\\n */ /**\\n * @typedef {{ zcfSeat: ZCFSeat, userSeat: ERef<UserSeat>}} ZcfSeatKit\\n */ /**\\n * @callback OfferHandler\\n * @param {ZCFSeat} seat\\n * @returns any\\n */ /**\\n * @callback ContractStartFn\\n * @param {ContractFacet} zcf\\n * @returns {ContractStartFnResult}\\n */ /**\\n * @typedef {Object} ContractStartFnResult\\n * @property {Object=} creatorFacet\\n * @property {Promise<Invitation>=} creatorInvitation\\n * @property {Object=} publicFacet\\n */\",\n  \"zoe/src/zoeService/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {Object} ZoeService\\n *\\n * Zoe provides a framework for deploying and working with smart\\n * contracts. It is accessed as a long-lived and well-trusted service\\n * that enforces offer safety for the contracts that use it. Zoe has a\\n * single `invitationIssuer` for the entirety of its lifetime. By\\n * having a reference to Zoe, a user can get the `invitationIssuer`\\n * and thus validate any `invitation` they receive from someone else.\\n *\\n * Zoe has two different facets: the public Zoe service and the\\n * contract facet (ZCF). Each contract instance has a copy of ZCF\\n * within its vat. The contract and ZCF never have direct access to\\n * the users' payments or the Zoe purses.\\n *\\n * @property {() => Issuer} getInvitationIssuer\\n *\\n * Zoe has a single `invitationIssuer` for the entirety of its\\n * lifetime. By having a reference to Zoe, a user can get the\\n * `invitationIssuer` and thus validate any `invitation` they receive\\n * from someone else. The mint associated with the invitationIssuer\\n * creates the ERTP payments that represent the right to interact with\\n * a smart contract in particular ways.\\n *\\n * @property {Install} install\\n * @property {StartInstance} startInstance\\n * @property {Offer} offer\\n * @property {(instance: Instance) => Object} getPublicFacet\\n * @property {(instance: Instance) => IssuerKeywordRecord} getIssuers\\n * @property {(instance: Instance) => BrandKeywordRecord} getBrands\\n * @property {(instance: Instance) => Object} getTerms\\n * @property {(invitation: ERef<Invitation>) => Promise<Instance>} getInstance\\n * @property {(invitation: ERef<Invitation>) => Promise<Installation>} getInstallation\\n * @property {(invitation: ERef<Invitation>) => Promise<InvitationDetails>}\\n * getInvitationDetails - return an object with the instance,\\n * installation, description, invitation handle, and any custom properties\\n * specific to the contract.\\n */ /**\\n * @callback Install\\n *\\n * Create an installation by safely evaluating the code and\\n * registering it with Zoe. Returns an installation.\\n *\\n * @param {SourceBundle} bundle\\n * @returns {Promise<Installation>}\\n */ /**\\n * @callback StartInstance\\n * Zoe is long-lived. We can use Zoe to create smart contract\\n * instances by specifying a particular contract installation to use,\\n * as well as the `terms` of the contract. The `terms.issuers` is a\\n * record mapping string names (keywords) to issuers, such as `{\\n * Asset: simoleanIssuer}`. (Note that the keywords must begin with a\\n * capital letter and must be ASCII identifiers.) Parties to the\\n * contract will use the keywords to index their proposal and their\\n * payments.\\n *\\n * The custom terms are the arguments to the contract, such as the\\n * number of bids an auction will wait for before closing. Custom\\n * terms are up to the discretion of the smart contract. We get back\\n * the creator facet, public facet, and creator invitation as defined\\n * by the contract.\\n *\\n * @param {ERef<Installation>} installation\\n * @param {IssuerKeywordRecord=} issuerKeywordRecord\\n * @param {Object=} terms\\n * @returns {Promise<StartInstanceResult>}\\n */ /**\\n * @callback Offer\\n *\\n * To redeem an invitation, the user normally provides a proposal (their\\n * rules for the offer) as well as payments to be escrowed by Zoe.  If\\n * either the proposal or payments would be empty, indicate this by\\n * omitting that argument or passing undefined, rather than passing an\\n * empty record.\\n *\\n * The proposal has three parts: `want` and `give` are used by Zoe to\\n * enforce offer safety, and `exit` is used to specify the particular\\n * payout-liveness policy that Zoe can guarantee. `want` and `give`\\n * are objects with keywords as keys and amounts as values.\\n * `paymentKeywordRecord` is a record with keywords as keys, and the\\n * values are the actual payments to be escrowed. A payment is\\n * expected for every rule under `give`.\\n *\\n * @param {ERef<Invitation>} invitation\\n * @param {Proposal=} proposal\\n * @param {PaymentPKeywordRecord=} paymentKeywordRecord\\n * @returns {Promise<UserSeat>} seat\\n */ /**\\n * @typedef {Object} UserSeat\\n * @property {() => Promise<Allocation>} getCurrentAllocation\\n * @property {() => Promise<ProposalRecord>} getProposal\\n * @property {() => Promise<PaymentPKeywordRecord>} getPayouts\\n * @property {(keyword: Keyword) => Promise<Payment>} getPayout\\n * @property {() => Promise<OfferResult>} getOfferResult\\n * @property {() => void=} tryExit\\n * @property {() => Promise<boolean>} hasExited\\n * @property {() => Promise<Notifier<Allocation>>} getNotifier\\n */ /**\\n * @typedef {any} OfferResult\\n */ /**\\n * @typedef {Object} AdminFacet\\n * @property {() => Promise<Completion>} getVatShutdownPromise\\n * @property {() => any} getVatStats\\n */ /**\\n * @typedef {Object} StartInstanceResult\\n * @property {any} creatorFacet\\n * @property {any} publicFacet\\n * @property {Instance} instance\\n * @property {Payment | undefined} creatorInvitation\\n * @property {AdminFacet} adminFacet\\n */ /**\\n * @typedef {Partial<ProposalRecord>} Proposal\\n *\\n * @typedef {{give: AmountKeywordRecord,\\n *            want: AmountKeywordRecord,\\n *            exit: ExitRule\\n *           }} ProposalRecord\\n */ /**\\n * @typedef {Record<Keyword,Amount>} AmountKeywordRecord\\n *\\n * The keys are keywords, and the values are amounts. For example:\\n * { Asset: amountMath.make(5n, assetBrand), Price:\\n * amountMath.make(9n, priceBrand) }\\n */ /**\\n * @typedef {Object} Waker\\n * @property {() => void} wake\\n */ /**\\n * @typedef {bigint} Deadline\\n */ /**\\n * @typedef {Object} Timer\\n * @property {(deadline: Deadline, wakerP: ERef<Waker>) => void} setWakeup\\n */ /**\\n * @typedef {Object} OnDemandExitRule\\n * @property {null} onDemand\\n */ /**\\n * @typedef {Object} WaivedExitRule\\n * @property {null} waived\\n */ /**\\n * @typedef {Object} AfterDeadlineExitRule\\n * @property {{timer:Timer, deadline:Deadline}} afterDeadline\\n */ /**\\n * @typedef {OnDemandExitRule | WaivedExitRule | AfterDeadlineExitRule} ExitRule\\n *\\n * The possible keys are 'waived', 'onDemand', and 'afterDeadline'.\\n * `timer` and `deadline` only are used for the `afterDeadline` key.\\n * The possible records are:\\n * `{ waived: null }`\\n * `{ onDemand: null }`\\n * `{ afterDeadline: { timer :Timer<Deadline>, deadline :Deadline } }\\n */ /**\\n * @typedef {Handle<'Instance'>} Instance\\n */ /**\\n * @typedef {Object} VatAdminSvc\\n * @property {(bundle: SourceBundle) => RootAndAdminNode} createVat\\n * @property {(BundleName: string) => RootAndAdminNode} createVatByName\\n */ /**\\n * @typedef {Record<string, any>} SourceBundle Opaque type for a JSONable source bundle\\n */ /**\\n * @typedef {Record<Keyword,ERef<Payment>>} PaymentPKeywordRecord\\n * @typedef {Record<Keyword,Payment>} PaymentKeywordRecord\\n */ /**\\n * @typedef {Object} StandardInvitationDetails\\n * @property {Installation} installation\\n * @property {Instance} instance\\n * @property {InvitationHandle} handle\\n * @property {string} description\\n */ /**\\n * @typedef {StandardInvitationDetails & Record<string, any>} InvitationDetails\\n */ /**\\n * @typedef {Object} Installation\\n * @property {() => SourceBundle} getBundle\\n */\",\n  \"zoe/src/contractSupport/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @callback Trade\\n * Trade between left and right so that left and right end up with\\n * the declared gains and losses.\\n * @param {ContractFacet} zcf\\n * @param {SeatGainsLossesRecord} left\\n * @param {SeatGainsLossesRecord} right\\n * @param {string} [leftHasExitedMsg] A custom error message if\\n * the left seat has been exited already\\n * @param {string} [rightHasExitedMsg] A custom error message if the\\n * right seat has been exited already\\n * @returns {void}\\n *\\n * @typedef {Object} SeatGainsLossesRecord\\n * @property {ZCFSeat} seat\\n * @property {AmountKeywordRecord} gains - what the seat will\\n * gain as a result of this trade\\n * @property {AmountKeywordRecord=} losses - what the seat will\\n * give up as a result of this trade. Losses is optional, but can\\n * only be omitted if the keywords for both seats are the same.\\n * If losses is not defined, the gains of the other seat is\\n * subtracted.\\n */ /**\\n * @callback Swap\\n * If two seats can satisfy each other's wants, trade enough to\\n * satisfy the wants of both seats and exit both seats.\\n *\\n * The surplus remains with the original seat. For example if seat A\\n * gives 5 moola and seat B only wants 3 moola, seat A retains 2\\n * moola.\\n *\\n * If leftSeat has exited already, both seats will fail\\n * with an error message (provided by 'leftHasExitedMsg'). Similarly,\\n * if rightSeat has exited already, both seats fail\\n * with an error message (provided by 'rightHasExitedMsg').\\n *\\n * If the swap fails, no assets are transferred, both seats will fail,\\n * and the function throws.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} leftSeat\\n * @param {ZCFSeat} rightSeat\\n * @param {string} [leftHasExitedMsg]\\n * @param {string} [rightHasExitedMsg]\\n * @returns {string}\\n */ /**\\n * @typedef {Object} OfferToReturns\\n *\\n * The return value of offerTo is a promise for the userSeat for the\\n * offer to the other contract, and a promise (`deposited`) which\\n * resolves when the payout for the offer has been deposited to the `toSeat`\\n * @property {Promise<UserSeat>} userSeatPromise\\n * @property {Promise<AmountKeywordRecord>} deposited\\n */ /**\\n * @typedef {Record<Keyword,Keyword>} KeywordKeywordRecord\\n *\\n * A mapping of keywords to keywords.\\n */ /**\\n * @callback OfferTo\\n *\\n * Make an offer to another contract instance (labeled contractB below),\\n * withdrawing the payments for the offer from a seat in the current\\n * contract instance (contractA) and depositing the payouts in another\\n * seat in the current contract instance (contractA).\\n *\\n * @param {ContractFacet} zcf\\n *   Zoe Contract Facet for contractA\\n *\\n * @param {ERef<Invitation>} invitation\\n *   Invitation to contractB\\n *\\n * @param {KeywordKeywordRecord=} keywordMapping\\n *   Mapping of keywords used in contractA to keywords to be used in\\n *   contractB. Note that the pathway to deposit the payout back to\\n *   contractA reverses this mapping.\\n *\\n * @param {Proposal} proposal\\n *   The proposal for the offer to be made to contractB\\n *\\n * @param {ZCFSeat} fromSeat\\n *   The seat in contractA to take the offer payments from.\\n *\\n * @param {ZCFSeat=} toSeat\\n *   The seat in contractA to deposit the payout of the offer to.\\n *   If `toSeat` is not provided, this defaults to the `fromSeat`.\\n *\\n * @returns {OfferToReturns}\\n */ /**\\n * @callback Reverse\\n *\\n * Given a mapping of keywords to keywords, invert the keys and\\n * values. This is used to map the offers made to another contract\\n * back to the keywords used in the first contract.\\n * @param {KeywordKeywordRecord=} keywordRecord\\n * @returns {KeywordKeywordRecord }\\n */ /**\\n * @callback MapKeywords\\n *\\n * Remap the keywords of an amountKeywordRecord or a\\n * PaymentPKeywordRecord according to a mapping. This is used to remap\\n * from keywords used in contractA to keywords used in contractB and\\n * vice versa in `offerTo`\\n *\\n * @param {AmountKeywordRecord | PaymentPKeywordRecord | undefined }\\n * keywordRecord\\n * @param {KeywordKeywordRecord} keywordMapping\\n */ /**\\n * @typedef {Object} Ratio\\n * @property {Amount} numerator\\n * @property {Amount} denominator\\n */ /**\\n * @callback MakeRatio\\n * @param {bigint} numerator\\n * @param {Brand} numeratorBrand\\n * @param {bigint=} denominator The default denomiator is 100\\n * @param {Brand=} denominatorBrand The default is to reuse the numeratorBrand\\n * @returns {Ratio}\\n */ /**\\n * @callback MakeRatioFromAmounts\\n * @param {Amount} numerator\\n * @param {Amount} denominator\\n * @returns {Ratio}\\n */ /**\\n * @callback MultiplyBy\\n * @param {Amount} amount\\n * @param {Ratio} ratio\\n * @returns {amount}\\n */ /**\\n * @callback DivideBy\\n * @param {Amount} amount\\n * @param {Ratio} ratio\\n * @returns {amount}\\n */ /**\\n * @callback InvertRatio\\n * @param {Ratio} ratio\\n * @returns {Ratio}\\n */\",\n  \"zoe/src/contracts/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} SellItemsPublicFacet\\n * @property {() => Issuer} getItemsIssuer\\n * @property {() => Amount} getAvailableItems\\n *\\n * @typedef {Object} SellItemsCreatorOnly\\n * @property {() => Promise<Invitation>} makeBuyerInvitation\\n *\\n * @typedef {SellItemsPublicFacet & SellItemsCreatorOnly} SellItemsCreatorFacet\\n */ /**\\n * @typedef {Object} SellItemsParameters\\n * @property {Record<string, any>} customValueProperties\\n * @property {bigint} count\\n * @property {Issuer} moneyIssuer\\n * @property {Installation} sellItemsInstallation\\n * @property {Amount} pricePerItem\\n *\\n * @typedef {Object} SellItemsResult\\n * @property {UserSeat} sellItemsCreatorSeat\\n * @property {SellItemsCreatorFacet} sellItemsCreatorFacet\\n * @property {Instance} sellItemsInstance\\n * @property {SellItemsPublicFacet} sellItemsPublicFacet\\n *\\n * @typedef {Object} MintAndSellNFTCreatorFacet\\n * @property {(sellParams: SellItemsParameters) => Promise<SellItemsResult>} sellTokens\\n * @property {() => Issuer} getIssuer\\n */ /**\\n * @typedef {Object} AutomaticRefundPublicFacet\\n * @property {() => bigint} getOffersCount\\n * @property {() => Promise<Invitation>} makeInvitation\\n */ /**\\n * @typedef {Object} SimpleExchangePublicFacet\\n * @property {() => Promise<Invitation>} makeInvitation\\n * @property {() => Notifier<any>} getNotifier\\n */\",\n  \"zoe/src/contracts/loan/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Notifier<Timestamp>} PeriodNotifier\\n *\\n *  The Notifier that provides notifications that periods have passed.\\n *  Since notifiers can't be relied on to produce an output every time\\n *  they should, we'll track the time of last payment, and catch up if\\n *  any times have been missed. Compound interest will be calculated\\n *  using the interestRate.\\n */ /**\\n * @typedef {Instance} AutoswapInstance\\n *   The running contract instance for an Autoswap or Multipool\\n *   Autoswap installation.  The publicFacet from the Autoswap\\n *   instance is used for producing an invitation to sell the\\n *   collateral on liquidation.\\n */ /**\\n * @typedef LoanTerms\\n *\\n * @property {Ratio} mmr - Maintenance Margin Requirement, a Ratio record.\\n * Default is 150%\\n *\\n * @property {AutoswapInstance} autoswapInstance\\n *\\n * @property {PriceAuthority} priceAuthority\\n *\\n *   Used for getting the current value of collateral and setting\\n *   liquidation triggers.\\n *\\n * @property {PeriodNotifier} periodNotifier\\n *\\n * @property {Ratio} interestRate\\n *   The rate in basis points that will be multiplied with the debt on\\n *   every period to compound interest.\\n *\\n * @property {RelativeTime} interestPeriod\\n *\\n * @property {Brand} loanBrand\\n * @property {Brand} collateralBrand\\n */ /**\\n * @typedef LenderSeatProperty\\n * @property {ZCFSeat} lenderSeat\\n *\\n *   The ZCFSeat representing the lender's position in the contract.\\n */ /**\\n * @typedef {LoanTerms & LenderSeatProperty} LoanConfigWithLender\\n *\\n * The loan now has a lenderSeat, which is added to the config.\\n */ /**\\n * @typedef BorrowerConfigProperties\\n *\\n * @property {ZCFSeat} collateralSeat\\n *\\n *   The ZCFSeat holding the collateral in escrow after the borrower\\n *   escrows it\\n *\\n * @property {() => Amount} getDebt\\n *\\n *   A function to get the current debt\\n *\\n * @property {PromiseRecord<PriceQuote>} liquidationPromiseKit\\n *\\n *   PromiseKit that includes a promise that resolves to a PriceQuote\\n *   when liquidation is triggered\\n */ /**\\n * @typedef BorrowerConfigPropertiesMinusDebt\\n *\\n * @property {ZCFSeat} collateralSeat\\n *\\n *   The ZCFSeat holding the collateral in escrow after the borrower\\n *   escrows it\\n *\\n * @property {PromiseRecord<PriceQuote>} liquidationPromiseKit\\n *\\n *   PromiseKit that includes a promise that resolves to a PriceQuote\\n *   when liquidation is triggered\\n */ /**\\n * @typedef {LoanConfigWithLender & BorrowerConfigProperties } LoanConfigWithBorrower\\n *\\n * The loan has a lender, a borrower, and collateral escrowed.\\n */ /**\\n * @typedef {LoanConfigWithLender & BorrowerConfigPropertiesMinusDebt\\n * } LoanConfigWithBorrowerMinusDebt\\n */ /**\\n * @callback ScheduleLiquidation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n */ /**\\n * @callback MakeLendInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanTerms} config\\n * @returns {Promise<Invitation>} lendInvitation\\n */ /**\\n * @callback MakeBorrowInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithLender} config\\n * @returns {Promise<Invitation>} borrowInvitation\\n */ /**\\n * @callback MakeCloseLoanInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {Promise<Invitation>} closeLoanInvitation\\n */ /**\\n * Allows holder to add collateral to the contract. Exits the seat\\n * after adding.\\n *\\n * @callback MakeAddCollateralInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {Promise<Invitation>} addCollateralInvitation\\n */ /**\\n * @callback Liquidate\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {void}\\n */ /**\\n * @callback MakeDebtCalculator\\n * @param {DebtCalculatorConfig} debtCalculatorConfig\\n */ /**\\n * @callback CalcInterestFn\\n * @param {Amount} oldDebt\\n * @param {Ratio} interestRate\\n * @returns {Amount} interest\\n */ /**\\n * @typedef {Object} DebtCalculatorConfig\\n * @property {CalcInterestFn} calcInterestFn\\n *\\n *   A function to calculate the interest, given the debt value and an\\n *   interest rate in basis points.\\n *\\n * @property {Amount} originalDebt\\n *\\n *   The debt at the start of the loan, in Loan brand\\n *\\n * @property {PeriodNotifier} periodNotifier\\n *\\n *   The AsyncIterable to notify when a period has occurred\\n *\\n * @property {Ratio} interestRate\\n * @property {RelativeTime} interestPeriod\\n *\\n *  the period at which the outstanding debt increases by the interestRate\\n *\\n * @property {ContractFacet} zcf\\n *\\n * @property {LoanConfigWithBorrowerMinusDebt} configMinusGetDebt\\n * @property {Timestamp} basetime The starting point from which to calculate\\n * interest.\\n */ /**\\n * @typedef {Object} ConfigMinusGetDebt\\n * @property {ZCFSeat} collateralSeat\\n * @property {PromiseRecord<any>} liquidationPromiseKit\\n * @property {bigint} [mmr]\\n * @property {Handle<'Instance'>} autoswapInstance\\n * @property {PriceAuthority} priceAuthority\\n * @property {PeriodNotifier} periodNotifier\\n * @property {bigint} interestRate\\n * @property {RelativeTime} interestPeriod\\n * @property {ZCFSeat} lenderSeat\\n */ /**\\n * @typedef {Object} BorrowFacet\\n *\\n * @property {() => Promise<Invitation>} makeCloseLoanInvitation\\n *\\n * Make an invitation to close the loan by repaying the debt\\n *   (including interest).\\n *\\n * @property {() => Promise<Invitation>} makeAddCollateralInvitation\\n *\\n * Make an invitation to add collateral to protect against liquidation\\n *\\n * @property {() => Promise<PriceQuote>} getLiquidationPromise\\n *\\n * Get a promise for a priceQuote that will resolve if liquidation\\n * occurs. The priceQuote is for the value of the collateral that\\n * triggered the liquidation. This may be lower than expected if the\\n * price is moving quickly.\\n *\\n * @property {() => Timestamp} getLastCalculationTimestamp\\n *\\n * Get the timestamp at which the debt was most recently recalculated.\\n *\\n * @property {() => Notifier<Amount>} getDebtNotifier\\n *\\n * Get a Notifier that will be updated when the current debt (an Amount with the Loan\\n * Brand) changes. This will increase as interest is added.\\n *\\n * @property {() => Amount} getRecentCollateralAmount\\n *\\n * Get a recent report of the amount of collateral in the loan\\n */\",\n  \"zoe/src/contracts/multipoolAutoswap/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} AutoswapPublicFacet\\n * @property {() => Promise<Invitation>} makeSwapInvitation synonym for\\n * makeSwapInInvitation\\n * @property {() => Promise<Invitation>} makeSwapInInvitation make an invitation\\n * that allows one to do a swap in which the In amount is specified and the Out\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeSwapOutInvitation make an invitation\\n * that allows one to do a swap in which the Out amount is specified and the In\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeAddLiquidityInvitation make an\\n * invitation that allows one to add liquidity to the pool.\\n * @property {() => Promise<Invitation>} makeRemoveLiquidityInvitation make an\\n * invitation that allows one to remove liquidity from the pool.\\n * @property {() => Issuer} getLiquidityIssuer\\n * @property {() => bigint} getLiquiditySupply get the current value of\\n * liquidity held by investors.\\n * @property {(amountIn: Amount, brandOut: Brand) => Amount} getInputPrice\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price.\\n * @property {(amountOut: Amount, brandIn: Brand) => Amount} getOutputPrice\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price\\n * @property {() => Record<string, Amount>} getPoolAllocation get an\\n * AmountKeywordRecord showing the current balances in the pool.\\n */ /**\\n * @typedef {Object} PriceAmountPair\\n *\\n * @property {Amount} amountOut\\n * @property {Amount} amountIn\\n */ /**\\n * @typedef {Object} Pool\\n * @property {(inputAmount: Amount, outputBrand: Brand) => PriceAmountPair } getPriceGivenAvailableInput\\n * @property {(inputBrand: Brand, outputAmount: Amount) => PriceAmountPair } getPriceGivenRequiredOutput\\n * @property {() => bigint} getLiquiditySupply\\n * @property {() => Issuer} getLiquidityIssuer\\n * @property {(seat: ZCFSeat) => string} addLiquidity\\n * @property {(seat: ZCFSeat) => string} removeLiquidity\\n * @property {() => ZCFSeat} getPoolSeat\\n * @property {() => Amount} getSecondaryAmount\\n * @property {() => Amount} getCentralAmount\\n */ /**\\n * @typedef {Object} MultipoolAutoswapPublicFacet\\n * @property {(issuer: Issuer, keyword: Keyword) => Promise<Issuer>} addPool\\n * add a new liquidity pool\\n * @property {() => Promise<Invitation>} makeSwapInvitation synonym for\\n * makeSwapInInvitation\\n * @property {() => Promise<Invitation>} makeSwapInInvitation make an invitation\\n * that allows one to do a swap in which the In amount is specified and the Out\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeSwapOutInvitation make an invitation\\n * that allows one to do a swap in which the Out amount is specified and the In\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeAddLiquidityInvitation make an\\n * invitation that allows one to add liquidity to the pool.\\n * @property {() => Promise<Invitation>} makeRemoveLiquidityInvitation make an\\n * invitation that allows one to remove liquidity from the pool.\\n * @property {(brand: Brand) => Issuer} getLiquidityIssuer\\n * @property {(brand: Brand) => bigint} getLiquiditySupply get the current value of\\n * liquidity in the pool for brand held by investors.\\n * @property {(amountIn: Amount, brandOut: Brand) => Amount} getInputPrice\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price.\\n * @property {(amountOut: Amount, brandIn: Brand) => Amount} getOutputPrice\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price\\n * @property {(amountIn: Amount, brandOut: Brand) => PriceAmountPair} getPriceGivenAvailableInput\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price. Include the minimum\\n * amountIn required to gain that much.\\n * @property {(amountOut: Amount, brandIn: Brand) => PriceAmountPair} getPriceGivenRequiredOutput\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price. Include the maximum amount\\n * of amountOut that can be gained for that amountIn.\\n * @property {(brand: Brand) => Record<string, Amount>} getPoolAllocation get an\\n * AmountKeywordRecord showing the current balances in the pool for brand.\\n */\",\n  \"zoe/src/contracts/priceAggregatorTypes.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} OracleAdmin\\n * @property {() => Promise<void>} delete Remove the oracle from the aggregator\\n * @property {(result: any) => Promise<void>} pushResult rather than waiting for\\n * the polling query, push a result directly from this oracle\\n */ /**\\n * @callback PriceAggregatorCreatorFacetInitOracle\\n * @param {Instance} oracleInstance\\n * @param {unknown=} query\\n * @returns {Promise<OracleAdmin>}\\n */ /**\\n * @typedef {Object} PriceAggregatorCreatorFacet\\n * @property {(quoteMint: Mint) => Promise<void>} initializeQuoteMint\\n * @property {PriceAggregatorCreatorFacetInitOracle} initOracle\\n */ /**\\n * @typedef {Object} PriceAggregatorPublicFacet\\n * @property {() => PriceAuthority} getPriceAuthority\\n */ /**\\n * @typedef {Object} PriceAggregatorKit\\n * @property {PriceAggregatorPublicFacet} publicFacet\\n * @property {PriceAggregatorCreatorFacet} creatorFacet\\n */ /**\\n * @typedef {Object} OraclePublicFacet the public methods accessible from the\\n * contract instance\\n * @property {(query: any) => ERef<Invitation>} makeQueryInvitation create an\\n * invitation for an oracle query\\n * @property {(query: any) => ERef<any>} query make an unpaid query\\n */ /**\\n * @callback OracleCreatorFacetMakeWithdrawInvitation\\n * @param {boolean=} total\\n * @returns {ERef<Invitation>}\\n */ /**\\n * @typedef {Object} OracleCreatorFacet the private methods accessible from the\\n * contract instance\\n * @property {() => AmountKeywordRecord} getCurrentFees get the current\\n * fee amounts\\n * @property {OracleCreatorFacetMakeWithdrawInvitation}\\n * makeWithdrawInvitation create an invitation to withdraw fees\\n * @property {() => Promise<Invitation>} makeShutdownInvitation\\n *   Make an invitation to withdraw all fees and shutdown\\n */ /**\\n * @typedef {Object} OraclePrivateParameters\\n * @property {OracleHandler} oracleHandler\\n */ /**\\n * @typedef {Object} OracleInitializationFacet\\n * @property {(privateParams: OraclePrivateParameters) => OracleCreatorFacet} initialize\\n */ /**\\n * @typedef {Object} OracleStartFnResult\\n * @property {OracleInitializationFacet} creatorFacet\\n * @property {OraclePublicFacet} publicFacet\\n * @property {Instance} instance\\n */ /**\\n * @typedef {Object} OracleKit\\n * @property {OracleCreatorFacet} creatorFacet\\n * @property {OraclePublicFacet} publicFacet\\n * @property {Instance} instance\\n */ /**\\n * @typedef {Object} OracleReply\\n * @property {any} reply\\n * @property {Amount} [requiredFee]\\n */ /**\\n * @typedef {Object} OracleHandler\\n * @property {(query: any, fee: Amount) => Promise<OracleReply>} onQuery\\n * callback to reply to a query\\n * @property {(query: any, reason: any) => void} onError notice an error\\n * @property {(query: any, reply: any, requiredFee: Amount | undefined) => void}\\n * onReply notice a successful reply\\n */\",\n  \"zoe/src/contracts/callSpread/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {'long' | 'short'} PositionKind\\n */ /**\\n * @callback MakeOptionInvitation\\n * @param {PositionKind} positionKind\\n * @returns {Promise<Payment>}\\n */ /**\\n * @typedef {Object} PayoffHandler\\n * @property {() => void} schedulePayoffs\\n * @property  {MakeOptionInvitation} makeOptionInvitation\\n */ /**\\n * @callback MakePayoffHandler\\n * @param {ContractFacet} zcf\\n * @param {Record<PositionKind,PromiseRecord<ZCFSeat>>} seatPromiseKits\\n * @param {ZCFSeat} collateralSeat\\n * @returns {PayoffHandler}\\n */ /**\\n * @callback Scale\\n * @param {Amount} amount\\n * @returns {Amount}\\n */ /**\\n * @callback MakePercent\\n * @param {bigint} value\\n * @param {Brand} brand\\n * @param {bigint=} base\\n * @returns {Percent}\\n */ /**\\n * @callback MakeCanonicalPercent\\n * @param {Brand} brand\\n * @returns {Percent}\\n */ /**\\n * @callback CalculatePercent\\n * @param {Amount} numerator\\n * @param {Amount} denominator\\n * @param {bigint=} base\\n * @returns {Percent}\\n */ /**\\n * @typedef {Object} Percent\\n * @property {Scale} scale\\n * @property {() => Percent} complement\\n * @property {() => Ratio} makeRatio\\n */ /**\\n * @typedef {Object} CalculateSharesReturn\\n * Return value from calculateShares, which represents the portions assigned to\\n * the long and short side of a transaction. These will be two non-negative\\n * integers that sum to 100.\\n * @property {Ratio} longShare\\n * @property {Ratio} shortShare\\n */ /**\\n * @callback CalculateShares\\n * calculate the portion (as a percentage) of the collateral that should be\\n * allocated to the long side of a call spread contract. price gives the value\\n * of the underlying asset at closing that determines the payouts to the parties\\n *\\n * if price <= strikePrice1, return Ratio representing 0\\n * if price >= strikePrice2, return Ratio representing 1.\\n * Otherwise return longShare and shortShare representing ratios between 0% and\\n * 100% reflecting the position of the price in the range from strikePrice1 to\\n * strikePrice2.\\n * @param {Brand} collateralBrand\\n * @param {Amount} price\\n * @param {Amount} strikePrice1\\n * @param {Amount} strikePrice2\\n * @returns {CalculateSharesReturn}\\n */ /**\\n * @callback oneMinus\\n * @param {Ratio} ratio\\n * @returns {Ratio}\\n */ /**\\n * @callback Make100Percent\\n * @param {Brand} brand\\n * @returns {Ratio}\\n */ /**\\n * @callback Make0Percent\\n * @param {Brand} brand\\n * @returns {Ratio}\\n */\",\n  \"zoe/src/contracts/exported.js\": \"'use strict';require('./types.js');require('./loan/types.js');require('./multipoolAutoswap/types.js');require('./priceAggregatorTypes.js');require('./callSpread/types.js');\",\n  \"zoe/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @template {string} H - the name of the handle\\n * @typedef {H & {}} Handle A type constructor for an opaque type\\n * identified by the H string. This uses an intersection type\\n * ('MyHandle' & {}) to tag the handle's type even though the actual\\n * value is just an empty object.\\n */ /**\\n * @typedef {string} Keyword\\n * @typedef {Handle<'Invitation'>} InvitationHandle - an opaque handle for an invitation\\n * @typedef {Record<Keyword,Issuer>} IssuerKeywordRecord\\n * @typedef {Record<Keyword,Brand>} BrandKeywordRecord\\n * @typedef {Record<Keyword, DeprecatedAmountMath>} DeprecatedAmountMathKeywordRecord\\n */ /**\\n * @typedef {Object} StandardTerms\\n * @property {IssuerKeywordRecord} issuers - record with\\n * keywords keys, issuer values\\n * @property {BrandKeywordRecord} brands - record with keywords\\n * keys, brand values\\n * @property {DeprecatedAmountMathKeywordRecord} maths - record with keywords\\n * keys, amountMath values\\n *\\n * @typedef {StandardTerms & Record<string, any>} Terms\\n *\\n * @typedef {object} InstanceRecord\\n * @property {Installation} installation\\n * @property {Terms} terms - contract parameters\\n *\\n * @typedef {Object} IssuerRecord\\n * @property {Brand} brand\\n * @property {Issuer} issuer\\n * @property {DeprecatedAmountMath} amountMath\\n * @property {AmountMathKind} mathKind\\n * @property {any} [displayInfo]\\n *\\n * @typedef {AmountKeywordRecord} Allocation\\n * @typedef {Record<Keyword,AmountMath>} AmountMathKeywordRecord\\n */ /**\\n * @typedef {Payment} Invitation\\n */\",\n  \"zoe/tools/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} PriceQuote\\n * @property {Amount} quoteAmount Amount whose value is a PriceQuoteValue\\n * @property {ERef<Payment> | null} quotePayment The `quoteAmount` wrapped as a payment\\n */ /**\\n * @typedef {[PriceDescription]} PriceQuoteValue A single-valued set of\\n * PriceDescriptions.  This is the `value` in PriceQuote.quoteAmount (`{ brand,\\n * value: PriceQuoteValue }`).\\n */ /**\\n * @typedef {Object} PriceDescription A description of a single quote\\n * @property {Amount} amountIn The amount supplied to a trade\\n * @property {Amount} amountOut The quoted result of trading `amountIn`\\n * @property {TimerService} timer The service that gave the `timestamp`\\n * @property {Timestamp} timestamp A timestamp according to `timer` for the\\n * quote\\n * @property {any=} conditions Additional conditions for the quote\\n */ /**\\n * @callback PriceQuoteCreate\\n * @param {PriceQuery} priceQuery\\n * @returns {ERef<PriceQuote> | undefined}\\n */ /**\\n * @callback PriceQuoteTrigger\\n * @param {PriceQuoteCreate} createQuote\\n */ /**\\n * @typedef {Object} PriceAuthorityAdmin\\n * @property {(createQuote: PriceQuoteCreate) => Promise<void>} fireTriggers\\n */ /**\\n * @typedef {Object} PriceAuthorityKit\\n * @property {PriceAuthority} priceAuthority\\n * @property {PriceAuthorityAdmin} adminFacet\\n */ /**\\n * @typedef {Object} PriceAuthority An object that mints PriceQuotes and handles\\n * triggers and notifiers for changes in the price\\n *\\n * @property {(brandIn: Brand, brandOut: Brand) => ERef<Issuer>} getQuoteIssuer\\n * Get the ERTP issuer of PriceQuotes for a given brandIn/brandOut pair\\n *\\n * @property {(brandIn: Brand, brandOut: Brand) => ERef<TimerService>}\\n * getTimerService get the timer used in PriceQuotes for a given\\n * brandIn/brandOut pair\\n *\\n * @property {(amountIn: Amount, brandOut: Brand) => ERef<Notifier<PriceQuote>>}\\n * makeQuoteNotifier Be notified of the latest PriceQuotes for a given\\n * `amountIn`.  The rate at which these are issued may be very different between\\n * `priceAuthorities`.\\n *\\n * @property {(deadline: Timestamp, amountIn: Amount, brandOut: Brand) =>\\n * Promise<PriceQuote>} quoteAtTime Resolves after `deadline` passes on the\\n * priceAuthority's timerService with the price quote of `amountIn` at that time\\n *\\n * @property {(amountIn: Amount, brandOut: Brand) => Promise<PriceQuote>}\\n * quoteGiven get a quote corresponding to the specified amountIn\\n *\\n * @property {(brandIn: Brand, amountOut: Amount) => Promise<PriceQuote>}\\n * quoteWanted get a quote corresponding to the specified amountOut\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenGT Resolve when a price quote of `amountIn` exceeds `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenGTE Resolve when a price quote of `amountIn` reaches or exceeds\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenLTE Resolve when a price quote of `amountIn` reaches or drops below\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenLT Resolve when the price quote of `amountIn` drops below\\n * `amountOutLimit`\\n */ /**\\n * @typedef {(amount: Amount) => Amount} PriceCalculator\\n */ /**\\n * @callback PriceQuery\\n * @param {PriceCalculator} calcAmountIn\\n * @param {PriceCalculator} calcAmountOut\\n * @returns {{ amountIn: Amount, amountOut: Amount, timestamp?: Timestamp }=}\\n */\",\n  \"notifier/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').ERef<T>} ERef\\n */ /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').PromiseRecord<T>} PromiseRecord\\n */ /**\\n * @template T\\n * @typedef {Object} IterationObserver<T>\\n * A valid sequence of calls to the methods of an `IterationObserver`\\n * represents an iteration. A valid sequence consists of any number of calls\\n * to `updateState` with the successive non-final values, followed by a\\n * final call to either `finish` with a successful `completion` value\\n * or `fail` with the alleged `reason` for failure. After at most one\\n * terminating calls, no further calls to these methods are valid and must be\\n * rejected.\\n * @property {(nonFinalValue: T) => void} updateState\\n * @property {(completion: T) => void} finish\\n * @property {(reason: any) => void} fail\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {number | undefined} UpdateCount a value used to mark the position\\n * in the update stream. For the last state, the updateCount is undefined.\\n */ /**\\n * @template T\\n * @typedef {Object} UpdateRecord<T>\\n * @property {T} value is whatever state the service wants to publish\\n * @property {UpdateCount} updateCount is a value that identifies the update\\n */ /**\\n * @template T\\n * @callback GetUpdateSince<T> Can be called repeatedly to get a sequence of\\n * update records\\n * @param {UpdateCount} [updateCount] return update record as of an update\\n * count. If the `updateCount` argument is omitted or differs from the current\\n * update count, return the current record.\\n * Otherwise, after the next state change, the promise will resolve to the\\n * then-current value of the record.\\n * @returns {Promise<UpdateRecord<T>>} resolves to the corresponding\\n * update\\n */ /**\\n * @template T\\n * @typedef {Object} BaseNotifier<T> an object that can be used to get the\\n * current state or updates\\n * @property {GetUpdateSince<T>} getUpdateSince return update record as of an\\n * update count.\\n */ /**\\n * @typedef {any} NotifierInternals Purposely opaque. Will be shared between\\n * machines, so it must be same to expose. But other software should avoid\\n * depending on its internal structure.\\n */ /**\\n * @template T\\n * @typedef {BaseNotifier<T> & AsyncIterable<T>} Notifier<T> an object that can\\n * be used to get the current state or updates\\n *\\n * @property {() => NotifierInternals} getSharableNotifierInternals\\n * Used to replicate the multicast values at other sites. To manually create a\\n * local representative of a Notification, do\\n * ```js\\n * localIterable =\\n *   makeNotifier(E(remoteIterable).getSharableNotifierInternals());\\n * ```\\n * The resulting `localIterable` also supports such remote use, and\\n * will return access to the same representation.\\n */ /**\\n * @template T\\n * @typedef {Object} NotifierRecord<T> the produced notifier/updater pair\\n * @property {IterationObserver<T>} updater the (closely-held) notifier producer\\n * @property {Notifier<T>} notifier the (widely-held) notifier consumer\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /* eslint-disable-next-line jsdoc/require-property*/ /**\\n * @template T\\n * @typedef {Object} BaseSubscription<T>\\n */ /**\\n * @typedef {any} SubscriptionInternals Purposely opaque. Will be shared between\\n * machines, so it must be same to expose. But other software should avoid\\n * depending on its internal structure.\\n */ /**\\n * @template T\\n * @typedef {BaseSubscription<T> & AsyncIterable<T>} Subscription<T>\\n * A form of AsyncIterable supporting distributed and multicast usage.\\n *\\n * @property {() => SubscriptionInternals} getSharableSubscriptionInternals\\n * Used to replicate the multicast values at other sites. To manually create a\\n * local representative of a Subscription, do\\n * ```js\\n * localIterable =\\n *   makeAsyncIterable(E(remoteIterable).getSharableSubscriptionInternals());\\n * ```\\n * The resulting `localIterable` also supports such remote use, and\\n * will return access to the same representation.\\n */ /**\\n * @template T\\n * @typedef {AsyncIterator<T> & AsyncIterable<T>} SubscriptionIterator<T>\\n * an AsyncIterator supporting distributed and multicast usage.\\n *\\n * @property {() => Subscription<T>} subscribe\\n * Get a new subscription whose starting position is this iterator's current\\n * position.\\n */ /**\\n * @template T\\n * @typedef {Object} SubscriptionRecord<T>\\n * @property {IterationObserver<T>} publication\\n * @property {Subscription<T>} subscription\\n */\",\n  \"notifier/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"ertp/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').ERef<T>} ERef\\n */ /**\\n * @typedef {Ximport('@agoric/marshal').InterfaceSpec} InterfaceSpec\\n * @typedef {Ximport('@agoric/marshal').GetInterfaceOf} GetInterfaceOf\\n */ /**\\n * @typedef {Object} Amount\\n * Amounts are descriptions of digital assets, answering the questions\\n * \\\"how much\\\" and \\\"of what kind\\\". Amounts are values labeled with a brand.\\n * AmountMath executes the logic of how amounts are changed when digital\\n * assets are merged, separated, or otherwise manipulated. For\\n * example, a deposit of 2 bucks into a purse that already has 3 bucks\\n * gives a new purse balance of 5 bucks. An empty purse has 0 bucks. AmountMath\\n * relies heavily on polymorphic MathHelpers, which manipulate the unbranded\\n * portion.\\n *\\n * @property {Brand} brand\\n * @property {Value} value\\n */ /**\\n * @typedef {NatValue | SetValue} Value\\n * Values describe the value of something that can be owned or shared.\\n * Fungible values are normally represented by natural numbers. Other\\n * values may be represented as strings naming a particular right, or\\n * an arbitrary object that sensibly represents the rights at issue.\\n *\\n * Value must be Comparable. (Would be nice to type this correctly.)\\n */ /**\\n * @typedef {'nat' | 'set' | 'strSet'} AmountMathKind\\n */ /**\\n * @callback MakeEmpty\\n * @param {Brand} brand\\n * @param {AmountMathKind=} mathKind\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} AmountMath\\n * Logic for manipulating amounts.\\n *\\n * Amounts are the canonical description of tradable goods. They are manipulated\\n * by issuers and mints, and represent the goods and currency carried by purses and\\n * payments. They can be used to represent things like currency, stock, and the\\n * abstract right to participate in a particular exchange.\\n *\\n * @property {(allegedValue: Value, brand: Brand) => Amount} make\\n * Make an amount from a value by adding the brand.\\n *\\n * @property {(allegedAmount: Amount, brand: Brand) => Amount} coerce\\n * Make sure this amount is valid and return it if so.\\n *\\n * @property {(amount: Amount, brand: Brand) => Value} getValue\\n * Extract and return the value.\\n *\\n * @property {MakeEmpty} makeEmpty\\n * Return the amount representing an empty amount. This is the\\n * identity element for MathHelpers.add and MatHelpers.subtract.\\n *\\n * @property {(amount: Amount) => Amount} makeEmptyFromAmount\\n * Return the amount representing an empty amount, using another\\n * amount as the template for the brand and mathKind.\\n *\\n * @property {(amount: Amount, brand?: Brand) => boolean} isEmpty\\n * Return true if the Amount is empty. Otherwise false.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => boolean} isGTE\\n * Returns true if the leftAmount is greater than or equal to the\\n * rightAmount. For non-scalars, \\\"greater than or equal to\\\" depends\\n * on the kind of amount, as defined by the MathHelpers. For example,\\n * whether rectangle A is greater than rectangle B depends on whether rectangle\\n * A includes rectangle B as defined by the logic in MathHelpers.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => boolean} isEqual\\n * Returns true if the leftAmount equals the rightAmount. We assume\\n * that if isGTE is true in both directions, isEqual is also true\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => Amount} add\\n * Returns a new amount that is the union of both leftAmount and rightAmount.\\n *\\n * For fungible amount this means adding the values. For other kinds of\\n * amount, it usually means including all of the elements from both\\n * left and right.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => Amount} subtract\\n * Returns a new amount that is the leftAmount minus the rightAmount\\n * (i.e. everything in the leftAmount that is not in the\\n * rightAmount). If leftAmount doesn't include rightAmount\\n * (subtraction results in a negative), throw  an error. Because the\\n * left amount must include the right amount, this is NOT equivalent\\n * to set subtraction.\\n */ /**\\n * @typedef {Object} DisplayInfo\\n * @property {number=} decimalPlaces\\n *   Tells the display software how many decimal places to move the\\n *   decimal over to the left, or in other words, which position corresponds to whole\\n *   numbers. We require fungible digital assets to be represented in\\n *   integers, in the smallest unit (i.e. USD might be represented in mill,\\n *   a thousandth of a dollar. In that case, `decimalPlaces` would be 3.)\\n *   This property is optional, and for non-fungible digital assets,\\n *   should not be specified.\\n *   The decimalPlaces property should be used for *display purposes only*. Any\\n *   other use is an anti-pattern.\\n */ /**\\n * @typedef {Object} Brand\\n * The brand identifies the kind of issuer, and has a function to get the\\n * alleged name for the kind of asset described. The alleged name (such\\n * as 'BTC' or 'moola') is provided by the maker of the issuer and should\\n * not be trusted as accurate.\\n *\\n * Every amount created by a particular AmountMath will share the same brand,\\n * but recipients cannot rely on the brand to verify that a purported amount\\n * represents the issuer they intended, since the same brand can be reused by\\n * a misbehaving issuer.\\n *\\n * @property {(allegedIssuer: ERef<Issuer>) => Promise<boolean>} isMyIssuer Should be used with\\n * `issuer.getBrand` to ensure an issuer and brand match.\\n * @property {() => string} getAllegedName\\n * @property {() => DisplayInfo} getDisplayInfo\\n *  Give information to UI on how to display the amount.\\n */ /**\\n * @typedef {ERef<Payment>} PaymentP\\n */ /**\\n * @callback IssuerBurn\\n * @param {PaymentP} payment\\n * @param {Amount=} optAmount\\n * @returns {Promise<Amount>}\\n */ /**\\n * @callback IssuerClaim\\n * @param {PaymentP} payment\\n * @param {Amount=} optAmount\\n * @returns {Promise<Payment>}\\n */ /**\\n * @typedef {Object} Issuer\\n * The issuer cannot mint a new amount, but it can create empty purses and\\n * payments. The issuer can also transform payments (splitting payments,\\n * combining payments, burning payments, and claiming payments\\n * exclusively). The issuer should be gotten from a trusted source and\\n * then relied upon as the decider of whether an untrusted payment is valid.\\n *\\n * @property {() => Brand} getBrand Get the Brand for this Issuer. The Brand\\n * indicates the kind of\\n * digital asset and is shared by the mint, the issuer, and any purses\\n * and payments of this particular kind. The brand is not closely\\n * held, so this function should not be trusted to identify an issuer\\n * alone. Fake digital assets and amount can use another issuer's brand.\\n *\\n * @property {() => string} getAllegedName Get the allegedName for this mint/issuer\\n * @property {() => AmountMathKind} getAmountMathKind Get the kind of\\n * MathHelpers used by this Issuer.\\n * @property {() => Purse} makeEmptyPurse Make an empty purse of this brand.\\n * @property {(payment: PaymentP) => Promise<boolean>} isLive\\n * Return true if the payment continues to exist.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {(payment: PaymentP) => Promise<Amount>} getAmountOf\\n * Get the amount of digital assets in the payment. Because the\\n * payment is not trusted, we cannot call a method on it directly,\\n * and must use the issuer instead.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {IssuerBurn} burn\\n * Burn all of the digital assets in the payment. `optAmount` is optional.\\n * If `optAmount` is present, the code will insist that the amount of\\n * the digital assets in the payment is equal to `optAmount`, to\\n * prevent sending the wrong payment and other confusion.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {IssuerClaim} claim\\n * Transfer all digital assets from the payment to a new payment and\\n * delete the original. `optAmount` is optional.\\n * If `optAmount` is present, the code will insist that the amount of\\n * digital assets in the payment is equal to `optAmount`, to prevent\\n * sending the wrong  payment and other confusion.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {(paymentsArray: PaymentP[]) => Promise<Payment>} combine\\n * Combine multiple payments into one payment.\\n *\\n * If any of the payments is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @property {(payment: PaymentP, paymentAmountA: Amount) => Promise<Payment[]>} split\\n * Split a single payment into two payments, A and B, according to the\\n * paymentAmountA passed in.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {(payment: PaymentP, amounts: Amount[]) => Promise<Payment[]>} splitMany\\n * Split a single payment into many payments, according to the\\n * amounts passed in.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n */ /**\\n * @callback MakeIssuerKit\\n * @param {string} allegedName\\n * @param {AmountMathKind} [amountMathKind=MathKind.NAT]\\n * @param {DisplayInfo=} [displayInfo=undefined]\\n * @returns {IssuerKit}\\n *\\n * The allegedName becomes part of the brand in asset descriptions. The\\n * allegedName doesn't have to be a string, but it will only be used for\\n * its value. The allegedName is useful for debugging and double-checking\\n * assumptions, but should not be trusted.\\n *\\n * The amountMathKind will be used to import a specific mathHelpers\\n * from the mathHelpers library. For example, natMathHelpers, the\\n * default, is used for basic fungible tokens.\\n *\\n *  `displayInfo` gives information to UI on how to display the amount.\\n *\\n * @typedef {Object} IssuerKit\\n * The return value of makeIssuerKit\\n *\\n * @property {Mint} mint\\n * @property {Issuer} issuer\\n * @property {DeprecatedAmountMath} amountMath\\n * @property {Brand} brand\\n * @property {AmountMathKind} amountMathKind\\n */ /**\\n * @typedef {Object} Mint\\n * Holding a Mint carries the right to issue new digital assets. These\\n * assets all have the same kind, which is called a Brand.\\n *\\n * @property {() => Issuer} getIssuer Gets the Issuer for this mint.\\n * @property {(newAmount: Amount) => Payment} mintPayment\\n * Creates a new Payment containing newly minted amount.\\n */ /**\\n * @callback DepositFacetReceive\\n * @param {Payment} payment\\n * @param {Amount=} optAmount\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} DepositFacet\\n * @property {DepositFacetReceive} receive\\n * Deposit all the contents of payment into the purse that made this facet,\\n * returning the amount. If the optional argument `optAmount` does not equal the\\n * amount of digital assets in the payment, throw an error.\\n *\\n * If payment is a promise, throw an error.\\n */ /**\\n * @callback PurseDeposit\\n * @param {Payment} payment\\n * @param {Amount=} optAmount\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} Purse\\n * Purses hold amount of digital assets of the same brand, but unlike Payments, they are\\n * not meant to be sent to others. To transfer digital assets, a\\n * Payment should be withdrawn from a Purse. The amount of digital\\n * assets in a purse can change through the action of deposit() and withdraw().\\n *\\n * The primary use for Purses and Payments is for currency-like and goods-like\\n * digital assets, but they can also be used to represent other kinds of rights, such\\n * as the right to participate in a particular contract.\\n *\\n * @property {() => Brand} getAllegedBrand Get the alleged Brand for this Purse\\n *\\n * @property {() => Amount} getCurrentAmount\\n * Get the amount contained in this purse.\\n *\\n * @property {() => Notifier<Amount>} getCurrentAmountNotifier\\n * Get a lossy notifier for changes to this purse's balance.\\n *\\n * @property {PurseDeposit} deposit\\n * Deposit all the contents of payment into this purse, returning the\\n * amount. If the optional argument `optAmount` does not equal the\\n * amount of digital assets in the payment, throw an error.\\n *\\n * If payment is a promise, throw an error.\\n *\\n * @property {() => DepositFacet} getDepositFacet\\n * Return an object whose `receive` method deposits to the current Purse.\\n *\\n * @property {(amount: Amount) => Payment} withdraw\\n * Withdraw amount from this purse into a new Payment.\\n */ /**\\n * @typedef {Object} Payment\\n * Payments hold amount of digital assets of the same brand in transit. Payments can\\n * be deposited in purses, split into multiple payments, combined, and\\n * claimed (getting an exclusive payment). Payments are linear, meaning\\n * that either a payment has the same amount of digital assets it\\n * started with, or it is used up entirely. It is impossible to partially use a payment.\\n *\\n * Payments are often received from other actors and therefore should\\n * not be trusted themselves. To get the amount of digital assets in a payment, use the\\n * trusted issuer: issuer.getAmountOf(payment),\\n *\\n * Payments can be converted to Purses by getting a trusted issuer and\\n * calling `issuer.makeEmptyPurse()` to create a purse, then `purse.deposit(payment)`.\\n *\\n * @property {() => Brand} getAllegedBrand\\n * Get the allegedBrand, indicating the kind of digital asset this\\n * payment purports to be, and which issuer to use. Because payments\\n * are not trusted, any method calls on payments should be treated\\n * with suspicion and verified elsewhere.\\n */ /**\\n * @template V\\n * @typedef {Object} MathHelpers<V>\\n * All of the difference in how digital asset amount are manipulated can be reduced to\\n * the behavior of the math on values. We extract this\\n * custom logic into mathHelpers. MathHelpers are about value\\n * arithmetic, whereas AmountMath is about amounts, which are the\\n * values labeled with a brand. AmountMath use mathHelpers to do their value arithmetic,\\n * and then brand the results, making a new amount.\\n *\\n * The MathHelpers are designed to be called only from AmountMath, and so\\n * all methods but coerce can assume their inputs are valid. They only\\n * need to do output validation, and only when there is a possibility of\\n * invalid output.\\n *\\n * @property {(allegedValue: V) => V} doCoerce\\n * Check the kind of this value and throw if it is not the\\n * expected kind.\\n *\\n * @property {() => V} doMakeEmpty\\n * Get the representation for the identity element (often 0 or an\\n * empty array)\\n *\\n * @property {(value: V) => boolean} doIsEmpty\\n * Is the value the identity element?\\n *\\n * @property {(left: V, right: V) => boolean} doIsGTE\\n * Is the left greater than or equal to the right?\\n *\\n * @property {(left: V, right: V) => boolean} doIsEqual\\n * Does left equal right?\\n *\\n * @property {(left: V, right: V) => Value} doAdd\\n * Return the left combined with the right.\\n *\\n * @property {(left: V, right: V) => V} doSubtract\\n * Return what remains after removing the right from the left. If\\n * something in the right was not in the left, we throw an error.\\n */ /**\\n * @typedef {bigint} NatValue\\n */ /**\\n * @typedef {Array<Comparable>} SetValue\\n */ /**\\n * @typedef {MathHelpers<NatValue>} NatMathHelpers\\n */ /**\\n * @typedef {MathHelpers<SetValue>} SetMathHelpers\\n */ /**\\n * @typedef {{ISSUER: 'issuer', BRAND: 'brand', PURSE: 'purse', PAYMENT:\\n * 'payment', MINT: 'mint', DEPOSIT_FACET: 'depositFacet' }} ERTPKind\\n */ /**\\n * @callback MakeInterface\\n * Make the interface using the allegedName and kind. The particular\\n * structure may change in the future to be more sophisticated.\\n * Therefore, ERTP and Zoe should not depend on this particular\\n * implementation.\\n *\\n * @param {string} allegedName The allegedName, as passed to\\n *  `makeIssuerKit`\\n * @param {string} kind The ERTPKind\\n * @returns {InterfaceSpec}\\n */ /**\\n * @callback MakeFarName\\n * Make the farName using the allegedName and kind. The particular\\n * structure may change in the future to be more sophisticated.\\n * Therefore, ERTP and Zoe should not depend on this particular\\n * implementation. `makeFar` converts its farName argument into\\n * the iface argument it passes to `Remotable`.\\n *\\n * @param {string} allegedName The allegedName, as passed to\\n *  `makeIssuerKit`\\n * @param {string} kind The ERTPKind\\n * @returns {string}\\n */ /**\\n * @typedef {Object} DeprecatedAmountMath\\n * This version of amountMath is deprecated. Please use `amountMath` directly\\n * as exported by `@agoric/ertp`.\\n *\\n * @property {() => Brand} getBrand Deprecated\\n * @property {() => AmountMathKind} getAmountMathKind  Deprecated\\n * @property {(allegedValue: Value) => Amount} make Deprecated\\n * @property {(allegedAmount: Amount) => Amount} coerce Deprecated\\n * @property {(amount: Amount) => Value} getValue Deprecated\\n * @property {() => Amount} getEmpty Deprecated\\n * @property {(amount: Amount) => boolean} isEmpty Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => boolean} isGTE Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => boolean} isEqual Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => Amount} add Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => Amount} subtract Deprecated\\n */\",\n  \"ertp/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"store/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {Record<string, Function>} ExternalInstance\\n */ /**\\n * @template K,V\\n * @typedef {Object} Store - A safety wrapper around a Map\\n * @property {(key: K) => boolean} has - Check if a key exists\\n * @property {(key: K, value: V) => void} init - Initialize the key only if it\\n * doesn't already exist\\n * @property {(key: K) => V} get - Return a value for the key. Throws if not\\n * found.\\n * @property {(key: K, value: V) => void} set - Set the key. Throws if not\\n * found.\\n * @property {(key: K) => void} delete - Remove the key. Throws if not found.\\n * @property {() => K[]} keys - Return an array of keys\\n * @property {() => V[]} values - Return an array of values\\n * @property {() => [K, V][]} entries - Return an array of entries\\n */ /**\\n * @template K,V\\n * @typedef {Object} WeakStore - A safety wrapper around a WeakMap\\n * @property {(key: any) => boolean} has - Check if a key exists\\n * @property {(key: K, value: V) => void} init - Initialize the key only if it\\n * doesn't already exist\\n * @property {(key: any) => V} get - Return a value for the key. Throws if not\\n * found.\\n * @property {(key: K, value: V) => void} set - Set the key. Throws if not\\n * found.\\n * @property {(key: K) => void} delete - Remove the key. Throws if not found.\\n */ /**\\n * Distinguishes between adding a new key (init) and updating or\\n * referencing a key (get, set, delete).\\n *\\n * `init` is only allowed if the key does not already exist. `Get`,\\n * `set` and `delete` are only allowed if the key does already exist.\\n *\\n * @template K,V\\n * @callback MakeWeakStore\\n * @param {string} [keyName='key'] - the column name for the key\\n * @returns {WeakStore<K,V>}\\n */ /**\\n * An external store for a given maker function.\\n * TODO: We should provide makers for other kinds of data structures.\\n * Weak sorted lists, weak priority queues, and many others.\\n *\\n * @template {(...args: Array<any>) => ExternalInstance} M\\n * @typedef {Object} ExternalStore\\n * @property {M} makeInstance Create a fresh instance\\n * @property {MakeWeakStore<ReturnType<M>, any>} makeWeakStore Create an\\n * external weak store indexed by an instance\\n */ /**\\n * @typedef {Record<string, any>} HydrateData\\n */ /**\\n * @typedef {[number, number]} HydrateKey\\n * @typedef {true} HydrateInit\\n * @typedef {Object} HydrateHook\\n * @property {(value: any) => HydrateKey} getKey\\n * @property {(key: HydrateKey) => any} load\\n * @property {(storeId: number) => void} drop\\n */ /**\\n * An external store that decouples the closure data from the returned\\n * \\\"representative\\\" instance.\\n *\\n * @template {Array<any>} A\\n * @template {ExternalInstance} T\\n * @callback MakeHydrateExternalStore\\n * @param {string} instanceKind\\n * @param {(...args: A) => HydrateData} adaptArguments\\n * @param {(init?: HydrateInit) => (data: HydrateData) => T} makeHydrate\\n * @returns {ExternalStore<(...args: A) => T>}\\n */ /**\\n * @typedef {Object} HydrateStore The store needed to save closed-over\\n * per-instance data\\n * @property {(id: number, data: HydrateData) => void} init\\n * @property {(id: number) => HydrateData} get\\n * @property {(id: number, data: HydrateData) => void} set\\n * @property {() => WeakStore<ExternalInstance, any>} makeWeakStore\\n */ /**\\n * @typedef {Object} BackingStore This is the master store that reifies storeIds\\n * @property {(storeId: number, instanceKind: string) => HydrateStore} makeHydrateStore\\n * @property {(storeId: number) => HydrateStore} getHydrateStore\\n */\",\n  \"store/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"swingset-vat/src/vats/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} TimerService Gives the ability to get the current time,\\n * schedule a single wake() call, create a repeater that will allow scheduling\\n * of events at regular intervals, or remove scheduled calls.\\n * @property {() => Timestamp} getCurrentTimestamp Retrieve the latest timestamp\\n * @property {(baseTime: Timestamp, waker: ERef<TimerWaker>) => Timestamp} setWakeup Return\\n * value is the time at which the call is scheduled to take place\\n * @property {(waker: ERef<TimerWaker>) => Array<Timestamp>} removeWakeup Remove the waker\\n * from all its scheduled wakeups, whether produced by `timer.setWakeup(h)` or\\n * `repeater.schedule(h)`.\\n * @property {(delay: RelativeTime, interval: RelativeTime) => TimerRepeater} createRepeater\\n * DEPRECATED: use makeRepeater instead.\\n * @property {(delaySecs: RelativeTime, interval: RelativeTime) => TimerRepeater} makeRepeater\\n * Create and return a repeater that will schedule `wake()` calls\\n * repeatedly at times that are a multiple of interval following delay.\\n * Interval is the difference between successive times at which wake will be\\n * called.  When `schedule(w)` is called, `w.wake()` will be scheduled to be\\n * called after the next multiple of interval from the base. Since times can be\\n * coarse-grained, the actual call may occur later, but this won't change when\\n * the next event will be called.\\n * @property {(delaySecs: RelativeTime, interval: RelativeTime) => Notifier<Timestamp>} makeNotifier\\n * Create and return a Notifier that will deliver updates repeatedly at times\\n * that are a multiple of interval following delay.\\n */ /**\\n * @typedef {bigint} Timestamp An absolute individual stamp returned by a\\n * TimerService.  Note that different timer services may have different\\n * interpretations of actual Timestamp values.\\n * @typedef {bigint} RelativeTime Difference between two Timestamps.  Note that\\n * different timer services may have different interpretations of actual\\n * RelativeTime values.\\n */ /**\\n * @typedef {Object} TimerWaker\\n * @property {(timestamp: Timestamp) => void} wake The timestamp passed to\\n * `wake()` is the time that the call was scheduled to occur.\\n */ /**\\n * @typedef {Object} TimerRepeater\\n * @property {(waker: ERef<TimerWaker>) => Timestamp} schedule Returns the time scheduled for\\n * the first call to `E(waker).wake()`.  The waker will continue to be scheduled\\n * every interval until the repeater is disabled.\\n * @property {() => void} disable Disable this repeater, so `schedule(w)` can't\\n * be called, and wakers already scheduled with this repeater won't be\\n * rescheduled again after `E(waker).wake()` is next called on them.\\n */\",\n  \"swingset-vat/exported.js\": \"'use strict';require('./src/vats/types.js');\",\n  \"zoe/exported.js\": \"'use strict';require('./src/contractFacet/types.js');require('./src/zoeService/types.js');require('./src/contractSupport/types.js');require('./src/contracts/exported.js');require('./src/types.js');require('./tools/types.js');require('../notifier/exported.js');require('../ertp/exported.js');require('../store/exported.js');require('../swingset-vat/exported.js');\",\n  \"assert/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* @ts-check*/ /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /* Based on*/ /* https://github.com/Agoric/SES-shim/blob/master/packages/ses/src/error/types.js*/ /* Coordinate edits until we refactor to avoid this duplication*/ /**\\n * @callback BaseAssert\\n * The `assert` function itself.\\n *\\n * @param {*} flag The truthy/falsy value\\n * @param {Details=} optDetails The details to throw\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {asserts flag}\\n */ /**\\n * @callback AssertMakeError\\n *\\n * The `assert.error` method, recording details for the console.\\n *\\n * The optional `optDetails` can be a string.\\n * @param {Details=} optDetails The details of what was asserted\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {Error}\\n */ /**\\n * @callback AssertFail\\n *\\n * The `assert.fail` method.\\n *\\n * Fail an assertion, recording details to the console and\\n * raising an exception with just type information.\\n *\\n * The optional `optDetails` can be a string for backwards compatibility\\n * with the nodejs assertion library.\\n * @param {Details=} optDetails The details of what was asserted\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {never}\\n */ /**\\n * @callback AssertEqual\\n * The `assert.equal` method\\n *\\n * Assert that two values must be `Object.is`.\\n * @param {*} actual The value we received\\n * @param {*} expected What we wanted\\n * @param {Details=} optDetails The details to throw\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {void}\\n */ /* Type all the overloads of the assertTypeof function.*/ /* There may eventually be a better way to do this, but*/ /* thems the breaks with Typescript 4.0.*/ /**\\n * @callback AssertTypeofBigint\\n * @param {any} specimen\\n * @param {'bigint'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is bigint}\\n *\\n * @callback AssertTypeofBoolean\\n * @param {any} specimen\\n * @param {'boolean'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is boolean}\\n *\\n * @callback AssertTypeofFunction\\n * @param {any} specimen\\n * @param {'function'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is Function}\\n *\\n * @callback AssertTypeofNumber\\n * @param {any} specimen\\n * @param {'number'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is number}\\n *\\n * @callback AssertTypeofObject\\n * @param {any} specimen\\n * @param {'object'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is Record<any, any> | null}\\n *\\n * @callback AssertTypeofString\\n * @param {any} specimen\\n * @param {'string'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is string}\\n *\\n * @callback AssertTypeofSymbol\\n * @param {any} specimen\\n * @param {'symbol'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is symbol}\\n *\\n * @callback AssertTypeofUndefined\\n * @param {any} specimen\\n * @param {'undefined'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is undefined}\\n */ /**\\n * The `assert.typeof` method\\n *\\n * @typedef {AssertTypeofBigint & AssertTypeofBoolean & AssertTypeofFunction & AssertTypeofNumber & AssertTypeofObject & AssertTypeofString & AssertTypeofSymbol & AssertTypeofUndefined} AssertTypeof\\n */ /**\\n * @callback AssertString\\n * The `assert.string` method.\\n *\\n * `assert.string(v)` is equivalent to `assert.typeof(v, 'string')`. We\\n * special case this one because it is the most frequently used.\\n *\\n * Assert an expected typeof result.\\n * @param {any} specimen The value to get the typeof\\n * @param {Details=} optDetails The details to throw\\n */ /**\\n * @callback AssertNote\\n * The `assert.note` method.\\n *\\n * Annotate this error with these details, potentially to be used by an\\n * augmented console, like the causal console of `console.js`, to\\n * provide extra information associated with logged errors.\\n *\\n * @param {Error} error\\n * @param {Details} detailsNote\\n * @returns {void}\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {{}} DetailsToken\\n * A call to the `details` template literal makes and returns a fresh details\\n * token, which is a frozen empty object associated with the arguments of that\\n * `details` template literal expression.\\n */ /**\\n * @typedef {string | DetailsToken} Details\\n * Either a plain string, or made by the `details` template literal tag.\\n */ /**\\n * @typedef {Object} StringablePayload\\n * Holds the payload passed to quote so that its printed form is visible.\\n * @property {() => string} toString How to print the payload\\n */ /**\\n * To \\\"declassify\\\" and quote a substitution value used in a\\n * details`...` template literal, enclose that substitution expression\\n * in a call to `quote`. This states that the argument should appear quoted\\n * (as if with `JSON.stringify`), in the error message of the thrown error. The\\n * payload itself is still passed unquoted to the console as it would be\\n * without `quote`.\\n *\\n * Starting from the example in the `details` comment, say instead that the\\n * color the sky is supposed to be is also computed. Say that we still don't\\n * want to reveal the sky's actual color, but we do want the thrown error's\\n * message to reveal what color the sky was supposed to be:\\n * ```js\\n * assert.equal(\\n *   sky.color,\\n *   color,\\n *   details`${sky.color} should be ${quote(color)}`,\\n * );\\n * ```\\n *\\n * The normal convention is to locally rename `details` to `X` and import `q`\\n * and `assert` unmodified.\\n * ```js\\n * import { assert, details as X, q } from \\\\'@agoric/assert\\\\';\\n * ```\\n * so the above example would then be\\n * ```js\\n * assert.equal(\\n *   sky.color,\\n *   color,\\n *   X`${sky.color} should be ${q(color)}`,\\n * );\\n * ```\\n *\\n * @callback AssertQuote\\n * @param {*} payload What to declassify\\n * @returns {StringablePayload} The declassified payload\\n */ /**\\n * @callback Raise\\n *\\n * To make an `assert` which terminates some larger unit of computation\\n * like a transaction, vat, or process, call `makeAssert` with a `Raise`\\n * callback, where that callback actually performs that larger termination.\\n * If possible, the callback should also report its `reason` parameter as\\n * the alleged reason for the termination.\\n *\\n * @param {Error} reason\\n */ /**\\n * @callback MakeAssert\\n *\\n * Makes and returns an `assert` function object that shares the bookkeeping\\n * state defined by this module with other `assert` function objects made by\\n * `makeAssert`. This state is per-module-instance and is exposed by the\\n * `loggedErrorHandler` above. We refer to `assert` as a \\\"function object\\\"\\n * because it can be called directly as a function, but also has methods that\\n * can be called.\\n *\\n * If `optRaise` is provided, the returned `assert` function object will call\\n * `optRaise(reason)` before throwing the error. This enables `optRaise` to\\n * engage in even more violent termination behavior, like terminating the vat,\\n * that prevents execution from reaching the following throw. However, if\\n * `optRaise` returns normally, which would be unusual, the throw following\\n * `optRaise(reason)` would still happen.\\n *\\n * @param {Raise=} optRaise\\n * @returns {Assert}\\n */ /**\\n * @typedef {(template: TemplateStringsArray | string[], ...args: any) => DetailsToken} DetailsTag\\n *\\n * Use the `details` function as a template literal tag to create\\n * informative error messages. The assertion functions take such messages\\n * as optional arguments:\\n * ```js\\n * assert(sky.isBlue(), details`${sky.color} should be \\\"blue\\\"`);\\n * ```\\n * The details template tag returns a `DetailsToken` object that can print\\n * itself with the formatted message in two ways.\\n * It will report the real details to\\n * the console but include only the typeof information in the thrown error\\n * to prevent revealing secrets up the exceptional path. In the example\\n * above, the thrown error may reveal only that `sky.color` is a string,\\n * whereas the same diagnostic printed to the console reveals that the\\n * sky was green.\\n *\\n * The `raw` member of a `template` is ignored, so a simple\\n * `string[]` can also be used as a template.\\n */ /**\\n * assert that expr is truthy, with an optional details to describe\\n * the assertion. It is a tagged template literal like\\n * ```js\\n * assert(expr, details`....`);`\\n * ```\\n *\\n * The literal portions of the template are assumed non-sensitive, as\\n * are the `typeof` types of the substitution values. These are\\n * assembled into the thrown error message. The actual contents of the\\n * substitution values are assumed sensitive, to be revealed to\\n * the console only. We assume only the virtual platform's owner can read\\n * what is written to the console, where the owner is in a privileged\\n * position over computation running on that platform.\\n *\\n * The optional `optDetails` can be a string for backwards compatibility\\n * with the nodejs assertion library.\\n *\\n * @typedef { BaseAssert & {\\n *   typeof: AssertTypeof,\\n *   error: AssertMakeError,\\n *   fail: AssertFail,\\n *   equal: AssertEqual,\\n *   string: AssertString,\\n *   note: AssertNote,\\n *   details: DetailsTag,\\n *   quote: AssertQuote,\\n *   makeAssert: MakeAssert,\\n * } } Assert\\n */\",\n  \"assert/src/assert.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js'); /* global globalThis */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst { freeze } = Object;\\n\\n/** @type {Assert} */\\nconst globalAssert = globalThis.assert;\\n\\nif (globalAssert === undefined) {\\n  throw new Error(\\n  `Cannot initialize @agoric/assert, missing globalThis.assert`);}\\n\\n\\n\\nconst missing = [\\n'fail',\\n'equal',\\n'typeof',\\n'string',\\n'note',\\n'details',\\n'quote',\\n'makeAssert'].\\nfilter(name => globalAssert[name] === undefined);\\nif (missing.length > 0) {\\n  throw new Error(\\n  `Cannot initialize @agoric/assert, missing globalThis.assert methods ${missing.join(\\n  ', ')\\n  }`);}\\n\\n\\n\\nconst { details, quote, makeAssert } = globalAssert;\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Prepend the correct indefinite article onto a noun, typically a typeof result\\n * e.g., \\\"an Object\\\" vs. \\\"a Number\\\"\\n *\\n * @deprecated\\n * @param {string} str The noun to prepend\\n * @returns {string} The noun prepended with a/an\\n */\\nfunction an(str) {\\n  str = `${str}`;\\n  if (str.length >= 1 && 'aeiouAEIOU'.includes(str[0])) {\\n    return `an ${str}`;}\\n\\n  return `a ${str}`;}\\n\\nfreeze(an);exports.an = an;exports.assert = globalAssert;exports.details = details;exports.makeAssert = makeAssert;exports.q = quote;exports.quote = quote;\",\n  \"nat/dist/nat.esm.js\": \"'use strict';\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* Copyright (C) 2011 Google Inc.*/ /* Copyright (C) 2018 Agoric*/ /**/ /* Licensed under the Apache License, Version 2.0 (the \\\"License\\\");*/ /* you may not use this file except in compliance with the License.*/ /* You may obtain a copy of the License at*/ /**/ /* http://www.apache.org/licenses/LICENSE-2.0*/ /**/ /* Unless required by applicable law or agreed to in writing, software*/ /* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,*/ /* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/ /* See the License for the specific language governing permissions and*/ /* limitations under the License.*/ /* @ts-check*/ /**\\n * Is `allegedNum` a number in the [contiguous range of exactly and\\n * unambiguously\\n * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)\\n *  natural numbers (non-negative integers)?\\n *\\n * To qualify `allegedNum` must either be a\\n * non-negative `bigint`, or a non-negative `number` representing an integer\\n * within range of [integers safely representable in\\n * floating point](https://tc39.es/ecma262/#sec-number.issafeinteger).\\n *\\n * @param {any} allegedNum\\n * @returns {boolean}\\n */\\nfunction isNat(allegedNum) {\\n  if (typeof allegedNum === 'bigint') {\\n    return allegedNum >= 0;}\\n\\n\\n  return Number.isSafeInteger(allegedNum) && allegedNum >= 0;}\\n\\n\\n/**\\n * If `allegedNumber` passes the `isNat` test, then return it as a bigint.\\n * Otherwise throw an appropriate error.\\n *\\n * If `allegedNum` is neither a bigint nor a number, `Nat` throws a `TypeError`.\\n * Otherwise, if it is not a [safely\\n * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)\\n * non-negative integer, `Nat` throws a `RangeError`.\\n * Otherwise, it is converted to a bigint if necessary and returned.\\n *\\n * @param {bigint | number} allegedNum\\n * @returns {bigint}\\n */\\nfunction Nat(allegedNum) {\\n  if (typeof allegedNum === 'bigint') {\\n    if (allegedNum < 0) {\\n      throw new RangeError(`${allegedNum} is negative`);}\\n\\n    return allegedNum;}\\n\\n\\n  if (typeof allegedNum === 'number') {\\n    if (!Number.isSafeInteger(allegedNum)) {\\n      throw new RangeError(`${allegedNum} not a safe integer`);}\\n\\n    if (allegedNum < 0) {\\n      throw new RangeError(`${allegedNum} is negative`);}\\n\\n    return BigInt(allegedNum);}\\n\\n\\n  throw new TypeError(\\n  `${allegedNum} is a ${typeof allegedNum} but must be a bigint or a number`);}exports.Nat = Nat;exports.isNat = isNat;\",\n  \"zoe/src/contractSupport/safeMath.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\n\\n\\nnat_esm = require('../../../nat/dist/nat.esm.js'); /* @ts-check*/ /**\\n * These operations should be used for calculations with the values of\\n * basic fungible tokens.\\n *\\n * natSafeMath is designed to be used directly, and so it needs to\\n * validate the inputs, as well as the outputs when necessary.\\n */\\nconst natSafeMath = harden({\\n  /* BigInts don't observably overflow*/\\n  add: (x, y) => nat_esm.Nat(x) + nat_esm.Nat(y),\\n  subtract: (x, y) => nat_esm.Nat(nat_esm.Nat(x) - nat_esm.Nat(y)),\\n  multiply: (x, y) => nat_esm.Nat(x) * nat_esm.Nat(y),\\n  floorDivide: (x, y) => nat_esm.Nat(x) / nat_esm.Nat(y),\\n  ceilDivide: (x, y) => {\\n    y = nat_esm.Nat(y);\\n    return nat_esm.Nat(nat_esm.Nat(x) + y - 1n) / y;},\\n\\n  /* Numbers and BigInts already compare magnitudes correctly.*/\\n  isGTE: (x, y) => x >= y });exports.natSafeMath = natSafeMath;\",\n  \"zoe/src/contractSupport/bondingCurves.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../../assert/src/assert.js');var nat_esm = require('../../../nat/dist/nat.esm.js');var safeMath = require('./safeMath.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\nconst { subtract, add, multiply, floorDivide } = safeMath.natSafeMath;\\n\\nconst BASIS_POINTS = 10000n; /* TODO change to 10_000n once tooling copes.*/\\n\\n/**\\n * Calculations for constant product markets like Uniswap.\\n * https://github.com/runtimeverification/verified-smart-contracts/blob/uniswap/uniswap/x-y-k.pdf\\n */\\n\\n/**\\n * Contains the logic for calculating how much should be given\\n * back to the user in exchange for what they sent in. Reused in\\n * several different places, including to check whether an offer\\n * is valid, getting the current price for an asset on user\\n * request, and to do the actual reallocation after an offer has\\n * been made.\\n *\\n * @param {NatValue} inputValue - the value of the asset sent\\n * in to be swapped\\n * @param {NatValue} inputReserve - the value in the liquidity\\n * pool of the kind of asset sent in\\n * @param {NatValue} outputReserve - the value in the liquidity\\n * pool of the kind of asset to be sent out\\n * @param {bigint} [feeBasisPoints=30n] - the fee taken in\\n * basis points. The default is 0.3% or 30 basis points. The fee\\n * is taken from inputValue\\n * @returns {NatValue} outputValue - the current price, in value form\\n */\\nconst getInputPrice = (\\ninputValue,\\ninputReserve,\\noutputReserve,\\nfeeBasisPoints = 30n) =>\\n{\\n  inputValue = nat_esm.Nat(inputValue);\\n  inputReserve = nat_esm.Nat(inputReserve);\\n  outputReserve = nat_esm.Nat(outputReserve);\\n  assert.assert(inputValue > 0n, assert.details`inputValue ${inputValue} must be positive`);\\n  assert.assert(inputReserve > 0n, assert.details`inputReserve ${inputReserve} must be positive`);\\n  assert.assert(\\n  outputReserve > 0n,\\n  assert.details`outputReserve ${outputReserve} must be positive`);\\n\\n\\n  const oneMinusFeeScaled = subtract(BASIS_POINTS, feeBasisPoints);\\n  const inputWithFee = multiply(inputValue, oneMinusFeeScaled);\\n  const numerator = multiply(inputWithFee, outputReserve);\\n  const denominator = add(multiply(inputReserve, BASIS_POINTS), inputWithFee);\\n  return floorDivide(numerator, denominator);};\\n\\n\\n/**\\n * Contains the logic for calculating how much should be taken\\n * from the user in exchange for what they want to obtain. Reused in\\n * several different places, including to check whether an offer\\n * is valid, getting the current price for an asset on user\\n * request, and to do the actual reallocation after an offer has\\n * been made.\\n *\\n * @param {NatValue} outputValue - the value of the asset the user wants\\n * to get\\n * @param {NatValue} inputReserve - the value in the liquidity\\n * pool of the asset being spent\\n * @param {NatValue} outputReserve - the value in the liquidity\\n * pool of the kind of asset to be sent out\\n * @param {bigint} [feeBasisPoints=30n] - the fee taken in\\n * basis points. The default is 0.3% or 30 basis points. The fee is taken from\\n * outputValue\\n * @returns {NatValue} inputValue - the value of input required to purchase output\\n */\\nconst getOutputPrice = (\\noutputValue,\\ninputReserve,\\noutputReserve,\\nfeeBasisPoints = 30n) =>\\n{\\n  outputValue = nat_esm.Nat(outputValue);\\n  inputReserve = nat_esm.Nat(inputReserve);\\n  outputReserve = nat_esm.Nat(outputReserve);\\n\\n  assert.assert(inputReserve > 0n, assert.details`inputReserve ${inputReserve} must be positive`);\\n  assert.assert(\\n  outputReserve > 0n,\\n  assert.details`outputReserve ${outputReserve} must be positive`);\\n\\n  assert.assert(\\n  outputReserve > outputValue,\\n  assert.details`outputReserve ${outputReserve} must be greater than outputValue ${outputValue}`);\\n\\n\\n  const oneMinusFeeScaled = subtract(BASIS_POINTS, feeBasisPoints);\\n  const numerator = multiply(multiply(outputValue, inputReserve), BASIS_POINTS);\\n  const denominator = multiply(\\n  subtract(outputReserve, outputValue),\\n  oneMinusFeeScaled);\\n\\n  return add(floorDivide(numerator, denominator), 1n);};\\n\\n\\n/* Calculate how many liquidity tokens we should be minting to send back to the*/\\n/* user when adding liquidity. We provide new liquidity equal to the existing*/\\n/* liquidity multiplied by the ratio of new central tokens to central tokens*/\\n/* already held. If the current supply is zero, return the inputValue as the*/\\n/* initial liquidity to mint is arbitrary.*/\\nconst calcLiqValueToMint = (\\nliqTokenSupply,\\ninputValue,\\ninputReserve) =>\\n{\\n  liqTokenSupply = nat_esm.Nat(liqTokenSupply);\\n  inputValue = nat_esm.Nat(inputValue);\\n  inputReserve = nat_esm.Nat(inputReserve);\\n\\n  if (liqTokenSupply === 0n) {\\n    return inputValue;}\\n\\n  return floorDivide(multiply(inputValue, liqTokenSupply), inputReserve);};\\n\\n\\n/**\\n * Calculate how much of the secondary token is required from the user when\\n * adding liquidity. We require that the deposited ratio of central to secondary\\n * match the current ratio of holdings in the pool.\\n *\\n * @param {NatValue} centralIn - The value of central assets being deposited\\n * @param {NatValue} centralPool - The value of central assets in the pool\\n * @param {NatValue} secondaryPool - The value of secondary assets in the pool\\n * @param {NatValue} secondaryIn - The value of secondary assets provided. If\\n * the pool is empty, the entire amount will be accepted\\n * @returns {NatValue} - the amount of secondary required\\n */\\nconst calcSecondaryRequired = (\\ncentralIn,\\ncentralPool,\\nsecondaryPool,\\nsecondaryIn) =>\\n{\\n  centralIn = nat_esm.Nat(centralIn);\\n  centralPool = nat_esm.Nat(centralPool);\\n  secondaryPool = nat_esm.Nat(secondaryPool);\\n  secondaryIn = nat_esm.Nat(secondaryIn);\\n\\n  if (centralPool === 0n || secondaryPool === 0n) {\\n    return secondaryIn;}\\n\\n\\n  const scaledSecondary = floorDivide(\\n  multiply(centralIn, secondaryPool),\\n  centralPool);\\n\\n  const exact =\\n  multiply(centralIn, secondaryPool) ===\\n  multiply(scaledSecondary, centralPool);\\n\\n  /* doesn't match the x-y-k.pdf paper, but more correct. When the ratios are*/\\n  /* exactly equal, lPrime is exactly l * (1 + alpha) and adding one is wrong*/\\n  return exact ? scaledSecondary : 1n + scaledSecondary;};\\n\\n\\n/* Calculate how many underlying tokens (in the form of a value) should be*/\\n/* returned when removing liquidity.*/\\nconst calcValueToRemove = (\\nliqTokenSupply,\\npoolValue,\\nliquidityValueIn) =>\\n{\\n  liqTokenSupply = nat_esm.Nat(liqTokenSupply);\\n  liquidityValueIn = nat_esm.Nat(liquidityValueIn);\\n  poolValue = nat_esm.Nat(poolValue);\\n\\n  return floorDivide(multiply(liquidityValueIn, poolValue), liqTokenSupply);};exports.calcLiqValueToMint = calcLiqValueToMint;exports.calcSecondaryRequired = calcSecondaryRequired;exports.calcValueToRemove = calcValueToRemove;exports.getInputPrice = getInputPrice;exports.getOutputPrice = getOutputPrice;\",\n  \"eventual-send/src/track-turns.js\": \"'use strict';\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* global globalThis */ /* @ts-nocheck*/ /* NOTE: We can't import these because they're not in scope before lockdown.*/ /* import { assert, details as X } from '@agoric/assert';*/ /* WARNING: Global Mutable State!*/ /* This state is communicated to `assert` that makes it available to the*/ /* causal console, which affects the console log output. Normally we*/ /* regard the ability to see console log output as a meta-level privilege*/ /* analogous to the ability to debug. Aside from that, this module should*/ /* not have any observably mutable state.*/\\n\\nlet hiddenPriorError;\\nlet hiddenCurrentTurn = 0;\\nlet hiddenCurrentEvent = 0;\\n\\n/* Turn on if you seem to be losing error logging at the top of the event loop*/\\nconst VERBOSE = false;\\n\\n/**\\n * @typedef {((...args: any[]) => any) | void} TurnStarterFn\\n * An optional function that is not this-sensitive, expected to be called at\\n * bottom of stack to start a new turn.\\n */\\n\\n/**\\n * Given a list of `TurnStarterFn`s, returns a list of `TurnStarterFn`s whose\\n * `this`-free call behaviors are not observably different to those that\\n * cannot see console output. The only purpose is to cause additional\\n * information to appear on the console.\\n *\\n * The call to `trackTurns` is itself a sending event, that occurs in some call\\n * stack in some turn number at some event number within that turn. Each call\\n * to any of the returned `TurnStartFn`s is a receiving event that begins a new\\n * turn. This sending event caused each of those receiving events.\\n *\\n * @param {TurnStarterFn[]} funcs\\n * @returns {TurnStarterFn[]}\\n */\\nconst trackTurns = funcs => {\\n  if (typeof globalThis === 'undefined' || !globalThis.assert) {\\n    return funcs;}\\n\\n  const { details: X } = assert;\\n\\n  hiddenCurrentEvent += 1;\\n  const sendingError = new Error(\\n  `Event: ${hiddenCurrentTurn}.${hiddenCurrentEvent}`);\\n\\n  if (hiddenPriorError !== undefined) {\\n    assert.note(sendingError, X`Caused by: ${hiddenPriorError}`);}\\n\\n\\n  return funcs.map(\\n  (func) =>\\n  func && (\\n  (...args) => {\\n    hiddenPriorError = sendingError;\\n    hiddenCurrentTurn += 1;\\n    hiddenCurrentEvent = 0;\\n    try {\\n      let result;\\n      try {\\n        result = func(...args);}\\n      catch (err) {\\n        if (err instanceof Error) {\\n          assert.note(\\n          err,\\n          X`Thrown from: ${hiddenPriorError}:${hiddenCurrentTurn}.${hiddenCurrentEvent}`);}\\n\\n\\n        if (VERBOSE) {\\n          console.log('THROWN to top of event loop', err);}\\n\\n        throw err;}\\n\\n      /* Must capture this now, not when the catch triggers.*/\\n      const detailsNote = X`Rejection from: ${hiddenPriorError}:${hiddenCurrentTurn}.${hiddenCurrentEvent}`;\\n      Promise.resolve(result).catch(reason => {\\n        if (reason instanceof Error) {\\n          assert.note(reason, detailsNote);}\\n\\n        if (VERBOSE) {\\n          console.log('REJECTED at top of event loop', reason);}});\\n\\n\\n      return result;} finally\\n    {\\n      hiddenPriorError = undefined;}}));};exports.trackTurns = trackTurns;\",\n  \"eventual-send/src/E.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\n\\ntrackTurns = require('./track-turns.js'); /* eslint-disable-next-line spaced-comment*/ /*/ <reference path=\\\"index.d.ts\\\" />*/\\n\\nconst readOnlyProxyHandler = {\\n  set(_target, _prop, _value) {\\n    return false;},\\n\\n  isExtensible(_target) {\\n    return false;},\\n\\n  setPrototypeOf(_target, _value) {\\n    return false;},\\n\\n  deleteProperty(_target, _prop) {\\n    return false;} };\\n\\n\\n\\n/**\\n * A Proxy handler for E(x).\\n *\\n * @param {*} x Any value passed to E(x)\\n * @param {*} HandledPromise\\n * @returns {ProxyHandler} the Proxy handler\\n */\\nfunction EProxyHandler(x, HandledPromise) {\\n  return harden({\\n    ...readOnlyProxyHandler,\\n    get(_target, p, _receiver) {\\n      /* Harden this Promise because it's our only opportunity to ensure*/\\n      /* p1=E(x).foo() is hardened. The Handled Promise API does not (yet)*/\\n      /* allow the handler to synchronously influence the promise returned*/\\n      /* by the handled methods, so we must freeze it from the outside. See*/\\n      /* #95 for details.*/\\n      return (...args) => harden(HandledPromise.applyMethod(x, p, args));},\\n\\n    apply(_target, _thisArg, argArray = []) {\\n      return harden(HandledPromise.applyFunction(x, argArray));},\\n\\n    has(_target, _p) {\\n      /* We just pretend everything exists.*/\\n      return true;} });}\\n\\n\\n\\n\\n/**\\n * A Proxy handler for E.sendOnly(x)\\n * For now it is just a variant on the E(x) Proxy handler.\\n *\\n * @param {*} x Any value passed to E.sendOnly(x)\\n * @param {*} HandledPromise\\n * @returns {ProxyHandler} the Proxy handler\\n */\\nfunction EsendOnlyProxyHandler(x, HandledPromise) {\\n  return harden({\\n    ...readOnlyProxyHandler,\\n    get(_target, p, _receiver) {\\n      return (...args) => {\\n        HandledPromise.applyMethod(x, p, args);\\n        return undefined;};},\\n\\n\\n    apply(_target, _thisArg, argsArray = []) {\\n      HandledPromise.applyFunction(x, argsArray);\\n      return undefined;},\\n\\n    has(_target, _p) {\\n      /* We just pretend that every thing exists.*/\\n      return true;} });}\\n\\n\\n\\n\\nfunction makeE(HandledPromise) {\\n  function E(x) {\\n    const handler = EProxyHandler(x, HandledPromise);\\n    return harden(new Proxy(() => {}, handler));}\\n\\n\\n  const makeEGetterProxy = (x) =>\\n  new Proxy(Object.create(null), {\\n    ...readOnlyProxyHandler,\\n    has(_target, _prop) {\\n      return true;},\\n\\n    get(_target, prop) {\\n      return harden(HandledPromise.get(x, prop));} });\\n\\n\\n\\n  E.G = makeEGetterProxy;\\n  E.get = makeEGetterProxy;\\n  E.resolve = HandledPromise.resolve;\\n  E.sendOnly = x => {\\n    const handler = EsendOnlyProxyHandler(x, HandledPromise);\\n    return harden(new Proxy(() => {}, handler));};\\n\\n\\n  E.when = (x, onfulfilled = undefined, onrejected = undefined) => {\\n    const [onsuccess, onfailure] = trackTurns.trackTurns([onfulfilled, onrejected]);\\n    return HandledPromise.resolve(x).then(onsuccess, onfailure);};\\n\\n\\n  return harden(E);}exports.default = makeE;\",\n  \"eventual-send/src/no-shim.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var E$1 = require('./E.js'); /* global HandledPromise */\\n\\n\\nconst hp = HandledPromise;\\nconst E = E$1.default(HandledPromise);exports.E = E;exports.HandledPromise = hp;\",\n  \"promise-kit/src/promiseKit.js\": \"'use strict';\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* global globalThis */ /* @ts-check*/ /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/\\n\\nconst BestPipelinablePromise = globalThis.HandledPromise || Promise;\\n\\n/**\\n * @template T\\n * @typedef {Object} PromiseRecord A reified Promise\\n * @property {(value: ERef<T>) => void} resolve\\n * @property {(reason: any) => void} reject\\n * @property {Promise<T>} promise\\n */\\n\\n/**\\n * @template T\\n * @typedef {T | PromiseLike<T>} ERef\\n * A reference of some kind for to an object of type T. It may be a direct\\n * reference to a local T. It may be a local presence for a remote T. It may\\n * be a promise for a local or remote T. Or it may even be a thenable\\n * (a promise-like non-promise with a \\\"then\\\" method) for a T.\\n */\\n\\n/**\\n * Needed to prevent type errors where functions are detected to be undefined.\\n */\\nconst NOOP_INITIALIZER = harden(_ => {});\\n\\n/**\\n * makePromiseKit() builds a Promise object, and returns a record\\n * containing the promise itself, as well as separate facets for resolving\\n * and rejecting it.\\n *\\n * @template T\\n * @returns {PromiseRecord<T>}\\n */\\nfunction makePromiseKit() {\\n  /** @type {(value: T) => void} */\\n  let res = NOOP_INITIALIZER;\\n  /** @type {(reason: any) => void} */\\n  let rej = NOOP_INITIALIZER;\\n\\n  const p = new BestPipelinablePromise((resolve, reject) => {\\n    res = resolve;\\n    rej = reject;});\\n\\n  /* Node.js adds the `domain` property which is not a standard*/\\n  /* property on Promise. Because we do not know it to be ocap-safe,*/\\n  /* we remove it.*/\\n  if (p.domain) {\\n    /* deleting p.domain may break functionality. To retain current*/\\n    /* functionality at the expense of safety, set unsafe to true.*/\\n    const unsafe = false;\\n    if (unsafe) {\\n      const originalDomain = p.domain;\\n      Object.defineProperty(p, 'domain', {\\n        get() {\\n          return originalDomain;} });} else\\n\\n\\n    {\\n      delete p.domain;}}\\n\\n\\n  return harden({ promise: p, resolve: res, reject: rej });}\\n\\nharden(makePromiseKit);\\n\\n/**\\n * Determine if the argument is a Promise.\\n *\\n * @param {any} maybePromise The value to examine\\n * @returns {maybePromise is Promise} Whether it is a promise\\n */\\nfunction isPromise(maybePromise) {\\n  return Promise.resolve(maybePromise) === maybePromise;}\\n\\nharden(isPromise);exports.isPromise = isPromise;exports.makePromiseKit = makePromiseKit;\",\n  \"marshal/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference path=\\\"extra-types.d.ts\\\" />*/ /**\\n * @typedef { \\\"bigint\\\" | \\\"boolean\\\" | \\\"null\\\" | \\\"number\\\" | \\\"string\\\" | \\\"symbol\\\" | \\\"undefined\\\" | \\\"copyArray\\\" | \\\"copyRecord\\\" | \\\"copyError\\\" | \\\"promise\\\" | \\\"presence\\\" } PassStyle\\n * TODO \\\"presence\\\" above should indirect through REMOTE_STYLE to prepare\\n * for changing it to \\\"remotable\\\"\\n */ /* TODO declare more precise types throughout this file, so the type system*/ /* and IDE can be more helpful.*/ /**\\n * @typedef {*} Passable\\n *\\n * A Passable value that may be marshalled. It is classified as one of\\n * PassStyle. A Passable must be hardened.\\n *\\n * A Passable has a pass-by-copy superstructure. This includes the atomic\\n * pass-by-copy primitives (\\\"bigint\\\" | \\\"boolean\\\" | \\\"null\\\" | \\\"number\\\" |\\n * \\\"string\\\" | \\\"undefined\\\") and the composite pass-by-copy objects (\\\"copyArray\\\" |\\n * \\\"copyRecord\\\" | \\\"copyError\\\"). The composite pass-by-copy objects that may\\n * contain other Passables.\\n *\\n * A Passable's pass-by-copy superstructure ends in PassableCap leaves. The\\n * Passable can be further classified by the nature of these leaves. Since a\\n * Passable is hardened, its structure and classification is stable --- its\\n * structure and classification cannot change even if some of the objects are\\n * proxies.\\n */ /**\\n * @typedef {Passable} Comparable\\n *\\n * A Comparable is a Passable in which none of the leaves of the pass-by-copy\\n * superstructure are promises. Two Comparables may be compared by\\n * for equivalence according to `sameStructure`, which is the strongest\\n * equivalence class supported by marshal's distributed object semantics.\\n */ /**\\n * @typedef {Comparable} OnlyData\\n *\\n * A Comparable is OnlyData when its pass-by-copy superstructure has no leaves,\\n * i.e., when all the leaves of the data structure tree are primitive data\\n * types or empty composites.\\n */ /**\\n * @typedef {OnlyData} PureData\\n *\\n * An OnlyData value is PureData when it contains no hidden mutable state,\\n * e.g., when none of its pass-by-copy composite data objects are proxies. This\\n * cannot be determined by inspection. It can only be achieved by trusted\\n * construction. A PureData value cannot be used as a communications channel,\\n * and can therefore be safely shared with subgraphs that should not be able\\n * to communicate with each other.\\n */ /**\\n * @typedef {*} Remotable\\n * Might be an object explicitly deemed to be `Remotable`, an object inferred\\n * to be Remotable, or a remote presence of a Remotable.\\n */ /**\\n * @typedef {Promise | Remotable} PassableCap\\n * The leaves of a Passable's pass-by-copy superstructure.\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @template Slot\\n * @callback ConvertValToSlot\\n * @param {PassableCap} val\\n * @returns {Slot}\\n */ /**\\n * @template Slot\\n * @callback ConvertSlotToVal\\n * @param {Slot} slot\\n * @param {InterfaceSpec=} iface\\n * @returns {PassableCap}\\n */ /**\\n * @template T\\n * @typedef {{ '@qclass': T }} EncodingClass\\n */ /**\\n * @typedef {EncodingClass<'NaN'> |\\n * EncodingClass<'undefined'> |\\n * EncodingClass<'Infinity'> |\\n * EncodingClass<'-Infinity'> |\\n * EncodingClass<'bigint'> & { digits: string } |\\n * EncodingClass<'@@asyncIterator'> |\\n * EncodingClass<'ibid'> & { index: number } |\\n * EncodingClass<'error'> & { name: string, message: string, errorId?: string } |\\n * EncodingClass<'slot'> & { index: number, iface?: InterfaceSpec } |\\n * EncodingClass<'hilbert'> & { original: Encoding, rest?: Encoding }} EncodingUnion\\n * @typedef {{ [index: string]: Encoding, '@qclass'?: undefined }} EncodingRecord\\n * We exclude '@qclass' as a property in encoding records.\\n * @typedef {EncodingUnion | null | string | boolean | number | EncodingRecord} EncodingElement\\n */ /**\\n * @typedef {EncodingElement | NestedArray<EncodingElement>} Encoding\\n * The JSON structure that the data portion of a Passable serializes to.\\n *\\n * The QCLASS 'hilbert' is a reference to the Hilbert Hotel\\n * of https://www.ias.edu/ideas/2016/pires-hilbert-hotel\\n * If QCLASS appears as a property name in the data, we encode it instead\\n * as a QCLASS record of type 'hilbert'. To do so, we must move the other\\n * parts of the record into fields of the hilbert record.\\n */ /**\\n * @template Slot\\n * @typedef CapData\\n * @property {Encoding} body\\n * @property {Slot[]} slots\\n */ /**\\n * @template Slot\\n * @callback Serialize\\n * @param {Passable} val\\n * @returns {CapData<Slot>}\\n */ /**\\n * @typedef {\\\"allowCycles\\\" | \\\"warnOfCycles\\\" | \\\"forbidCycles\\\"} CyclePolicy\\n */ /**\\n * @template Slot\\n * @callback Unserialize\\n * @param {CapData<Slot>} data\\n * @param {CyclePolicy=} cyclePolicy\\n * @returns {Passable}\\n */ /**\\n * @template Slot\\n * @typedef Marshal\\n * @property {Serialize<Slot>} serialize\\n * @property {Unserialize<Slot>} unserialize\\n */ /**\\n * @template Slot\\n * @callback MakeMarshal\\n * @param {ConvertValToSlot=} convertValToSlot\\n * @param {ConvertSlotToVal=} convertSlotToVal\\n * @param {MakeMarshalOptions=} options\\n * @returns {Marshal}\\n */ /**\\n * @typedef MakeMarshalOptions\\n * @property {string=} marshalName\\n * @property {'on'|'off'=} errorTagging\\n * @property {(err: Error) => void=} marshalSaveError\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {string} InterfaceSpec\\n * This is an interface specification.\\n * For now, it is just a string, but will eventually be any OnlyData. Either\\n * way, it must remain pure, so that it can be safely shared by subgraphs that\\n * are not supposed to be able to communicate.\\n */ /**\\n * @callback MarshalGetInterfaceOf\\n * Simple semantics, just tell what interface (or undefined) a remotable has.\\n *\\n * @param {*} maybeRemotable the value to check\\n * @returns {InterfaceSpec|undefined} the interface specification, or undefined\\n * if not a deemed to be a Remotable\\n */\",\n  \"marshal/src/ibidTables.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var nat_esm = require('../../nat/dist/nat.esm.js');\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('./types.js'); /* @ts-check*/ /**\\n * The ibid logic relies on\\n *    * JSON.stringify on an array visiting array indexes from 0 to\\n *      arr.length -1 in order, and not visiting anything else.\\n *    * JSON.parse of a record (a plain object) creating an object on\\n *      which a getOwnPropertyNames will enumerate properties in the\\n *      same order in which they appeared in the parsed JSON string.\\n */\\nconst makeReplacerIbidTable = () => {\\n  /** @type {Map<object, number>} */\\n  const ibidMap = new Map();\\n  let ibidCount = 0;\\n\\n  return harden({\\n    /**\\n     * @param {object} obj\\n     */\\n    has(obj) {\\n      return ibidMap.has(obj);},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    get(obj) {\\n      return ibidMap.get(obj);},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    add(obj) {\\n      ibidMap.set(obj, ibidCount);\\n      ibidCount += 1;} });};\\n\\n\\n\\nharden(makeReplacerIbidTable);\\n\\n\\n/**\\n * @param {CyclePolicy} cyclePolicy\\n */\\nconst makeReviverIbidTable = cyclePolicy => {\\n  const ibids = [];\\n  const unfinishedIbids = new WeakSet();\\n\\n  return harden({\\n    /**\\n     * @param {number} allegedIndex\\n     * @returns {object}\\n     */\\n    get(allegedIndex) {\\n      const index = Number(nat_esm.Nat(allegedIndex));\\n      assert.assert(index < ibids.length, assert.details`ibid out of range: ${index}`, RangeError);\\n      const result = ibids[index];\\n      if (unfinishedIbids.has(result)) {\\n        switch (cyclePolicy) {\\n          case 'allowCycles':{\\n              break;}\\n\\n          case 'warnOfCycles':{\\n              console.log(`Warning: ibid cycle at ${index}`);\\n              break;}\\n\\n          case 'forbidCycles':{\\n              assert.assert.fail(assert.details`Ibid cycle at ${assert.quote(index)}`, TypeError);}\\n\\n          default:{\\n              assert.assert.fail(\\n              assert.details`Unrecognized cycle policy: ${assert.quote(cyclePolicy)}`,\\n              TypeError);}}}\\n\\n\\n\\n\\n      return result;},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    register(obj) {\\n      ibids.push(obj);\\n      return obj;},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    start(obj) {\\n      ibids.push(obj);\\n      unfinishedIbids.add(obj);\\n      return obj;},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    finish(obj) {\\n      unfinishedIbids.delete(obj);\\n      return obj;} });};\\n\\n\\n\\nharden(makeReviverIbidTable);exports.makeReplacerIbidTable = makeReplacerIbidTable;exports.makeReviverIbidTable = makeReviverIbidTable;\",\n  \"marshal/src/marshal.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var nat_esm = require('../../nat/dist/nat.esm.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');require('./types.js');var ibidTables = require('./ibidTables.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst {\\n  getPrototypeOf,\\n  setPrototypeOf,\\n  create,\\n  getOwnPropertyDescriptors,\\n  defineProperties,\\n  is,\\n  isFrozen,\\n  fromEntries,\\n  prototype: objectPrototype } =\\nObject;\\n\\nconst { ownKeys } = Reflect;\\n\\n/* TODO: Use just 'remote' when we're willing to make a breaking change.*/\\nconst REMOTE_STYLE = 'presence';\\n\\nconst PASS_STYLE = Symbol.for('passStyle');\\n\\n/** @type {MarshalGetInterfaceOf} */\\nfunction getInterfaceOf(val) {\\n  if (typeof val !== 'object' || val === null) {\\n    return undefined;}\\n\\n  if (val[PASS_STYLE] !== REMOTE_STYLE) {\\n    return undefined;}\\n\\n  assert.assert(isFrozen(val), assert.details`Remotable ${val} must be frozen`, TypeError);\\n  const iface = val[Symbol.toStringTag];\\n  assert.assert.typeof(\\n  iface,\\n  'string',\\n  assert.details`Remotable interface currently can only be a string`);\\n\\n  return iface;}\\n\\n\\n/**\\n * Do a deep copy of the object, handling Proxies and recursion.\\n * The resulting copy is guaranteed to be pure data, as well as hardened.\\n * Such a hardened, pure copy cannot be used as a communications path.\\n *\\n * @template T\\n * @param {T & OnlyData} val input value.  NOTE: Must be hardened!\\n * @param {WeakMap<any,any>} [already=new WeakMap()]\\n * @returns {T & PureData} pure, hardened copy\\n */\\nfunction pureCopy(val, already = new WeakMap()) {\\n  /* eslint-disable-next-line no-use-before-define*/\\n  const passStyle = passStyleOf(val);\\n  switch (passStyle) {\\n    case 'bigint':\\n    case 'boolean':\\n    case 'null':\\n    case 'number':\\n    case 'string':\\n    case 'undefined':\\n    case 'symbol':\\n      return val;\\n\\n    case 'copyArray':\\n    case 'copyRecord':{\\n        const obj = /** @type {Object} */val;\\n        if (already.has(obj)) {\\n          return already.get(obj);}\\n\\n\\n        /* Create a new identity.*/\\n        const copy = /** @type {T} */passStyle === 'copyArray' ? [] : {};\\n\\n        /* Prevent recursion.*/\\n        already.set(obj, copy);\\n\\n        /* Make a deep copy on the new identity.*/\\n        /* Object.entries(obj) takes a snapshot (even if a Proxy).*/\\n        /* Since we already know it is a copyRecord or copyArray, we*/\\n        /* know that Object.entries is safe enough. On a copyRecord it*/\\n        /* will represent all the own properties. On a copyArray it*/\\n        /* will represent all the own properties except for the length.*/\\n        Object.entries(obj).forEach(([prop, value]) => {\\n          copy[prop] = pureCopy(value, already);});\\n\\n        return harden(copy);}\\n\\n\\n    case 'copyError':{\\n        const unk = /** @type {unknown} */val;\\n        const err = /** @type {Error} */unk;\\n\\n        if (already.has(err)) {\\n          return already.get(err);}\\n\\n\\n        const { name, message } = err;\\n\\n        /* eslint-disable-next-line no-use-before-define*/\\n        const EC = getErrorConstructor(`${name}`) || Error;\\n        const copy = harden(new EC(`${message}`));\\n        already.set(err, copy);\\n\\n        const unk2 = /** @type {unknown} */harden(copy);\\n        return (/** @type {T} */unk2);}\\n\\n\\n    case REMOTE_STYLE:{\\n        assert.assert.fail(\\n        assert.details`Input value ${assert.quote(\\n        passStyle)\\n        } cannot be copied as it must be passed by reference`,\\n        TypeError);}\\n\\n\\n\\n    case 'promise':{\\n        assert.assert.fail(assert.details`Promises cannot be copied`, TypeError);}\\n\\n\\n    default:\\n      assert.assert.fail(\\n      assert.details`Input value ${assert.quote(passStyle)} is not recognized as data`,\\n      TypeError);}}\\n\\n\\n\\nharden(pureCopy);\\n\\n\\nconst errorConstructors = new Map([\\n['Error', Error],\\n['EvalError', EvalError],\\n['RangeError', RangeError],\\n['ReferenceError', ReferenceError],\\n['SyntaxError', SyntaxError],\\n['TypeError', TypeError],\\n['URIError', URIError]]);\\n\\n\\nfunction getErrorConstructor(name) {\\n  return errorConstructors.get(name);}\\n\\n\\n/**\\n * For most of these classification tests, we do strict validity `assert`s,\\n * throwing if we detect something invalid. For errors, we need to remember\\n * the error itself exists to help us diagnose a bug that's likely more\\n * pressing than a validity bug in the error itself. Thus, whenever it is safe\\n * to do so, we prefer to let the error test succeed and to couch these\\n * complaints as notes on the error.\\n *\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyError(val) {\\n  /* TODO: Need a better test than instanceof*/\\n  if (!(val instanceof Error)) {\\n    return false;}\\n\\n  const proto = getPrototypeOf(val);\\n  const { name } = val;\\n  const EC = getErrorConstructor(name);\\n  if (!EC || EC.prototype !== proto) {\\n    assert.assert.note(\\n    val,\\n    assert.details`Errors must inherit from an error class .prototype ${val}`);}\\n\\n\\n\\n  const {\\n    message: mDesc,\\n    /* Allow but ignore only extraneous own `stack` property.*/\\n    stack: _optStackDesc,\\n    ...restDescs } =\\n  getOwnPropertyDescriptors(val);\\n  if (ownKeys(restDescs).length >= 1) {\\n    assert.assert.note(\\n    val,\\n    assert.details`Passed Error has extra unpassed properties ${restDescs}`);}\\n\\n\\n  if (mDesc) {\\n    if (typeof mDesc.value !== 'string') {\\n      assert.assert.note(\\n      val,\\n      assert.details`Passed Error \\\"message\\\" ${mDesc} must be a string-valued data property.`);}\\n\\n\\n    if (mDesc.enumerable) {\\n      assert.assert.note(\\n      val,\\n      assert.details`Passed Error \\\"message\\\" ${mDesc} must not be enumerable`);}}\\n\\n\\n\\n  return true;}\\n\\n\\n/**\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyArray(val) {\\n  if (!Array.isArray(val)) {\\n    return false;}\\n\\n  assert.assert(\\n  getPrototypeOf(val) === Array.prototype,\\n  assert.details`Malformed array: ${val}`,\\n  TypeError);\\n\\n  const len = val.length;\\n  const descs = getOwnPropertyDescriptors(val);\\n  for (let i = 0; i < len; i += 1) {\\n    const desc = descs[i];\\n    assert.assert(desc, assert.details`Arrays must not contain holes: ${assert.quote(i)}`, TypeError);\\n    assert.assert(\\n    'value' in desc,\\n    assert.details`Arrays must not contain accessors: ${assert.quote(i)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    typeof desc.value !== 'function',\\n    assert.details`Arrays must not contain methods: ${assert.quote(i)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    desc.enumerable,\\n    assert.details`Array elements must be enumerable: ${assert.quote(i)}`,\\n    TypeError);}\\n\\n\\n  assert.assert(\\n  ownKeys(descs).length === len + 1,\\n  assert.details`Arrays must not have non-indexes: ${val}`,\\n  TypeError);\\n\\n  return true;}\\n\\n\\n/**\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyRecord(val) {\\n  const proto = getPrototypeOf(val);\\n  if (proto !== objectPrototype) {\\n    return false;}\\n\\n  const descs = getOwnPropertyDescriptors(val);\\n  const descKeys = ownKeys(descs);\\n\\n  for (const descKey of descKeys) {\\n    if (typeof descKey === 'symbol') {\\n      return false;}\\n\\n    const desc = descs[descKey];\\n    if (typeof desc.value === 'function') {\\n      return false;}}\\n\\n\\n  for (const descKey of descKeys) {\\n    assert.assert.typeof(\\n    descKey,\\n    'string',\\n    assert.details`Pass by copy records can only have string-named own properties`);\\n\\n    const desc = descs[descKey];\\n    assert.assert(\\n    !('get' in desc),\\n    assert.details`Records must not contain accessors: ${assert.quote(descKey)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    desc.enumerable,\\n    assert.details`Record fields must be enumerable: ${assert.quote(descKey)}`,\\n    TypeError);}\\n\\n\\n  return true;}\\n\\n\\nconst makeRemotableProto = (oldProto, allegedName) => {\\n  assert.assert(\\n  oldProto === objectPrototype || oldProto === null,\\n  assert.details`For now, remotables cannot inherit from anything unusual`);\\n\\n  /* Assign the arrow function to a variable to set its .name.*/\\n  const toString = () => `[${allegedName}]`;\\n  return harden(\\n  create(oldProto, {\\n    [PASS_STYLE]: { value: REMOTE_STYLE },\\n    toString: { value: toString },\\n    [Symbol.toStringTag]: { value: allegedName } }));};\\n\\n\\n\\n\\n/**\\n * Throw if val is not the correct shape for the prototype of a Remotable.\\n *\\n * TODO: It would be nice to typedef this shape and then declare that this\\n * function asserts it, but we can't declare a type with PASS_STYLE from JSDoc.\\n *\\n * @param {{ [PASS_STYLE]: string, [Symbol.toStringTag]: string, toString: () =>\\n * void}} val the value to verify\\n */\\nconst assertRemotableProto = val => {\\n  assert.assert.typeof(val, 'object', assert.details`cannot serialize non-objects like ${val}`);\\n  assert.assert(!Array.isArray(val), assert.details`Arrays cannot be pass-by-remote`);\\n  assert.assert(val !== null, assert.details`null cannot be pass-by-remote`);\\n\\n  const protoProto = getPrototypeOf(val);\\n  assert.assert(\\n  protoProto === objectPrototype || protoProto === null,\\n  assert.details`The Remotable Proto marker cannot inherit from anything unusual`);\\n\\n  assert.assert(isFrozen(val), assert.details`The Remotable proto must be frozen`);\\n  const {\\n    [PASS_STYLE]: { value: passStyleValue },\\n    toString: { value: toStringValue },\\n    /* @ts-ignore https://github.com/microsoft/TypeScript/issues/1863*/\\n    [Symbol.toStringTag]: { value: toStringTagValue },\\n    ...rest } =\\n  getOwnPropertyDescriptors(val);\\n  assert.assert(\\n  ownKeys(rest).length === 0,\\n  assert.details`Unexpect properties on Remotable Proto ${ownKeys(rest)}`);\\n\\n  assert.assert(\\n  passStyleValue === REMOTE_STYLE,\\n  assert.details`Expected ${assert.quote(REMOTE_STYLE)}, not ${assert.quote(passStyleValue)}`);\\n\\n  assert.assert.typeof(toStringValue, 'function', assert.details`toString must be a function`);\\n  assert.assert.typeof(toStringTagValue, 'string', assert.details`@@toStringTag must be a string`);};\\n\\n\\n/**\\n * Ensure that val could become a legitimate remotable.  This is used\\n * internally both in the construction of a new remotable and\\n * mustPassByRemote.\\n *\\n * @param {*} val The remotable candidate to check\\n */\\nfunction assertCanBeRemotable(val) {\\n  /* throws exception if cannot*/\\n  assert.assert.typeof(val, 'object', assert.details`cannot serialize non-objects like ${val}`);\\n  assert.assert(!Array.isArray(val), assert.details`Arrays cannot be pass-by-remote`);\\n  assert.assert(val !== null, assert.details`null cannot be pass-by-remote`);\\n\\n  const descs = getOwnPropertyDescriptors(val);\\n  const keys = ownKeys(descs); /* enumerable-and-not, string-or-Symbol*/\\n  keys.forEach(key => {\\n    assert.assert(\\n    /* Typecast needed due to https://github.com/microsoft/TypeScript/issues/1863*/\\n    !('get' in descs[/** @type {string} */key]),\\n    assert.details`cannot serialize objects with getters like ${assert.quote(String(key))} in ${val}`);\\n\\n    assert.assert.typeof(\\n    /* @ts-ignore https://github.com/microsoft/TypeScript/issues/1863*/\\n    val[key],\\n    'function',\\n    assert.details`cannot serialize objects with non-methods like ${assert.quote(\\n    String(key))\\n    } in ${val}`);\\n\\n    assert.assert(\\n    key !== PASS_STYLE,\\n    assert.details`A pass-by-remote cannot shadow ${assert.quote(PASS_STYLE)}`);});}\\n\\n\\n\\n\\n/**\\n * @param {Remotable} val\\n */\\nfunction assertRemotable(val) {\\n  assert.assert(isFrozen(val), assert.details`cannot serialize non-frozen objects like ${val}`);\\n\\n  assertCanBeRemotable(val);\\n\\n  const p = getPrototypeOf(val);\\n  if (p !== null && p !== objectPrototype) {\\n    assertRemotableProto(p);}}\\n\\n\\n\\n/**\\n * This is the equality comparison used by JavaScript's Map and Set\\n * abstractions, where NaN is the same as NaN and -0 is the same as\\n * 0. Marshal serializes -0 as zero, so the semantics of our distributed\\n * object system does not distinguish 0 from -0.\\n *\\n * `sameValueZero` is the EcmaScript spec name for this equality comparison,\\n * but TODO we need a better name for the API.\\n *\\n * @param {any} x\\n * @param {any} y\\n * @returns {boolean}\\n */\\nfunction sameValueZero(x, y) {\\n  return x === y || is(x, y);}\\n\\n\\n/**\\n * objects can only be passed in one of two/three forms:\\n * 1: pass-by-remote: all properties (own and inherited) are methods,\\n *    the object itself is of type object, not function\\n * 2: pass-by-copy: all string-named own properties are data, not methods\\n *    the object must inherit from objectPrototype or null\\n * 3: the empty object is pass-by-remote, for identity comparison\\n *\\n * all objects must be frozen\\n *\\n * anything else will throw an error if you try to serialize it\\n * with these restrictions, our remote call/copy protocols expose all useful\\n * behavior of these objects: pass-by-remote objects have no other data (so\\n * there's nothing else to copy), and pass-by-copy objects have no other\\n * behavior (so there's nothing else to invoke)\\n *\\n * How would val be passed?  For primitive values, the answer is\\n *   * 'null' for null\\n *   * throwing an error for a symbol, whether registered or not.\\n *   * that value's typeof string for all other primitive values\\n * For frozen objects, the possible answers\\n *   * 'copyRecord' for non-empty records with only data properties\\n *   * 'copyArray' for arrays with only data properties\\n *   * 'copyError' for instances of Error with only data properties\\n *   * REMOTE_STYLE for non-array objects with only method properties\\n *   * 'promise' for genuine promises only\\n *   * throwing an error on anything else, including thenables.\\n * We export passStyleOf so other algorithms can use this module's\\n * classification.\\n *\\n * @param {Passable} val\\n * @returns {PassStyle}\\n */\\nfunction passStyleOf(val) {\\n  const typestr = typeof val;\\n  switch (typestr) {\\n    case 'object':{\\n        if (getInterfaceOf(val)) {\\n          return REMOTE_STYLE;}\\n\\n        if (val === null) {\\n          return 'null';}\\n\\n        assert.assert(\\n        isFrozen(val),\\n        assert.details`Cannot pass non-frozen objects like ${val}. Use harden()`);\\n\\n        if (promiseKit.isPromise(val)) {\\n          return 'promise';}\\n\\n        assert.assert(\\n        typeof val.then !== 'function',\\n        assert.details`Cannot pass non-promise thenables`);\\n\\n        if (isPassByCopyError(val)) {\\n          return 'copyError';}\\n\\n        if (isPassByCopyArray(val)) {\\n          return 'copyArray';}\\n\\n        if (isPassByCopyRecord(val)) {\\n          return 'copyRecord';}\\n\\n        assertRemotable(val);\\n        /* console.log(`--- @@marshal: pass-by-ref object without Far/Remotable`);*/\\n        /* assert.fail(X`pass-by-ref object without Far/Remotable`);*/\\n        return REMOTE_STYLE;}\\n\\n    case 'function':{\\n        assert.assert.fail(assert.details`Bare functions like ${val} are disabled for now`);}\\n\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case 'symbol':{\\n        return typestr;}\\n\\n    default:{\\n        assert.assert.fail(assert.details`Unrecognized typeof ${assert.quote(typestr)}`, TypeError);}}}\\n\\n\\n\\n\\n/**\\n * Special property name that indicates an encoding that needs special\\n * decoding.\\n */\\nconst QCLASS = '@qclass';\\n\\n\\n/**\\n * @template Slot\\n * @type {ConvertValToSlot<Slot>}\\n */\\nconst defaultValToSlotFn = x => x;\\n/**\\n * @template Slot\\n * @type {ConvertSlotToVal<Slot>}\\n */\\nconst defaultSlotToValFn = (x, _) => x;\\n\\n/**\\n * @template Slot\\n * @type {MakeMarshal<Slot>}\\n */\\nfunction makeMarshal(\\nconvertValToSlot = defaultValToSlotFn,\\nconvertSlotToVal = defaultSlotToValFn,\\n{\\n  marshalName = 'anon-marshal',\\n  errorTagging = 'on',\\n  /* We prefer that the caller instead log to somewhere hidden*/\\n  /* to be revealed when correlating with the received error.*/\\n  marshalSaveError = (err) =>\\n  console.log('Temporary logging of sent error', err) } =\\n{})\\n{\\n  assert.assert.typeof(marshalName, 'string');\\n  assert.assert(\\n  errorTagging === 'on' || errorTagging === 'off',\\n  assert.details`The errorTagging option can only be \\\"on\\\" or \\\"off\\\" ${errorTagging}`);\\n\\n  /* Ascending numbers identifying the sending of errors relative to this*/\\n  /* marshal instance.*/\\n  let errorCount = 0;\\n  const nextErrorId = () => {\\n    errorCount += 1;\\n    return `error:${marshalName}#${errorCount}`;};\\n\\n\\n  /**\\n   * @template Slot\\n   * @param {Passable} val\\n   * @param {Slot[]} slots\\n   * @param {WeakMap<Passable,number>} slotMap\\n   * @param {InterfaceSpec=} iface\\n   * @returns {Encoding}\\n   */\\n  function serializeSlot(val, slots, slotMap, iface = undefined) {\\n    let slotIndex;\\n    if (slotMap.has(val)) {\\n      slotIndex = slotMap.get(val);\\n      assert.assert.typeof(slotIndex, 'number');} else\\n    {\\n      const slot = convertValToSlot(val);\\n\\n      slotIndex = slots.length;\\n      slots.push(slot);\\n      slotMap.set(val, slotIndex);}\\n\\n\\n    /* if (iface === undefined && passStyleOf(val) === REMOTE_STYLE) {\\n     // iface = `Alleged: remotable at slot ${slotIndex}`;\\n     if (\\n     getPrototypeOf(val) === objectPrototype &&\\n     ownKeys(val).length === 0\\n     ) {\\n     // For now, skip the diagnostic if we have a pure empty object\\n     } else {\\n     try {\\n     assert.fail(X`Serialize ${val} generates needs iface`);\\n     } catch (err) {\\n     console.info(err);\\n     }\\n     }\\n     }\\n     */\\n\\n\\n    if (iface === undefined) {\\n      return harden({\\n        [QCLASS]: 'slot',\\n        index: slotIndex });}\\n\\n\\n    return harden({\\n      [QCLASS]: 'slot',\\n      iface,\\n      index: slotIndex });}\\n\\n\\n\\n  /**\\n   * @template Slot\\n   * @type {Serialize<Slot>}\\n   */\\n  const serialize = root => {\\n    const slots = [];\\n    /* maps val (promise or remotable) to index of slots[]*/\\n    const slotMap = new Map();\\n    const ibidTable = ibidTables.makeReplacerIbidTable();\\n\\n    /**\\n     * Must encode `val` into plain JSON data *canonically*, such that\\n     * `sameStructure(v1, v2)` implies\\n     * `JSON.stringify(encode(v1)) === JSON.stringify(encode(v2))`\\n     * For each record, we only accept sortable property names\\n     * (no anonymous symbols). On the encoded form the sort\\n     * order of these names must be the same as their enumeration\\n     * order, so a `JSON.stringify` of the encoded form agrees with\\n     * a canonical-json stringify of the encoded form.\\n     *\\n     * @param {Passable} val\\n     * @returns {Encoding}\\n     */\\n    const encode = val => {\\n      /* First we handle all primitives. Some can be represented directly as*/\\n      /* JSON, and some must be encoded as [QCLASS] composites.*/\\n      const passStyle = passStyleOf(val);\\n      switch (passStyle) {\\n        case 'null':{\\n            return null;}\\n\\n        case 'undefined':{\\n            return harden({ [QCLASS]: 'undefined' });}\\n\\n        case 'string':\\n        case 'boolean':{\\n            return val;}\\n\\n        case 'number':{\\n            if (Number.isNaN(val)) {\\n              return harden({ [QCLASS]: 'NaN' });}\\n\\n            if (is(val, -0)) {\\n              return 0;}\\n\\n            if (val === Infinity) {\\n              return harden({ [QCLASS]: 'Infinity' });}\\n\\n            if (val === -Infinity) {\\n              return harden({ [QCLASS]: '-Infinity' });}\\n\\n            return val;}\\n\\n        case 'bigint':{\\n            return harden({\\n              [QCLASS]: 'bigint',\\n              digits: String(val) });}\\n\\n\\n        case 'symbol':{\\n            switch (val) {\\n              case Symbol.asyncIterator:{\\n                  return harden({\\n                    [QCLASS]: '@@asyncIterator' });}\\n\\n\\n              default:{\\n                  assert.assert.fail(assert.details`Unsupported symbol ${assert.quote(String(val))}`);}}}\\n\\n\\n\\n        default:{\\n            /* if we've seen this object before, serialize a backref*/\\n            if (ibidTable.has(val)) {\\n              /* Backreference to prior occurrence*/\\n              const index = ibidTable.get(val);\\n              assert.assert.typeof(index, 'number');\\n              return harden({\\n                [QCLASS]: 'ibid',\\n                index });}\\n\\n\\n            ibidTable.add(val);\\n\\n            switch (passStyle) {\\n              case 'copyRecord':{\\n                  if (QCLASS in val) {\\n                    /* Hilbert hotel*/\\n                    const { [QCLASS]: qclassValue, ...rest } = val;\\n                    if (ownKeys(rest).length === 0) {\\n                      return harden({\\n                        [QCLASS]: 'hilbert',\\n                        original: encode(qclassValue) });} else\\n\\n                    {\\n                      return harden({\\n                        [QCLASS]: 'hilbert',\\n                        original: encode(qclassValue),\\n                        /* This means the rest will get an ibid entry even*/\\n                        /* though it is not any of the original objects.*/\\n                        rest: encode(harden(rest)) });}}\\n\\n\\n\\n                  /* Currently copyRecord allows only string keys so this will*/\\n                  /* work. If we allow sortable symbol keys, this will need to*/\\n                  /* become more interesting.*/\\n                  const names = ownKeys(val).sort();\\n                  return fromEntries(names.map(name => [name, encode(val[name])]));}\\n\\n              case 'copyArray':{\\n                  return val.map(encode);}\\n\\n              case 'copyError':{\\n                  /* We deliberately do not share the stack, but it would*/\\n                  /* be useful to log the stack locally so someone who has*/\\n                  /* privileged access to the throwing Vat can correlate*/\\n                  /* the problem with the remote Vat that gets this*/\\n                  /* summary. If we do that, we could allocate some random*/\\n                  /* identifier and include it in the message, to help*/\\n                  /* with the correlation.*/\\n\\n                  if (errorTagging === 'on') {\\n                    const errorId = nextErrorId();\\n                    assert.assert.note(val, assert.details`Sent as ${errorId}`);\\n                    marshalSaveError(val);\\n                    return harden({\\n                      [QCLASS]: 'error',\\n                      errorId,\\n                      message: `${val.message}`,\\n                      name: `${val.name}` });} else\\n\\n                  {\\n                    return harden({\\n                      [QCLASS]: 'error',\\n                      message: `${val.message}`,\\n                      name: `${val.name}` });}}\\n\\n\\n\\n              case REMOTE_STYLE:{\\n                  const iface = getInterfaceOf(val);\\n                  /* console.log(`serializeSlot: ${val}`);*/\\n                  return serializeSlot(val, slots, slotMap, iface);}\\n\\n              case 'promise':{\\n                  /* console.log(`serializeSlot: ${val}`);*/\\n                  return serializeSlot(val, slots, slotMap);}\\n\\n              default:{\\n                  assert.assert.fail(assert.details`unrecognized passStyle ${assert.quote(passStyle)}`, TypeError);}}}}};\\n\\n\\n\\n\\n\\n\\n    const encoded = encode(root);\\n\\n    return harden({\\n      body: JSON.stringify(encoded),\\n      slots });};\\n\\n\\n\\n  function makeFullRevive(slots, cyclePolicy) {\\n    /* ibid table is shared across recursive calls to fullRevive.*/\\n    const ibidTable = ibidTables.makeReviverIbidTable(cyclePolicy);\\n\\n    /**\\n     * We stay close to the algorithm at\\n     * https://tc39.github.io/ecma262/#sec-json.parse , where\\n     * fullRevive(harden(JSON.parse(str))) is like JSON.parse(str, revive))\\n     * for a similar reviver. But with the following differences:\\n     *\\n     * Rather than pass a reviver to JSON.parse, we first call a plain\\n     * (one argument) JSON.parse to get rawTree, and then post-process\\n     * the rawTree with fullRevive. The kind of revive function\\n     * handled by JSON.parse only does one step in post-order, with\\n     * JSON.parse doing the recursion. By contrast, fullParse does its\\n     * own recursion, enabling it to interpret ibids in the same\\n     * pre-order in which the replacer visited them, and enabling it\\n     * to break cycles.\\n     *\\n     * In order to break cycles, the potentially cyclic objects are\\n     * not frozen during the recursion. Rather, the whole graph is\\n     * hardened before being returned. Error objects are not\\n     * potentially recursive, and so may be harmlessly hardened when\\n     * they are produced.\\n     *\\n     * fullRevive can produce properties whose value is undefined,\\n     * which a JSON.parse on a reviver cannot do. If a reviver returns\\n     * undefined to JSON.parse, JSON.parse will delete the property\\n     * instead.\\n     *\\n     * fullRevive creates and returns a new graph, rather than\\n     * modifying the original tree in place.\\n     *\\n     * fullRevive may rely on rawTree being the result of a plain call\\n     * to JSON.parse. However, it *cannot* rely on it having been\\n     * produced by JSON.stringify on the replacer above, i.e., it\\n     * cannot rely on it being a valid marshalled\\n     * representation. Rather, fullRevive must validate that.\\n     *\\n     * @param {Encoding} rawTree must be hardened\\n     */\\n    function fullRevive(rawTree) {\\n      if (Object(rawTree) !== rawTree) {\\n        /* primitives pass through*/\\n        return rawTree;}\\n\\n      /* Assertions of the above to narrow the type.*/\\n      assert.assert.typeof(rawTree, 'object');\\n      assert.assert(rawTree !== null);\\n      if (QCLASS in rawTree) {\\n        const qclass = rawTree[QCLASS];\\n        assert.assert.typeof(\\n        qclass,\\n        'string',\\n        assert.details`invalid qclass typeof ${assert.quote(typeof qclass)}`);\\n\\n        assert.assert(!Array.isArray(rawTree));\\n        /* Switching on `encoded[QCLASS]` (or anything less direct, like*/\\n        /* `qclass`) does not discriminate rawTree in typescript@4.2.3 and*/\\n        /* earlier.*/\\n        switch (rawTree['@qclass']) {\\n          /* Encoding of primitives not handled by JSON*/\\n          case 'undefined':{\\n              return undefined;}\\n\\n          case 'NaN':{\\n              return NaN;}\\n\\n          case 'Infinity':{\\n              return Infinity;}\\n\\n          case '-Infinity':{\\n              return -Infinity;}\\n\\n          case 'bigint':{\\n              const { digits } = rawTree;\\n              assert.assert.typeof(\\n              digits,\\n              'string',\\n              assert.details`invalid digits typeof ${assert.quote(typeof digits)}`);\\n\\n              return BigInt(digits);}\\n\\n          case '@@asyncIterator':{\\n              return Symbol.asyncIterator;}\\n\\n\\n          case 'ibid':{\\n              const { index } = rawTree;\\n              return ibidTable.get(index);}\\n\\n\\n          case 'error':{\\n              const { name, message, errorId } = rawTree;\\n              assert.assert.typeof(\\n              name,\\n              'string',\\n              assert.details`invalid error name typeof ${assert.quote(typeof name)}`);\\n\\n              assert.assert.typeof(\\n              message,\\n              'string',\\n              assert.details`invalid error message typeof ${assert.quote(typeof message)}`);\\n\\n              const EC = getErrorConstructor(`${name}`) || Error;\\n              const error = harden(new EC(`${message}`));\\n              ibidTable.register(error);\\n              if (typeof errorId === 'string') {\\n                /* errorId is a late addition so be tolerant of its absence.*/\\n                assert.assert.note(error, assert.details`Received as ${errorId}`);}\\n\\n              return error;}\\n\\n\\n          case 'slot':{\\n              const { index, iface } = rawTree;\\n              const slot = slots[Number(nat_esm.Nat(index))];\\n              return ibidTable.register(convertSlotToVal(slot, iface));}\\n\\n\\n          case 'hilbert':{\\n              const { original, rest } = rawTree;\\n              assert.assert(\\n              'original' in rawTree,\\n              assert.details`Invalid Hilbert Hotel encoding ${rawTree}`);\\n\\n              const result = ibidTable.start({});\\n              result[QCLASS] = fullRevive(original);\\n              if ('rest' in rawTree) {\\n                assert.assert(\\n                rest !== undefined,\\n                assert.details`Rest encoding must not be undefined`);\\n\\n                const restObj = fullRevive(rest);\\n                /* TODO really should assert that `passStyleOf(rest)` is*/\\n                /* `'copyRecord'` but we'd have to harden it and it is too*/\\n                /* early to do that.*/\\n                assert.assert(\\n                !(QCLASS in restObj),\\n                assert.details`Rest must not contain its own definition of ${assert.quote(QCLASS)}`);\\n\\n                defineProperties(result, getOwnPropertyDescriptors(restObj));}\\n\\n              return ibidTable.finish(result);}\\n\\n\\n          default:{\\n              assert.assert.fail(assert.details`unrecognized ${assert.quote(QCLASS)} ${assert.quote(qclass)}`, TypeError);}}} else\\n\\n\\n      if (Array.isArray(rawTree)) {\\n        const { length } = rawTree;\\n        const result = ibidTable.start([]);\\n        for (let i = 0; i < length; i += 1) {\\n          result[i] = fullRevive(rawTree[i]);}\\n\\n        return ibidTable.finish(result);} else\\n      {\\n        const result = ibidTable.start({});\\n        for (const name of ownKeys(rawTree)) {\\n          assert.assert.typeof(\\n          name,\\n          'string',\\n          assert.details`Property ${name} of ${rawTree} must be a string`);\\n\\n          result[name] = fullRevive(rawTree[name]);}\\n\\n        return ibidTable.finish(result);}}\\n\\n\\n    return fullRevive;}\\n\\n\\n  /**\\n   * @template Slot\\n   * @type {Unserialize<Slot>}\\n   */\\n  function unserialize(data, cyclePolicy = 'forbidCycles') {\\n    assert.assert.typeof(\\n    data.body,\\n    'string',\\n    assert.details`unserialize() given non-capdata (.body is ${data.body}, not string)`);\\n\\n    assert.assert(\\n    Array.isArray(data.slots),\\n    assert.details`unserialize() given non-capdata (.slots are not Array)`);\\n\\n    const rawTree = harden(JSON.parse(data.body));\\n    const fullRevive = makeFullRevive(data.slots, cyclePolicy);\\n    return harden(fullRevive(rawTree));}\\n\\n\\n  return harden({\\n    serialize,\\n    unserialize });}\\n\\n\\n\\n/**\\n * Create and register a Remotable.  After this, getInterfaceOf(remotable)\\n * returns iface.\\n *\\n * // https://github.com/Agoric/agoric-sdk/issues/804\\n *\\n * @param {InterfaceSpec} [iface='Remotable'] The interface specification for\\n * the remotable. For now, a string iface must be \\\"Remotable\\\" or begin with\\n * \\\"Alleged: \\\", to serve as the alleged name. More general ifaces are not yet\\n * implemented. This is temporary. We include the\\n * \\\"Alleged\\\" as a reminder that we do not yet have SwingSet or Comms Vat\\n * support for ensuring this is according to the vat hosting the object.\\n * Currently, Alice can tell Bob about Carol, where VatA (on Alice's behalf)\\n * misrepresents Carol's `iface`. VatB and therefore Bob will then see\\n * Carol's `iface` as misrepresented by VatA.\\n * @param {undefined} [props=undefined] Currently may only be undefined.\\n * That plan is that own-properties are copied to the remotable\\n * @param {object} [remotable={}] The object used as the remotable\\n * @returns {object} remotable, modified for debuggability\\n */\\nconst Remotable = (iface = 'Remotable', props = undefined, remotable = {}) => {\\n  /* TODO unimplemented*/\\n  assert.assert.typeof(\\n  iface,\\n  'string',\\n  assert.details`Interface ${iface} must be a string; unimplemented`);\\n\\n  /* TODO unimplemented*/\\n  assert.assert(\\n  iface === 'Remotable' || iface.startsWith('Alleged: '),\\n  assert.details`For now, iface ${assert.quote(\\n  iface)\\n  } must be \\\"Remotable\\\" or begin with \\\"Alleged: \\\"; unimplemented`);\\n\\n  iface = pureCopy(harden(iface));\\n  /* TODO: When iface is richer than just string, we need to get the allegedName*/\\n  /* in a different way.*/\\n  const allegedName = iface;\\n  assert.assert(props === undefined, assert.details`Remotable props not yet implemented ${props}`);\\n\\n  /* Fail fast: check that the unmodified object is able to become a Remotable.*/\\n  assertCanBeRemotable(remotable);\\n\\n  /* Ensure that the remotable isn't already marked.*/\\n  assert.assert(\\n  !(PASS_STYLE in remotable),\\n  assert.details`Remotable ${remotable} is already marked as a ${assert.quote(\\n  remotable[PASS_STYLE])\\n  }`);\\n\\n  /* Ensure that the remotable isn't already frozen.*/\\n  assert.assert(!isFrozen(remotable), assert.details`Remotable ${remotable} is already frozen`);\\n  const remotableProto = makeRemotableProto(\\n  getPrototypeOf(remotable),\\n  allegedName);\\n\\n\\n  /* Take a static copy of the enumerable own properties as data properties.*/\\n  /* const propDescs = getOwnPropertyDescriptors({ ...props });*/\\n  const mutateHardenAndCheck = target => {\\n    /* defineProperties(target, propDescs);*/\\n    setPrototypeOf(target, remotableProto);\\n    harden(target);\\n    assertCanBeRemotable(target);};\\n\\n\\n  /* Fail fast: check a fresh remotable to see if our rules fit.*/\\n  mutateHardenAndCheck({});\\n\\n  /* Actually finish the new remotable.*/\\n  mutateHardenAndCheck(remotable);\\n\\n  /* COMMITTED!*/\\n  /* We're committed, so keep the interface for future reference.*/\\n  assert.assert(iface !== undefined); /* To make TypeScript happy*/\\n  return remotable;};\\n\\n\\nharden(Remotable);\\n\\n\\n/**\\n * A concise convenience for the most common `Remotable` use.\\n *\\n * @param {string} farName This name will be prepended with `Alleged: `\\n * for now to form the `Remotable` `iface` argument.\\n * @param {object} [remotable={}] The object used as the remotable\\n * @returns {object} remotable, modified for debuggability\\n */\\nconst Far = (farName, remotable = {}) =>\\nRemotable(`Alleged: ${farName}`, undefined, remotable);\\n\\nharden(Far);exports.Far = Far;exports.QCLASS = QCLASS;exports.REMOTE_STYLE = REMOTE_STYLE;exports.Remotable = Remotable;exports.getErrorConstructor = getErrorConstructor;exports.getInterfaceOf = getInterfaceOf;exports.makeMarshal = makeMarshal;exports.passStyleOf = passStyleOf;exports.pureCopy = pureCopy;exports.sameValueZero = sameValueZero;\",\n  \"marshal/src/marshal-stringify.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');require('./types.js');var\\n\\n\\n\\n\\n\\n\\nmarshal = require('./marshal.js'); /* @ts-check*/ /** @type {ConvertValToSlot<any>} */\\nconst doNotConvertValToSlot = (val) =>\\nassert.assert.fail(assert.details`Marshal's stringify rejects presences and promises ${val}`);\\n\\n/** @type {ConvertSlotToVal<any>} */\\nconst doNotConvertSlotToVal = (slot, _iface) =>\\nassert.assert.fail(assert.details`Marshal's parse must not encode any slots ${slot}`);\\n\\nconst badArrayHandler = harden({\\n  get: (_target, name, _receiver) => {\\n    if (name === 'length') {\\n      return 0;}\\n\\n    assert.assert.fail(assert.details`Marshal's parse must not encode any slot positions ${name}`);} });\\n\\n\\n\\nconst badArray = harden(new Proxy(harden([]), badArrayHandler));\\n\\nconst { serialize, unserialize } = marshal.makeMarshal(\\ndoNotConvertValToSlot,\\ndoNotConvertSlotToVal,\\n{ errorTagging: 'off' });\\n\\n\\n/**\\n * @param {OnlyData} val\\n * @returns {string}\\n */\\nconst stringify = val => serialize(val).body;\\nharden(stringify);\\n\\n/**\\n * @param {string} str\\n * @returns {OnlyData}\\n */\\nconst parse = (str) =>\\nunserialize(\\nharden({\\n  body: str,\\n  slots: badArray }));\\n\\n\\nharden(parse);exports.parse = parse;exports.stringify = stringify;\",\n  \"marshal/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var marshal = require('./src/marshal.js');var marshalStringify = require('./src/marshal-stringify.js');exports.Far = marshal.Far;exports.QCLASS = marshal.QCLASS;exports.REMOTE_STYLE = marshal.REMOTE_STYLE;exports.Remotable = marshal.Remotable;exports.getErrorConstructor = marshal.getErrorConstructor;exports.getInterfaceOf = marshal.getInterfaceOf;exports.makeMarshal = marshal.makeMarshal;exports.passStyleOf = marshal.passStyleOf;exports.pureCopy = marshal.pureCopy;exports.sameValueZero = marshal.sameValueZero;exports.parse = marshalStringify.parse;exports.stringify = marshalStringify.stringify;\",\n  \"same-structure/src/sameStructure.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var marshal = require('../../marshal/src/marshal.js');\\n\\n\\n\\n\\n\\n\\n\\nrequire('../../marshal/index.js'); /* @ts-check*/ /* Shim of Object.fromEntries from*/ /* https://github.com/tc39/proposal-object-from-entries/blob/master/polyfill.js*/ /* TODO reconcile and dedup with the Object.fromEntries ponyfill in*/ /* SES-shim/packages/ses/src/commons.js*/\\nfunction objectFromEntries(iter) {\\n  const obj = {};\\n\\n  for (const pair of iter) {\\n    if (Object(pair) !== pair) {\\n      throw new TypeError('iterable for fromEntries should yield objects');}\\n\\n\\n    /* Consistency with Map: contract is that entry has \\\"0\\\" and \\\"1\\\" keys, not*/\\n    /* that it is an array or iterable.*/\\n\\n    const { '0': key, '1': val } = pair;\\n\\n    Object.defineProperty(obj, key, {\\n      configurable: true,\\n      enumerable: true,\\n      writable: true,\\n      value: val });}\\n\\n\\n\\n  return obj;}\\n\\n\\n/**\\n * A *passable* is something that may be marshalled. It consists of a\\n * graph of pass-by-copy data terminating in leaves of passable\\n * non-pass-by-copy data. These leaves may be promises, or\\n * pass-by-presence objects. A *comparable* is a passable whose leaves\\n * contain no promises. Two comparables can be synchronously compared\\n * for structural equivalence.\\n *\\n * TODO: Currently, all algorithms here treat the pass-by-copy\\n * superstructure as a tree. This means that dags are unwound at\\n * potentially exponential cost, and cycles cause failure to\\n * terminate. We must fix both problems, making all these algorithms\\n * graph-aware.\\n *\\n * We say that a function *reveals* an X when it returns either an X\\n * or a promise for an X.\\n *\\n * Given a passable, reveal a corresponding comparable, where each\\n * leaf promise of the passable has been replaced with its\\n * corresponding comparable.\\n *\\n * @param {Passable} passable\\n * @returns {Promise<Comparable>}\\n */\\nfunction allComparable(passable) {\\n  const passStyle = marshal.passStyleOf(passable);\\n  switch (passStyle) {\\n    case 'null':\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case marshal.REMOTE_STYLE:\\n    case 'copyError':{\\n        return passable;}\\n\\n    case 'promise':{\\n        return passable.then(nonp => allComparable(nonp));}\\n\\n    case 'copyArray':{\\n        const valPs = passable.map(p => allComparable(p));\\n        return Promise.all(valPs).then(vals => harden(vals));}\\n\\n    case 'copyRecord':{\\n        const names = Object.getOwnPropertyNames(passable);\\n        const valPs = names.map(name => allComparable(passable[name]));\\n        return Promise.all(valPs).then((vals) =>\\n        harden(objectFromEntries(vals.map((val, i) => [names[i], val]))));}\\n\\n\\n    default:{\\n        assert.assert.fail(assert.details`unrecognized passStyle ${passStyle}`, TypeError);}}}\\n\\n\\n\\nharden(allComparable);\\n\\n/**\\n * Are left and right structurally equivalent comparables? This\\n * compares pass-by-copy data deeply until non-pass-by-copy values are\\n * reached. The non-pass-by-copy values at the leaves of the\\n * comparison may only be pass-by-presence objects. If they are\\n * anything else, including promises, throw an error.\\n *\\n * Pass-by-presence objects compare identities.\\n *\\n * @param {Comparable} left\\n * @param {Comparable} right\\n * @returns {boolean}\\n */\\nfunction sameStructure(left, right) {\\n  const leftStyle = marshal.passStyleOf(left);\\n  const rightStyle = marshal.passStyleOf(right);\\n  assert.assert(\\n  leftStyle !== 'promise',\\n  assert.details`Cannot structurally compare promises: ${left}`);\\n\\n  assert.assert(\\n  rightStyle !== 'promise',\\n  assert.details`Cannot structurally compare promises: ${right}`);\\n\\n\\n  if (leftStyle !== rightStyle) {\\n    return false;}\\n\\n  switch (leftStyle) {\\n    case 'null':\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case marshal.REMOTE_STYLE:{\\n        return marshal.sameValueZero(left, right);}\\n\\n    case 'copyRecord':\\n    case 'copyArray':{\\n        const leftNames = Object.getOwnPropertyNames(left);\\n        const rightNames = Object.getOwnPropertyNames(right);\\n        if (leftNames.length !== rightNames.length) {\\n          return false;}\\n\\n        for (const name of leftNames) {\\n          /* TODO: Better hasOwnProperty check*/\\n          if (!Object.getOwnPropertyDescriptor(right, name)) {\\n            return false;}\\n\\n          /* TODO: Make cycle tolerant*/\\n          if (!sameStructure(left[name], right[name])) {\\n            return false;}}\\n\\n\\n        return true;}\\n\\n    case 'copyError':{\\n        return left.name === right.name && left.message === right.message;}\\n\\n    default:{\\n        assert.assert.fail(assert.details`unrecognized passStyle ${leftStyle}`, TypeError);}}}\\n\\n\\n\\nharden(sameStructure);\\n\\nfunction pathStr(path) {\\n  if (path === null) {\\n    return 'top';}\\n\\n  const [base, index] = path;\\n  let i = index;\\n  const baseStr = pathStr(base);\\n  if (typeof i === 'string' && /^[a-zA-Z]\\\\w*$/.test(i)) {\\n    return `${baseStr}.${i}`;}\\n\\n  if (typeof i === 'string' && `${+i}` === i) {\\n    i = +i;}\\n\\n  return `${baseStr}[${JSON.stringify(i)}]`;}\\n\\n\\n/* TODO: Reduce redundancy between sameStructure and*/\\n/* mustBeSameStructureInternal*/\\nfunction mustBeSameStructureInternal(left, right, message, path) {\\n  function complain(problem) {\\n    assert.assert.fail(\\n    assert.details`${assert.quote(message)}: ${assert.quote(problem)} at ${assert.quote(\\n    pathStr(path))\\n    }: (${left}) vs (${right})`);}\\n\\n\\n\\n  const leftStyle = marshal.passStyleOf(left);\\n  const rightStyle = marshal.passStyleOf(right);\\n  if (leftStyle === 'promise') {\\n    complain('Promise on left');}\\n\\n  if (rightStyle === 'promise') {\\n    complain('Promise on right');}\\n\\n\\n  if (leftStyle !== rightStyle) {\\n    complain('different passing style');}\\n\\n  switch (leftStyle) {\\n    case 'null':\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case marshal.REMOTE_STYLE:{\\n        if (!marshal.sameValueZero(left, right)) {\\n          complain('different');}\\n\\n        break;}\\n\\n    case 'copyRecord':\\n    case 'copyArray':{\\n        const leftNames = Object.getOwnPropertyNames(left);\\n        const rightNames = Object.getOwnPropertyNames(right);\\n        if (leftNames.length !== rightNames.length) {\\n          complain(`${leftNames.length} vs ${rightNames.length} own properties`);}\\n\\n        for (const name of leftNames) {\\n          /* TODO: Better hasOwnProperty check*/\\n          if (!Object.getOwnPropertyDescriptor(right, name)) {\\n            complain(`${name} not found on right`);}\\n\\n          /* TODO: Make cycle tolerant*/\\n          mustBeSameStructureInternal(left[name], right[name], message, [\\n          path,\\n          name]);}\\n\\n\\n        break;}\\n\\n    case 'copyError':{\\n        if (left.name !== right.name) {\\n          complain(`different error name: ${left.name} vs ${right.name}`);}\\n\\n        if (left.message !== right.message) {\\n          complain(\\n          `different error message: ${left.message} vs ${right.message}`);}\\n\\n\\n        break;}\\n\\n    default:{\\n        complain(`unrecognized passStyle ${leftStyle}`);\\n        break;}}}\\n\\n\\n\\n\\n/**\\n * @param {Comparable} left\\n * @param {Comparable} right\\n * @param {string} message\\n */\\nfunction mustBeSameStructure(left, right, message) {\\n  mustBeSameStructureInternal(left, right, `${message}`, null);}\\n\\nharden(mustBeSameStructure);\\n\\n/**\\n * If `val` would be a valid input to `sameStructure`, return\\n * normally. Otherwise error.\\n *\\n * @param {Comparable} val\\n */\\nfunction mustBeComparable(val) {\\n  mustBeSameStructure(val, val, 'not comparable');}exports.allComparable = allComparable;exports.mustBeComparable = mustBeComparable;exports.mustBeSameStructure = mustBeSameStructure;exports.sameStructure = sameStructure;\",\n  \"same-structure/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var sameStructure = require('./src/sameStructure.js');exports.allComparable = sameStructure.allComparable;exports.mustBeComparable = sameStructure.mustBeComparable;exports.mustBeSameStructure = sameStructure.mustBeSameStructure;exports.sameStructure = sameStructure.sameStructure;\",\n  \"ertp/src/mathHelpers/natMathHelpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../types.js');var nat_esm = require('../../../nat/dist/nat.esm.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\nconst identity = 0n;\\n\\n/**\\n * Fungible digital assets use the natMathHelpers to manage balances -\\n * the operations are merely arithmetic on natural, non-negative\\n * numbers.\\n *\\n * Natural numbers are used for fungible erights such as money because\\n * rounding issues make floats problematic. All operations should be\\n * done with the smallest whole unit such that the NatMathHelpers never\\n * deals with fractional parts.\\n *\\n * @type {NatMathHelpers}\\n */\\nconst natMathHelpers = harden({\\n  doCoerce: nat_esm.Nat,\\n  doMakeEmpty: _ => identity,\\n  doIsEmpty: nat => nat === identity,\\n  doIsGTE: (left, right) => left >= right,\\n  doIsEqual: (left, right) => left === right,\\n  /* BigInts don't observably overflow*/\\n  doAdd: (left, right) => left + right,\\n  doSubtract: (left, right) => nat_esm.Nat(left - right) });\\n\\n\\nharden(natMathHelpers);exports.default = natMathHelpers;\",\n  \"ertp/src/mathHelpers/setMathHelpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../types.js');var assert = require('../../../assert/src/assert.js');var marshal = require('../../../marshal/src/marshal.js');require('../../../marshal/index.js');var sameStructure = require('../../../same-structure/src/sameStructure.js');\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('../../../same-structure/index.js'); /* @ts-check*/ /* Operations for arrays with unique objects identifying and providing*/ /* information about digital assets. Used for Zoe invites.*/\\nconst identity = harden([]);\\n\\nconst getKeyForRecord = record => {\\n  const keys = Object.getOwnPropertyNames(record);\\n  keys.sort();\\n  const values = Object.values(record).filter(\\n  value => typeof value === 'string');\\n\\n  values.sort();\\n  return [...keys, ...values].join();};\\n\\n\\n/* Cut down the number of sameStructure comparisons to only the ones*/\\n/* that don't fail basic equality tests*/\\n/* TODO: better name?*/\\nconst hashBadly = thing => {\\n  const type = typeof thing;\\n  const allowableNonObjectValues = ['string', 'number', 'bigint', 'boolean'];\\n  if (allowableNonObjectValues.includes(type)) {\\n    return thing;}\\n\\n  if (marshal.passStyleOf(thing) === 'presence') {\\n    return thing;}\\n\\n  if (marshal.passStyleOf(thing) === 'copyRecord') {\\n    return getKeyForRecord(thing);}\\n\\n  assert.assert.fail(\\n  assert.details`typeof ${typeof thing} is not allowed in an amount of MathKind.SET`);};\\n\\n\\n\\nconst makeBuckets = list => {\\n  const buckets = new Map();\\n  list.forEach(elem => {\\n    const badHash = hashBadly(elem);\\n    if (!buckets.has(badHash)) {\\n      buckets.set(badHash, []);}\\n\\n    const soFar = buckets.get(badHash);\\n    soFar.push(elem);});\\n\\n  return buckets;};\\n\\n\\n/* Based on bucket sort*/\\nconst checkForDupes = buckets => {\\n  for (const maybeMatches of buckets.values()) {\\n    for (let i = 0; i < maybeMatches.length; i += 1) {\\n      for (let j = i + 1; j < maybeMatches.length; j += 1) {\\n        assert.assert(\\n        !sameStructure.sameStructure(maybeMatches[i], maybeMatches[j]),\\n        assert.details`value has duplicates: ${maybeMatches[i]} and ${maybeMatches[j]}`);}}}};\\n\\n\\n\\n\\n\\n\\nconst hasElement = (buckets, elem) => {\\n  const badHash = hashBadly(elem);\\n  if (!buckets.has(badHash)) {\\n    return false;}\\n\\n  const maybeMatches = buckets.get(badHash);\\n  return maybeMatches.some(maybeMatch => sameStructure.sameStructure(maybeMatch, elem));};\\n\\n\\n/* get a string of string keys and string values as a fuzzy hash for*/\\n/* bucketing.*/\\n/* only use sameStructure within that bucket.*/\\n\\n/**\\n * @type {SetMathHelpers}\\n */\\nconst setMathHelpers = harden({\\n  doCoerce: list => {\\n    harden(list);\\n    sameStructure.mustBeComparable(list);\\n    assert.assert(marshal.passStyleOf(list) === 'copyArray', 'list must be an array');\\n    checkForDupes(makeBuckets(list));\\n    return list;},\\n\\n  doMakeEmpty: _ => identity,\\n  doIsEmpty: list => marshal.passStyleOf(list) === 'copyArray' && list.length === 0,\\n  doIsGTE: (left, right) => {\\n    const leftBuckets = makeBuckets(left);\\n    return right.every(rightElem => hasElement(leftBuckets, rightElem));},\\n\\n  doIsEqual: (left, right) => {\\n    return left.length === right.length && setMathHelpers.doIsGTE(left, right);},\\n\\n  doAdd: (left, right) => {\\n    const combined = harden([...left, ...right]);\\n    checkForDupes(makeBuckets(combined));\\n    return combined;},\\n\\n  doSubtract: (left, right) => {\\n    const leftBuckets = makeBuckets(left);\\n    const rightBuckets = makeBuckets(right);\\n    right.forEach(rightElem => {\\n      assert.assert(\\n      hasElement(leftBuckets, rightElem),\\n      assert.details`right element ${rightElem} was not in left`);});\\n\\n\\n    const leftElemNotInRight = leftElem => !hasElement(rightBuckets, leftElem);\\n    return harden(left.filter(leftElemNotInRight));} });\\n\\n\\n\\nharden(setMathHelpers);exports.default = setMathHelpers;\",\n  \"ertp/src/deprecatedAmountMath.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var assert = require('../../assert/src/assert.js');var marshal = require('../../marshal/src/marshal.js');require('../../marshal/index.js');var sameStructure = require('../../same-structure/src/sameStructure.js');require('../../same-structure/index.js');var natMathHelpers = require('./mathHelpers/natMathHelpers.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nsetMathHelpers = require('./mathHelpers/setMathHelpers.js'); /* @ts-nocheck*/ /* We want an enum, but narrowed to the AmountMathKind type.*/ /**\\n * Constants for the kinds of amountMath we support.\\n *\\n * @type {{ NAT: 'nat', SET: 'set', STRING_SET: 'strSet' }}\\n */\\nconst MathKind = {\\n  NAT: 'nat',\\n  SET: 'set',\\n  STRING_SET: 'strSet' };\\n\\nharden(MathKind);\\n\\n\\n/**\\n * @deprecated Please import `amountMath` from `@agoric/ertp` directly.\\n * @param {Brand} brand\\n * @param {AmountMathKind} amountMathKind\\n * @returns {DeprecatedAmountMath}\\n */\\nfunction makeAmountMath(brand, amountMathKind) {\\n  sameStructure.mustBeComparable(brand);\\n  assert.assert.typeof(amountMathKind, 'string');\\n\\n  const mathHelpers = {\\n    nat: natMathHelpers.default,\\n    set: setMathHelpers.default,\\n    strSet: setMathHelpers.default };\\n\\n  const helpers = mathHelpers[amountMathKind];\\n  assert.assert(\\n  helpers !== undefined,\\n  assert.details`unrecognized amountMathKind: ${amountMathKind}`);\\n\\n\\n  /* Cache the amount if we can.*/\\n  const cache = new WeakSet();\\n\\n  /** @type {DeprecatedAmountMath} */\\n  const amountMath = marshal.Far('amountMath', {\\n    getBrand: () => brand,\\n    getAmountMathKind: () => amountMathKind,\\n\\n    /**\\n     * Make an amount from a value by adding the brand.\\n     *\\n     * @param {Value} allegedValue\\n     * @returns {Amount}\\n     */\\n    make: allegedValue => {\\n      const value = helpers.doCoerce(allegedValue);\\n      const amount = harden({ brand, value });\\n      cache.add(amount);\\n      return amount;},\\n\\n\\n    /**\\n     * Make sure this amount is valid and return it if so, throwing if invalid.\\n     *\\n     * @param {Amount} allegedAmount\\n     * @returns {Amount} or throws if invalid\\n     */\\n    coerce: allegedAmount => {\\n      /* If the cache already has the allegedAmount, that*/\\n      /* means it is a valid amount.*/\\n      if (cache.has(allegedAmount)) {\\n        return allegedAmount;}\\n\\n      const { brand: allegedBrand, value } = allegedAmount;\\n      assert.assert(\\n      allegedBrand !== undefined,\\n      assert.details`The brand in allegedAmount ${allegedAmount} is undefined. Did you pass a value rather than an amount?`);\\n\\n      assert.assert(\\n      brand === allegedBrand,\\n      assert.details`The brand in the allegedAmount ${allegedAmount} in 'coerce' didn't match the amountMath brand ${brand}.`);\\n\\n      /* Will throw on inappropriate value*/\\n      return amountMath.make(value);},\\n\\n\\n    /* Get the value from the amount.*/\\n    getValue: amount => amountMath.coerce(amount).value,\\n\\n    /* Represents the empty set/mathematical identity.*/\\n    /* eslint-disable-next-line no-use-before-define*/\\n    getEmpty: () => empty,\\n\\n    /* Is the amount equal to the empty set?*/\\n    isEmpty: amount => helpers.doIsEmpty(amountMath.getValue(amount)),\\n\\n    /* Is leftAmount greater than or equal to rightAmount? In other*/\\n    /* words, is everything in the rightAmount included in the*/\\n    /* leftAmount?*/\\n    isGTE: (leftAmount, rightAmount) =>\\n    helpers.doIsGTE(\\n    amountMath.getValue(leftAmount),\\n    amountMath.getValue(rightAmount)),\\n\\n\\n    /* Is leftAmount equal to rightAmount?*/\\n    isEqual: (leftAmount, rightAmount) =>\\n    helpers.doIsEqual(\\n    amountMath.getValue(leftAmount),\\n    amountMath.getValue(rightAmount)),\\n\\n\\n    /* Combine leftAmount and rightAmount.*/\\n    add: (leftAmount, rightAmount) =>\\n    amountMath.make(\\n    helpers.doAdd(\\n    amountMath.getValue(leftAmount),\\n    amountMath.getValue(rightAmount))),\\n\\n\\n\\n    /* Return the amount included in leftAmount but not included in*/\\n    /* rightAmount. If leftAmount does not include all of rightAmount,*/\\n    /* error.*/\\n    subtract: (leftAmount, rightAmount) =>\\n    amountMath.make(\\n    helpers.doSubtract(\\n    amountMath.getValue(leftAmount),\\n    amountMath.getValue(rightAmount))) });\\n\\n\\n\\n  const empty = amountMath.make(helpers.doMakeEmpty());\\n  return amountMath;}\\n\\n\\nharden(makeAmountMath);exports.MathKind = MathKind;exports.makeAmountMath = makeAmountMath;\",\n  \"ertp/src/typeGuards.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\nnat_esm = require('../../nat/dist/nat.esm.js'); /**\\n * Type guard for SetValue\\n * Used as a pre-validation check to select which validator\\n * (mathHelpers) to use, and also used with assert to satisfy\\n * Typescript checking\\n *\\n * @param {Value} value\\n * @returns {value is SetValue}\\n */\\nconst isSetValue = value => Array.isArray(value);\\n\\n/**\\n * Type guard for NatValue.\\n * Used as a pre-validation check to select which validator\\n * (mathHelpers) to use, and also used with assert to satisfy\\n * Typescript checking\\n *\\n * @param {Value} value\\n * @returns {value is NatValue}\\n */\\nconst isNatValue = value => nat_esm.isNat(value);exports.isNatValue = isNatValue;exports.isSetValue = isSetValue;\",\n  \"ertp/src/amountMath.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var assert = require('../../assert/src/assert.js');var nat_esm = require('../../nat/dist/nat.esm.js');var marshal = require('../../marshal/src/marshal.js');require('../../marshal/index.js');var sameStructure = require('../../same-structure/src/sameStructure.js');require('../../same-structure/index.js');var natMathHelpers = require('./mathHelpers/natMathHelpers.js');var setMathHelpers = require('./mathHelpers/setMathHelpers.js');var deprecatedAmountMath = require('./deprecatedAmountMath.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\ntypeGuards = require('./typeGuards.js'); /* @ts-check*/ /* We want an enum, but narrowed to the AmountMathKind type.*/ /**\\n * Constants for the kinds of amountMath we support.\\n *\\n * @type {{ NAT: 'nat', SET: 'set', STRING_SET: 'strSet' }}\\n */\\nconst MathKind = {\\n  NAT: 'nat',\\n  SET: 'set',\\n  /* Deprecated, to be removed in Beta*/\\n  STRING_SET: 'strSet' };\\n\\nharden(MathKind);\\n\\n/**\\n * Amounts describe digital assets. From an amount, you can learn the\\n * kind of digital asset as well as \\\"how much\\\" or \\\"how many\\\". Amounts\\n * have two parts: a brand (the kind of digital asset) and the value\\n * (the answer to \\\"how much\\\"). For example, in the phrase \\\"5 bucks\\\",\\n * \\\"bucks\\\" takes the role of the brand and the value is 5. Amounts\\n * can describe fungible and non-fungible digital assets. Amounts are\\n * pass-by-copy and can be made by and sent to anyone.\\n *\\n * The issuer has an internal table that maps purses and payments to\\n * amounts. The issuer must be able to do things such as add digital\\n * assets to a purse and withdraw digital assets from a purse. To do\\n * so, it must know how to add and subtract digital assets. Rather\\n * than hard-coding a particular solution, we chose to parameterize\\n * the issuer with a collection of polymorphic functions, which we\\n * call `amountMath`. These math functions include concepts like\\n * addition, subtraction, and greater than or equal to.\\n *\\n * We also want to make sure there is no confusion as to what kind of\\n * asset we are using. Thus, amountMath includes checks of the\\n * `brand`, the unique identifier for the type of digital asset. If\\n * the wrong brand is used in amountMath, an error is thrown and the\\n * operation does not succeed.\\n *\\n * amountMath uses mathHelpers to do most of the work, but then adds\\n * the brand to the result. The function `value` gets the value from\\n * the amount by removing the brand (amount -> value), and the function\\n * `make` adds the brand to produce an amount (value -> amount). The\\n * function `coerce` takes an amount and checks it, returning an amount (amount\\n * -> amount).\\n *\\n * Each issuer of digital assets has an associated brand in a one-to-one\\n * mapping. In untrusted contexts, such as in analyzing payments and\\n * amounts, we can get the brand and find the issuer which matches the\\n * brand. The issuer and the brand mutually validate each other.\\n */\\n\\n/** @type {{ nat: NatMathHelpers, set: SetMathHelpers, strSet: SetMathHelpers }} */\\nconst helpers = {\\n  nat: natMathHelpers.default,\\n  set: setMathHelpers.default,\\n  strSet: setMathHelpers.default };\\n\\n\\n/**\\n * @param {Value} value\\n * @returns {NatMathHelpers | SetMathHelpers}\\n */\\nconst getHelpersFromValue = value => {\\n  if (typeGuards.isSetValue(value)) {\\n    return setMathHelpers.default;}\\n\\n  if (typeGuards.isNatValue(value)) {\\n    return natMathHelpers.default;}\\n\\n  assert.assert.fail(assert.details`value ${value} must be a bigint or an array`);};\\n\\n\\n/** @type {(amount: Amount) => AmountMathKind} */\\nconst getMathKind = amount => {\\n  if (typeGuards.isSetValue(amount.value)) {\\n    return 'set';}\\n\\n  if (typeGuards.isNatValue(amount.value)) {\\n    return 'nat';}\\n\\n  assert.assert.fail(assert.details`value ${amount.value} must be a bigint or an array`);};\\n\\n\\n/**\\n * @type {(amount: Amount ) => NatMathHelpers | SetMathHelpers }\\n */\\nconst getHelpersFromAmount = amount => {\\n  return getHelpersFromValue(amount.value);};\\n\\n\\n/** @type {(leftAmount: Amount, rightAmount: Amount ) =>\\n * NatMathHelpers | SetMathHelpers } */\\nconst getHelpers = (leftAmount, rightAmount) => {\\n  const leftHelpers = getHelpersFromAmount(leftAmount);\\n  const rightHelpers = getHelpersFromAmount(rightAmount);\\n  assert.assert.equal(leftHelpers, rightHelpers);\\n  return leftHelpers;};\\n\\n\\n/** @type {(amount: Amount, brand?: Brand) => void} */\\nconst optionalBrandCheck = (amount, brand) => {\\n  if (brand !== undefined) {\\n    sameStructure.mustBeComparable(brand);\\n    assert.assert.equal(\\n    amount.brand,\\n    brand,\\n    assert.details`amount's brand ${amount.brand} did not match expected brand ${brand}`);}};\\n\\n\\n\\n\\n/** @type {(value: Value, brand: Brand) => Amount} */\\nconst noCoerceMake = (value, brand) => {\\n  const amount = harden({ brand, value });\\n  return amount;};\\n\\n\\n/** @type {(value: Value) => void} */\\nconst assertLooksLikeValue = value => {\\n  assert.assert(\\n  Array.isArray(value) || nat_esm.isNat(value),\\n  assert.details`value ${value} must be a Nat or an array`);};\\n\\n\\n\\nconst assertBrand = (brand, msg) => {\\n  assert.assert(marshal.passStyleOf(brand) === marshal.REMOTE_STYLE, msg);};\\n\\n\\n/** @type {(brand: Brand) => void} */\\nconst assertLooksLikeBrand = brand => {\\n  const msg = assert.details`The brand ${brand} doesn't look like a brand.`;\\n  assertBrand(brand, msg);};\\n\\n\\n/**\\n * Give a better error message by logging the entire amount\\n * rather than just the brand\\n *\\n * @type {(amount: Amount) => void}\\n */\\nconst assertLooksLikeAmountBrand = amount => {\\n  const msg = assert.details`The amount ${amount} doesn't look like an amount. Did you pass a value instead?`;\\n  assertBrand(amount.brand, msg);};\\n\\n\\nconst assertLooksLikeAmount = amount => {\\n  assertLooksLikeAmountBrand(amount);\\n  assertLooksLikeValue(amount.value);};\\n\\n\\nconst checkLRAndGetHelpers = (leftAmount, rightAmount, brand = undefined) => {\\n  assertLooksLikeAmount(leftAmount);\\n  assertLooksLikeAmount(rightAmount);\\n  optionalBrandCheck(leftAmount, brand);\\n  optionalBrandCheck(rightAmount, brand);\\n  assert.assert.equal(\\n  leftAmount.brand,\\n  rightAmount.brand,\\n  assert.details`Brands in left ${leftAmount.brand} and right ${rightAmount.brand} should match but do not`);\\n\\n  return getHelpers(leftAmount, rightAmount);};\\n\\n\\nconst coerceLR = (h, leftAmount, rightAmount) => {\\n  return [h.doCoerce(leftAmount.value), h.doCoerce(rightAmount.value)];};\\n\\n\\n/** @type {AmountMath} */\\nconst amountMath = {\\n  make: (allegedValue, brand) => {\\n    assertLooksLikeBrand(brand);\\n    assertLooksLikeValue(allegedValue);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    const value = getHelpersFromValue(allegedValue).doCoerce(allegedValue);\\n    return harden({ brand, value });},\\n\\n  coerce: (allegedAmount, brand) => {\\n    assertLooksLikeAmount(allegedAmount);\\n    assertLooksLikeBrand(brand);\\n    assert.assert(\\n    brand === allegedAmount.brand,\\n    assert.details`The brand in the allegedAmount ${allegedAmount} in 'coerce' didn't match the specified brand ${brand}.`);\\n\\n    /* Will throw on inappropriate value*/\\n    return amountMath.make(allegedAmount.value, brand);},\\n\\n  getValue: (amount, brand) => amountMath.coerce(amount, brand).value,\\n  makeEmpty: (brand, mathKind = MathKind.NAT) => {\\n    assert.assert(\\n    helpers[mathKind],\\n    assert.details`${mathKind} must be MathKind.NAT or MathKind.SET. MathKind.STRING_SET is accepted but deprecated`);\\n\\n    assertLooksLikeBrand(brand);\\n    return noCoerceMake(helpers[mathKind].doMakeEmpty(), brand);},\\n\\n  makeEmptyFromAmount: (amount) =>\\n  amountMath.makeEmpty(amount.brand, getMathKind(amount)),\\n  isEmpty: (amount, brand = undefined) => {\\n    assertLooksLikeAmount(amount);\\n    optionalBrandCheck(amount, brand);\\n    const h = getHelpersFromAmount(amount);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    return h.doIsEmpty(h.doCoerce(amount.value));},\\n\\n  isGTE: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    return h.doIsGTE(...coerceLR(h, leftAmount, rightAmount));},\\n\\n  isEqual: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    return h.doIsEqual(...coerceLR(h, leftAmount, rightAmount));},\\n\\n  add: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    return noCoerceMake(\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    h.doAdd(...coerceLR(h, leftAmount, rightAmount)),\\n    leftAmount.brand);},\\n\\n\\n  subtract: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    return noCoerceMake(\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    h.doSubtract(...coerceLR(h, leftAmount, rightAmount)),\\n    leftAmount.brand);} };\\n\\n\\n\\nharden(amountMath);exports.makeAmountMath = deprecatedAmountMath.makeAmountMath;exports.MathKind = MathKind;exports.amountMath = amountMath;exports.getMathKind = getMathKind;\",\n  \"store/src/helpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var marshal = require('../../marshal/src/marshal.js');\\n\\n\\n\\nrequire('../../marshal/index.js'); /* @ts-check*/ /**\\n * Helper function to reject keys which are empty objects but not marked as\\n * Remotable. This is intended to catch code which uses harden({}) (which\\n * will become pass-by-copy, see #2018) as a \\\"handle\\\" or \\\"marker object\\\"\\n * when they should have used Far().\\n *\\n * @param { unknown } key\\n */\\nfunction isEmptyNonRemotableObject(key) {\\n  return (\\n    typeof key === 'object' &&\\n    key !== null &&\\n    Reflect.ownKeys(key).length === 0 &&\\n    marshal.getInterfaceOf(key) === undefined);}\\n\\n\\nharden(isEmptyNonRemotableObject);exports.isEmptyNonRemotableObject = isEmptyNonRemotableObject;\",\n  \"store/src/store.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var\\n\\n\\n\\n\\n\\n\\nhelpers = require('./helpers.js'); /* Copyright (C) 2019 Agoric, under Apache license 2.0*/ /**\\n * Distinguishes between adding a new key (init) and updating or\\n * referencing a key (get, set, delete).\\n *\\n * `init` is only allowed if the key does not already exist. `Get`,\\n * `set` and `delete` are only allowed if the key does already exist.\\n *\\n * @template K,V\\n * @param  {string} [keyName='key'] - the column name for the key\\n * @returns {Store<K,V>}\\n */\\nfunction makeStore(keyName = 'key') {\\n  const store = new Map();\\n  const assertKeyDoesNotExist = (key) =>\\n  assert.assert(!store.has(key), assert.details`${assert.quote(keyName)} already registered: ${key}`);\\n  const assertKeyExists = (key) =>\\n  assert.assert(store.has(key), assert.details`${assert.quote(keyName)} not found: ${key}`);\\n  const assertNotBadKey = (key) =>\\n  assert.assert(!helpers.isEmptyNonRemotableObject(key), assert.details`${assert.quote(keyName)} bad key: ${key}`);\\n  return harden({\\n    has: key => {\\n      assertNotBadKey(key);\\n      return store.has(key);},\\n\\n    init: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyDoesNotExist(key);\\n      store.set(key, value);},\\n\\n    get: key => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      return store.get(key);},\\n\\n    set: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      store.set(key, value);},\\n\\n    delete: key => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      store.delete(key);},\\n\\n    keys: () => Array.from(store.keys()),\\n    values: () => Array.from(store.values()),\\n    entries: () => Array.from(store.entries()) });}\\n\\n\\nharden(makeStore);exports.makeStore = makeStore;\",\n  \"store/src/weak-store.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var assert = require('../../assert/src/assert.js');var\\n\\n\\n\\n\\n\\n\\n\\nhelpers = require('./helpers.js'); /* Copyright (C) 2019 Agoric, under Apache license 2.0*/ /**\\n * @template {Record<any, any>} K\\n * @template {any} V\\n * @param {string} [keyName='key']\\n * @returns {WeakStore<K, V>}\\n */\\nfunction makeWeakStore(keyName = 'key') {\\n  const wm = new WeakMap();\\n  const assertKeyDoesNotExist = (key) =>\\n  assert.assert(!wm.has(key), assert.details`${assert.quote(keyName)} already registered: ${key}`);\\n  const assertKeyExists = (key) =>\\n  assert.assert(wm.has(key), assert.details`${assert.quote(keyName)} not found: ${key}`);\\n  const assertNotBadKey = (key) =>\\n  assert.assert(!helpers.isEmptyNonRemotableObject(key), assert.details`${assert.quote(keyName)} bad key: ${key}`);\\n  return harden({\\n    has: key => {\\n      assertNotBadKey(key);\\n      return wm.has(key);},\\n\\n    init: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyDoesNotExist(key);\\n      wm.set(key, value);},\\n\\n    get: key => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      return wm.get(key);},\\n\\n    set: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      wm.set(key, value);},\\n\\n    delete: key => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      wm.delete(key);} });}\\n\\n\\n\\nharden(makeWeakStore);exports.makeWeakStore = makeWeakStore;\",\n  \"store/src/external/memory.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../types.js');var\\n\\n\\n\\n\\n\\nweakStore = require('../weak-store.js'); /* Copyright (C) 2019-20 Agoric, under Apache license 2.0*/ /**\\n * Create a completely in-memory \\\"external\\\" store.  This store will be\\n * garbage-collected in the usual way, but it will not page out any objects to\\n * secondary storage.\\n *\\n * @template {(...args: any[]) => ExternalInstance} M\\n * @param {string} keyName\\n * @param {M} maker\\n * @returns {ExternalStore<M>}\\n */\\nfunction makeMemoryExternalStore(keyName, maker) {\\n  return harden({\\n    makeInstance: maker,\\n    makeWeakStore() {\\n      return weakStore.makeWeakStore(keyName);} });}\\n\\n\\n\\nharden(makeMemoryExternalStore);exports.makeMemoryExternalStore = makeMemoryExternalStore;\",\n  \"store/src/external/default.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../types.js');var memory = require('./memory.js'); /* Copyright (C) 2019 Agoric, under Apache license 2.0*/\\n\\n\\n\\n\\n\\n\\nconst makeExternalStore = memory.makeMemoryExternalStore;exports.makeExternalStore = makeExternalStore;\",\n  \"store/src/external/hydrate.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../types.js');var store = require('../store.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nweakStore = require('../weak-store.js'); /* @ts-check*/ /**\\n * @callback MakeBackingStore\\n * @param {HydrateHook} hydrateHook\\n * @returns {BackingStore}\\n */ /**\\n * This creates an external store maker for a given storage backend, supporting\\n * the Closure interface that the rewriter targets.\\n *\\n * @template {Array<any>} A\\n * @template {ExternalInstance} T\\n * @param {MakeBackingStore} makeBackingStore\\n * @returns {MakeHydrateExternalStore<A, T>}\\n */const makeHydrateExternalStoreMaker = makeBackingStore => {/** @type {WeakStore<T, HydrateKey>} */const instanceToKey = weakStore.makeWeakStore('instance');\\n  let lastStoreId = 0;\\n\\n  /* This has to be a strong store, since it is indexed by ID.*/\\n  const storeIdToHydrate = store.makeStore('storeId');\\n\\n  /**\\n   * Create a data object that queues writes to the store.\\n   *\\n   * @param {HydrateData} data\\n   * @param {() => void} markDirty\\n   */\\n  const makeActiveData = (data, markDirty) => {\\n    const activeData = {};\\n    /* For every property in data...*/\\n    for (const prop of Object.getOwnPropertyNames(data)) {\\n      /* Define a getter and setter on activeData.*/\\n      Object.defineProperty(activeData, prop, {\\n        get: () => data[prop],\\n        set: value => {\\n          data[prop] = value;\\n          markDirty();} });}\\n\\n\\n\\n    return harden(activeData);};\\n\\n\\n  /** @type {BackingStore} */\\n  let backing;\\n\\n  /** @type {HydrateHook} */\\n  const hydrateHook = {\\n    getKey(value) {\\n      return instanceToKey.get(value);},\\n\\n    load([storeId, instanceId]) {\\n      const hydrate = storeIdToHydrate.get(storeId);\\n      const store = backing.getHydrateStore(storeId);\\n\\n      const data = store.get(instanceId);\\n      const markDirty = () => store.set(instanceId, data);\\n\\n      const activeData = makeActiveData(data, markDirty);\\n      const obj = hydrate(activeData);\\n      instanceToKey.init(obj, [storeId, instanceId]);\\n      return obj;},\\n\\n    drop(storeId) {\\n      storeIdToHydrate.delete(storeId);} };\\n\\n\\n\\n  backing = makeBackingStore(hydrateHook);\\n\\n  /** @type {MakeHydrateExternalStore<A, T>} */\\n  function makeHydrateExternalStore(keyName, adaptArguments, makeHydrate) {\\n    let lastInstanceId = 0;\\n\\n    lastStoreId += 1;\\n    const storeId = lastStoreId;\\n    const hstore = backing.makeHydrateStore(storeId, keyName);\\n\\n    const initHydrate = makeHydrate(true);\\n    storeIdToHydrate.init(storeId, makeHydrate());\\n\\n    /** @type {ExternalStore<(...args: A) => T>} */\\n    const estore = {\\n      makeInstance(...args) {\\n        const data = adaptArguments(...args);\\n        /* Create a new object with the above guts.*/\\n        lastInstanceId += 1;\\n        const instanceId = lastInstanceId;\\n        initHydrate(data);\\n\\n        /* We store and reload it to sanity-check the initial state and also to*/\\n        /* ensure that the new object has active data.*/\\n        hstore.init(instanceId, data);\\n        return hydrateHook.load([storeId, instanceId]);},\\n\\n      makeWeakStore() {\\n        return hstore.makeWeakStore();} };\\n\\n\\n    return estore;}\\n\\n  return harden(makeHydrateExternalStore);};exports.makeHydrateExternalStoreMaker = makeHydrateExternalStoreMaker;\",\n  \"store/src/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var store = require('./store.js');var weakStore = require('./weak-store.js');var memory = require('./external/memory.js');var _default = require('./external/default.js');var hydrate = require('./external/hydrate.js');exports.default = store.makeStore;exports.makeStore = store.makeStore;exports.makeWeakStore = weakStore.makeWeakStore;exports.makeMemoryExternalStore = memory.makeMemoryExternalStore;exports.makeExternalStore = _default.makeExternalStore;exports.makeHydrateExternalStoreMaker = hydrate.makeHydrateExternalStoreMaker;\",\n  \"notifier/src/asyncIterableAdaptor.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var\\n\\n\\n\\n\\n\\n\\n\\nnoShim = require('../../eventual-send/src/no-shim.js'); /* @ts-check*/ /**\\n * Adaptor from a notifierP to an async iterable.\\n * The notifierP can be any object that has an eventually invokable\\n * `getUpdateSince` method that behaves according to the notifier\\n * spec. This can be a notifier, a promise for a local or remote\\n * notfier, or a presence of a remote notifier.\\n *\\n * It is also used internally by notifier.js so that a notifier itself is an\\n * async iterable.\\n *\\n * An async iterable is an object with a `[Symbol.asyncIterator]()` method\\n * that returns an async iterator. The async iterator we return here has only\\n * a `next()` method, without the optional `return` and `throw` methods. The\\n * omitted methods, if present, would be used by the for/await/of loop to\\n * inform the iterator of early termination. But this adaptor would not do\\n * anything useful in reaction to this notification.\\n *\\n * An async iterator's `next()` method returns a promise for an iteration\\n * result. An iteration result is a record with `value` and `done` properties.\\n *\\n * The purpose of building on the notifier protocol is to have a lossy\\n * adaptor, where intermediate results can be missed in favor of more recent\\n * results which are therefore less stale. See\\n * https://github.com/Agoric/documentation/blob/master/main/distributed-programming.md#notifiers\\n *\\n * @template T\\n * @param {ERef<BaseNotifier<T>>} notifierP\\n * @returns {AsyncIterable<T>}\\n */\\nconst makeAsyncIterableFromNotifier = notifierP => {\\n  return harden({\\n    [Symbol.asyncIterator]: () => {\\n      /** @type {UpdateCount} */\\n      let localUpdateCount;\\n      /** @type {Promise<{value: T, done: boolean}> | undefined} */\\n      let myIterationResultP;\\n      return harden({\\n        next: () => {\\n          if (!myIterationResultP) {\\n            /* In this adaptor, once `next()` is called and returns an*/\\n            /* unresolved promise, `myIterationResultP`, and until*/\\n            /* `myIterationResultP` is fulfilled with an*/\\n            /* iteration result, further `next()` calls will return the same*/\\n            /* `myIterationResultP` promise again without asking the notifier*/\\n            /* for more updates. If there's already an unanswered ask in the*/\\n            /* air, all further asks should just reuse the result of that one.*/\\n            /**/\\n            /* This reuse behavior is only needed for code that uses the async*/\\n            /* iterator protocol explicitly. When this async iterator is*/\\n            /* consumed by a for/await/of loop, `next()` will only be called*/\\n            /* after the promise for the previous iteration result has*/\\n            /* fulfilled. If it fulfills with `done: true`, the for/await/of*/\\n            /* loop will never call `next()` again.*/\\n            /**/\\n            /* See*/\\n            /* https://2ality.com/2016/10/asynchronous-iteration.html#queuing-next()-invocations*/\\n            /* for an explicit use that sends `next()` without waiting.*/\\n            myIterationResultP = noShim.E(notifierP).\\n            getUpdateSince(localUpdateCount).\\n            then(({ value, updateCount }) => {\\n              localUpdateCount = updateCount;\\n              const done = localUpdateCount === undefined;\\n              if (!done) {\\n                /* Once the outstanding question has been answered, stop*/\\n                /* using that answer, so any further `next()` questions*/\\n                /* cause a new `getUpdateSince` request.*/\\n                /**/\\n                /* But only if more answers are expected. Once the notifier*/\\n                /* is `done`, that was the last answer so reuse it forever.*/\\n                myIterationResultP = undefined;}\\n\\n              return harden({ value, done });});}\\n\\n\\n          return myIterationResultP;} });} });};\\n\\n\\n\\n\\n\\n\\n/**\\n * This advances `asyncIteratorP` updating `iterationObserver` with each\\n * successive value. The `iterationObserver` may only be interested in certain\\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\\n * `observeIterator` feature tests for those methods before calling them.\\n *\\n * @template T\\n * @param {ERef<AsyncIterator<T>>} asyncIteratorP\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @returns {Promise<undefined>}\\n */\\nconst observeIterator = (asyncIteratorP, iterationObserver) => {\\n  return new Promise(ack => {\\n    const recur = () => {\\n      noShim.E.when(\\n      noShim.E(asyncIteratorP).next(),\\n      ({ value, done }) => {\\n        if (done) {\\n          iterationObserver.finish && iterationObserver.finish(value);\\n          ack(undefined);} else\\n        {\\n          iterationObserver.updateState &&\\n          iterationObserver.updateState(value);\\n          recur();}},\\n\\n\\n      reason => {\\n        iterationObserver.fail && iterationObserver.fail(reason);\\n        ack(undefined);});};\\n\\n\\n\\n    recur();});};\\n\\n\\n\\n/**\\n * This reads from `asyncIterableP` updating `iterationObserver` with each\\n * successive value. The `iterationObserver` may only be interested in certain\\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\\n * `observeIteration` feature tests for those methods before calling them.\\n *\\n * @template T\\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @returns {Promise<undefined>}\\n */\\nconst observeIteration = (asyncIterableP, iterationObserver) => {\\n  const iteratorP = noShim.E(asyncIterableP)[Symbol.asyncIterator]();\\n  return observeIterator(iteratorP, iterationObserver);};\\n\\n\\n/**\\n * @deprecated Use `observeIteration` instead\\n * @template T\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\\n * @returns {Promise<undefined>}\\n */\\nconst updateFromIterable = (iterationObserver, asyncIterableP) =>\\nobserveIteration(asyncIterableP, iterationObserver);\\n\\n/**\\n * As updates come in from the possibly remote `notifierP`, update\\n * the local `updater`. Since the updates come from a notifier, they\\n * are lossy, i.e., once a more recent state can be reported, less recent\\n * states are assumed irrelevant and dropped.\\n *\\n * @template T\\n * @param {ERef<Notifier<T>>} notifierP\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @returns {Promise<undefined>}\\n */\\nconst observeNotifier = (notifierP, iterationObserver) =>\\nobserveIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);\\n\\n/**\\n * @deprecated Use 'observeNotifier` instead.\\n * @template T\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @param {ERef<Notifier<T>>} notifierP\\n * @returns {Promise<undefined>}\\n */\\nconst updateFromNotifier = (iterationObserver, notifierP) =>\\nobserveIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);exports.makeAsyncIterableFromNotifier = makeAsyncIterableFromNotifier;exports.observeIteration = observeIteration;exports.observeIterator = observeIterator;exports.observeNotifier = observeNotifier;exports.updateFromIterable = updateFromIterable;exports.updateFromNotifier = updateFromNotifier;\",\n  \"notifier/src/notifier.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var assert = require('../../assert/src/assert.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');var marshal = require('../../marshal/src/marshal.js');require('../../marshal/index.js');var asyncIterableAdaptor = require('./asyncIterableAdaptor.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst makeNotifier = baseNotifierP => {\\n  const asyncIterable = asyncIterableAdaptor.makeAsyncIterableFromNotifier(baseNotifierP);\\n\\n  return harden({\\n    ...asyncIterable,\\n    getSharableNotifierInternals: () => baseNotifierP });};\\n\\n\\n\\n/**\\n * Produces a pair of objects, which allow a service to produce a stream of\\n * update promises.\\n *\\n * The initial state argument has to be truly optional even though it can\\n * be any first class value including `undefined`. We need to distinguish the\\n * presence vs the absence of it, which we cannot do with the optional argument\\n * syntax. Rather we use the arity of the arguments array.\\n *\\n * If no initial state is provided to `makeNotifierKit`, then it starts without\\n * an initial state. Its initial state will instead be the state of the first\\n * update.\\n *\\n * @template T\\n * @param {[] | [T]} args the first state to be returned\\n * @returns {NotifierRecord<T>} the notifier and updater\\n */\\nconst makeNotifierKit = (...args) => {\\n  /** @type {PromiseRecord<UpdateRecord<T>>|undefined} */\\n  let nextPromiseKit = promiseKit.makePromiseKit();\\n  /** @type {UpdateCount} */\\n  let currentUpdateCount = 1; /* avoid falsy numbers*/\\n  /** @type {UpdateRecord<T>|undefined} */\\n  let currentResponse;\\n\\n  const hasState = () => currentResponse !== undefined;\\n\\n  const final = () => currentUpdateCount === undefined;\\n\\n  const baseNotifier = harden({\\n    /* NaN matches nothing*/\\n    getUpdateSince(updateCount = NaN) {\\n      if (\\n      hasState() && (\\n      final() ||\\n      currentResponse && currentResponse.updateCount !== updateCount))\\n      {\\n        /* If hasState() and either it is final() or it is*/\\n        /* not the state of updateCount, return the current state.*/\\n        assert.assert(currentResponse !== undefined);\\n        return Promise.resolve(currentResponse);}\\n\\n      /* otherwise return a promise for the next state.*/\\n      assert.assert(nextPromiseKit);\\n      return nextPromiseKit.promise;} });\\n\\n\\n\\n  const notifier = marshal.Far('notifier', {\\n    ...makeNotifier(baseNotifier),\\n    /* TODO stop exposing baseNotifier methods directly*/\\n    ...baseNotifier });\\n\\n\\n  const updater = harden({\\n    updateState(state) {\\n      if (final()) {\\n        throw new Error('Cannot update state after termination.');}\\n\\n\\n      /* become hasState() && !final()*/\\n      assert.assert(nextPromiseKit && currentUpdateCount);\\n      currentUpdateCount += 1;\\n      currentResponse = harden({\\n        value: state,\\n        updateCount: currentUpdateCount });\\n\\n      nextPromiseKit.resolve(currentResponse);\\n      nextPromiseKit = promiseKit.makePromiseKit();},\\n\\n\\n    finish(finalState) {\\n      if (final()) {\\n        throw new Error('Cannot finish after termination.');}\\n\\n\\n      /* become hasState() && final()*/\\n      assert.assert(nextPromiseKit);\\n      currentUpdateCount = undefined;\\n      currentResponse = harden({\\n        value: finalState,\\n        updateCount: currentUpdateCount });\\n\\n      nextPromiseKit.resolve(currentResponse);\\n      nextPromiseKit = undefined;},\\n\\n\\n    fail(reason) {\\n      if (final()) {\\n        throw new Error('Cannot fail after termination.');}\\n\\n\\n      /* become !hasState() && final()*/\\n      assert.assert(nextPromiseKit);\\n      currentUpdateCount = undefined;\\n      currentResponse = undefined;\\n      /* Don't trigger Node.js's UnhandledPromiseRejectionWarning*/\\n      nextPromiseKit.promise.catch(_ => {});\\n      nextPromiseKit.reject(reason);} });\\n\\n\\n\\n  if (args.length >= 1) {\\n    updater.updateState(args[0]);}\\n\\n\\n  /* notifier facet is separate so it can be handed out while updater*/\\n  /* is tightly held*/\\n  return harden({ notifier, updater });};\\n\\n\\n/**\\n * Adaptor from async iterable to notifier.\\n *\\n * @template T\\n * @param {AsyncIterable<T>} asyncIterable\\n * @returns {Notifier<T>}\\n */\\nconst makeNotifierFromAsyncIterable = asyncIterable => {\\n  const { notifier, updater } = makeNotifierKit();\\n  asyncIterableAdaptor.observeIteration(asyncIterable, updater);\\n  return notifier;};exports.makeNotifier = makeNotifier;exports.makeNotifierFromAsyncIterable = makeNotifierFromAsyncIterable;exports.makeNotifierKit = makeNotifierKit;\",\n  \"notifier/src/subscriber.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var noShim = require('../../eventual-send/src/no-shim.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');var marshal = require('../../marshal/src/marshal.js');\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('../../marshal/index.js'); /* @ts-check*/ /**\\n * @template T\\n * @param {SubscriptionInternals} startP\\n * @returns {Subscription<T>}\\n */\\nconst makeSubscription = startP => {\\n  return marshal.Far('Subscription', {\\n    /* eslint-disable-next-line no-use-before-define*/\\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(startP),\\n\\n    /**\\n     * Use this to distribute a Subscription efficiently over the network,\\n     * by obtaining this from the Subscription to me replicated, and applying\\n     * `makeSubscription` to it at the new site to get an equivalent local\\n     * Subscription at that site.\\n     *\\n     * @returns {SubscriptionInternals}\\n     */\\n    getSharableSubscriptionInternals: () => startP });};\\n\\n\\nharden(makeSubscription);\\n\\n\\n/**\\n * @template T\\n * @param {SubscriptionInternals} tailP\\n * @returns {SubscriptionIterator<T>}\\n */\\nconst makeSubscriptionIterator = tailP => {\\n  /* To understand the implementation, start with*/\\n  /* https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue*/\\n  return marshal.Far('SubscriptionIterator', {\\n    subscribe: () => makeSubscription(tailP),\\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(tailP),\\n    next: () => {\\n      const resultP = noShim.E.get(tailP).head;\\n      tailP = noShim.E.get(tailP).tail;\\n      return resultP;} });};\\n\\n\\n\\n\\n/**\\n * Makes a `{ publicaction, subscription }` for doing lossless efficient\\n * distributed pub/sub.\\n *\\n * @template T\\n * @returns {SubscriptionRecord<T>}\\n */\\nconst makeSubscriptionKit = () => {\\n  let rear;\\n  const subscription = makeSubscription(new noShim.HandledPromise(r => rear = r));\\n\\n  const publication = marshal.Far('publication', {\\n    updateState: value => {\\n      if (rear === undefined) {\\n        throw new Error('Cannot update state after termination.');}\\n\\n      const { promise: nextTailE, resolve: nextRear } = promiseKit.makePromiseKit();\\n      rear(harden({ head: { value, done: false }, tail: nextTailE }));\\n      rear = nextRear;},\\n\\n    finish: finalValue => {\\n      if (rear === undefined) {\\n        throw new Error('Cannot finish after termination.');}\\n\\n      const readComplaint = noShim.HandledPromise.reject(\\n      new Error('cannot read past end of iteration'));\\n\\n      readComplaint.catch(_ => {}); /* suppress unhandled rejection error*/\\n      rear({ head: { value: finalValue, done: true }, tail: readComplaint });\\n      rear = undefined;},\\n\\n    fail: reason => {\\n      if (rear === undefined) {\\n        throw new Error('Cannot fail after termination.');}\\n\\n      rear(noShim.HandledPromise.reject(reason));\\n      rear = undefined;} });\\n\\n\\n  return harden({ publication, subscription });};\\n\\nharden(makeSubscriptionKit);exports.makeSubscription = makeSubscription;exports.makeSubscriptionKit = makeSubscriptionKit;\",\n  \"notifier/src/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var asyncIterableAdaptor = require('./asyncIterableAdaptor.js');var notifier = require('./notifier.js');var subscriber = require('./subscriber.js');exports.makeAsyncIterableFromNotifier = asyncIterableAdaptor.makeAsyncIterableFromNotifier;exports.observeIteration = asyncIterableAdaptor.observeIteration;exports.observeIterator = asyncIterableAdaptor.observeIterator;exports.observeNotifier = asyncIterableAdaptor.observeNotifier;exports.updateFromIterable = asyncIterableAdaptor.updateFromIterable;exports.updateFromNotifier = asyncIterableAdaptor.updateFromNotifier;exports.makeNotifier = notifier.makeNotifier;exports.makeNotifierFromAsyncIterable = notifier.makeNotifierFromAsyncIterable;exports.makeNotifierKit = notifier.makeNotifierKit;exports.makeSubscription = subscriber.makeSubscription;exports.makeSubscriptionKit = subscriber.makeSubscriptionKit;\",\n  \"ertp/src/interfaces.js\": \"'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* @ts-check*/ /** @type {ERTPKind} */\\nconst ERTPKind = {\\n  ISSUER: 'issuer',\\n  BRAND: 'brand',\\n  PURSE: 'purse',\\n  PAYMENT: 'payment',\\n  MINT: 'mint',\\n  /* TODO: improve implementation such that spaces can be used in*/\\n  /* ERTPKind. Currently we assume that the ERTPKind is the last*/\\n  /* element of the interface, after we split on spaces.*/\\n  DEPOSIT_FACET: 'depositFacet' };\\n\\n\\n/** @type {MakeFarName} */\\nconst makeFarName = (allegedName, kind) => `${allegedName} ${kind}`;\\n\\n/** @type {MakeInterface} */\\nconst makeInterface = (allegedName, kind) =>\\n`Alleged: ${allegedName} ${kind}`;exports.ERTPKind = ERTPKind;exports.makeFarName = makeFarName;exports.makeInterface = makeInterface;\",\n  \"ertp/src/displayInfo.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var marshal = require('../../marshal/src/marshal.js');\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('../../marshal/index.js'); /* @ts-check*/ /* TODO: assertSubset and assertKeysAllowed are copied from Zoe. Move*/ /* this code to a location where it can be used by ERTP and Zoe*/ /* easily. Perhaps another package.*/ /**\\n * Assert all values from `part` appear in `whole`.\\n *\\n * @param {string[]} whole\\n * @param {string[]} part\\n */\\nconst assertSubset = (whole, part) => {\\n  part.forEach(key => {\\n    assert.assert.typeof(key, 'string');\\n    assert.assert(\\n    whole.includes(key),\\n    assert.details`key ${assert.quote(key)} was not one of the expected keys ${assert.quote(whole)}`);});};\\n\\n\\n\\n\\n/* Assert that the keys of `record` are all in `allowedKeys`. If a key*/\\n/* of `record` is not in `allowedKeys`, throw an error. If a key in*/\\n/* `allowedKeys` is not a key of record, we do not throw an error.*/\\nconst assertKeysAllowed = (allowedKeys, record) => {\\n  const keys = Object.getOwnPropertyNames(record);\\n  assertSubset(allowedKeys, keys);\\n  /* assert that there are no symbol properties.*/\\n  assert.assert(\\n  Object.getOwnPropertySymbols(record).length === 0,\\n  assert.details`no symbol properties allowed`);};\\n\\n\\n\\nconst assertDisplayInfo = allegedDisplayInfo => {\\n  if (allegedDisplayInfo === undefined) {\\n    return;}\\n\\n  const displayInfoKeys = harden(['decimalPlaces']);\\n  assertKeysAllowed(displayInfoKeys, allegedDisplayInfo);};\\n\\n\\nconst coerceDisplayInfo = allegedDisplayInfo => {\\n  if (marshal.passStyleOf(allegedDisplayInfo) === marshal.REMOTE_STYLE) {\\n    /* These condition together try to ensure that `allegedDisplayInfo`*/\\n    /* is a plain empty object. It will accept all plain empty objects*/\\n    /* that it should. It will reject most things we want to reject including*/\\n    /* remotables that are explicitly declared `Remotable`. But a normal*/\\n    /* HandledPromise presence not explicitly declared `Remotable` will*/\\n    /* be mistaken for a plain empty object. Even in this case, the copy*/\\n    /* has a new identity, so the only danger is that we didn't reject*/\\n    /* with a diagnostic, potentially masking a programmer error.*/\\n    assert.assert(Object.isFrozen(allegedDisplayInfo));\\n    assert.assert.equal(Reflect.ownKeys(allegedDisplayInfo).length, 0);\\n    assert.assert.equal(Object.getPrototypeOf(allegedDisplayInfo), Object.prototype);\\n    assert.assert.equal(marshal.getInterfaceOf(allegedDisplayInfo), undefined);\\n    return harden({});}\\n\\n  allegedDisplayInfo = marshal.pureCopy(allegedDisplayInfo);\\n  assertDisplayInfo(allegedDisplayInfo);\\n  return allegedDisplayInfo;};exports.assertDisplayInfo = assertDisplayInfo;exports.assertKeysAllowed = assertKeysAllowed;exports.assertSubset = assertSubset;exports.coerceDisplayInfo = coerceDisplayInfo;\",\n  \"ertp/src/payment.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var marshal = require('../../marshal/src/marshal.js');require('../../marshal/index.js');var interfaces = require('./interfaces.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\nconst makePaymentMaker = (allegedName, brand) => {\\n  const paymentVOFactory = state => {\\n    return {\\n      init: b => state.brand = b,\\n      self: marshal.Far(interfaces.makeFarName(allegedName, interfaces.ERTPKind.PAYMENT), {\\n        getAllegedBrand: () => state.brand }) };};\\n\\n\\n\\n\\n  const paymentMaker = makeKind(paymentVOFactory);\\n\\n  const makePayment = () => paymentMaker(brand);\\n\\n  return makePayment;};exports.makePaymentMaker = makePaymentMaker;\",\n  \"ertp/src/issuer.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var assert = require('../../assert/src/assert.js');var noShim = require('../../eventual-send/src/no-shim.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');var marshal = require('../../marshal/src/marshal.js');require('../../marshal/index.js');var deprecatedAmountMath = require('./deprecatedAmountMath.js');var amountMath = require('./amountMath.js');var _default = require('../../store/src/external/default.js');require('../../store/src/index.js');var notifier = require('../../notifier/src/notifier.js');require('../../notifier/src/index.js');var interfaces = require('./interfaces.js');var displayInfo = require('./displayInfo.js');var\\npayment = require('./payment.js'); /* @ts-check*/ /* global makeWeakStore */\\n\\n'use jessie';\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * @type {MakeIssuerKit}\\n */\\nfunction makeIssuerKit(\\nallegedName,\\namountMathKind = amountMath.MathKind.NAT,\\ndisplayInfo$1 = undefined)\\n{\\n  assert.assert.typeof(allegedName, 'string');\\n  displayInfo$1 = displayInfo.coerceDisplayInfo(displayInfo$1);\\n\\n  const brand = marshal.Far(interfaces.makeFarName(allegedName, interfaces.ERTPKind.BRAND), {\\n    isMyIssuer: allegedIssuerP => {\\n      return noShim.E.when(allegedIssuerP, allegedIssuer => {\\n        /* eslint-disable-next-line no-use-before-define*/\\n        return allegedIssuer === issuer;});},\\n\\n\\n    getAllegedName: () => allegedName,\\n\\n    /* Give information to UI on how to display the amount.*/\\n    getDisplayInfo: () => displayInfo$1 });\\n\\n\\n  /** @type {(left: Amount, right: Amount) => Amount } */\\n  const add = (left, right) => amountMath.amountMath.add(left, right, brand);\\n  /** @type {(left: Amount, right: Amount) => Amount } */\\n  const subtract = (left, right) => amountMath.amountMath.subtract(left, right, brand);\\n  /** @type {(allegedAmount: Amount) => Amount} */\\n  const coerce = allegedAmount => amountMath.amountMath.coerce(allegedAmount, brand);\\n  /** @type {(left: Amount, right: Amount) => boolean } */\\n  const isEqual = (left, right) => amountMath.amountMath.isEqual(left, right, brand);\\n\\n  /** @type {Amount} */\\n  const emptyAmount = amountMath.amountMath.makeEmpty(brand, amountMathKind);\\n\\n  const makePayment = payment.makePaymentMaker(allegedName, brand);\\n\\n  /** @type {WeakStore<Payment, Amount>} */\\n  const paymentLedger = makeWeakStore('payment');\\n\\n  function assertKnownPayment(payment) {\\n    assert.assert(paymentLedger.has(payment), assert.details`payment not found for ${allegedName}`);}\\n\\n\\n  /* Methods like deposit() have an optional second parameter `amount`*/\\n  /* which, if present, is supposed to be equal to the balance of the*/\\n  /* payment. This helper function does that check.*/\\n  const assertAmountEqual = (paymentBalance, amount) => {\\n    if (amount !== undefined) {\\n      assert.assert(\\n      isEqual(amount, paymentBalance),\\n      assert.details`payment balance ${paymentBalance} must equal amount ${amount}`);}};\\n\\n\\n\\n\\n  const { makeInstance: makeDepositFacet } = _default.makeExternalStore(\\n  'depositFacet',\\n  /**\\n   * @param {Purse} purse\\n   * @returns {DepositFacet}\\n   */\\n  (purse) =>\\n  marshal.Far(interfaces.makeFarName(allegedName, interfaces.ERTPKind.DEPOSIT_FACET), {\\n    receive: purse.deposit }));\\n\\n\\n\\n  const { makeInstance: makePurse } = _default.makeExternalStore('purse', () => {\\n    let currentBalance = emptyAmount;\\n    /** @type {NotifierRecord<Amount>} */\\n    const {\\n      notifier: balanceNotifier,\\n      updater: balanceUpdater } =\\n    notifier.makeNotifierKit(currentBalance);\\n\\n    /** @type {Purse} */\\n    const purse = marshal.Far(interfaces.makeFarName(allegedName, interfaces.ERTPKind.PURSE), {\\n      deposit: (srcPayment, optAmount = undefined) => {\\n        if (promiseKit.isPromise(srcPayment)) {\\n          throw TypeError(\\n          `deposit does not accept promises as first argument. Instead of passing the promise (deposit(paymentPromise)), consider unwrapping the promise first: paymentPromise.then(actualPayment => deposit(actualPayment))`);}\\n\\n\\n        assertKnownPayment(srcPayment);\\n        const srcPaymentBalance = paymentLedger.get(srcPayment);\\n        /* Note: this does not guarantee that optAmount itself is a valid stable amount*/\\n        assertAmountEqual(srcPaymentBalance, optAmount);\\n        const newPurseBalance = add(srcPaymentBalance, currentBalance);\\n        /* Commit point*/\\n        /* Move the assets in `srcPayment` into this purse, using up the*/\\n        /* source payment, such that total assets are conserved.*/\\n        paymentLedger.delete(srcPayment);\\n        currentBalance = newPurseBalance;\\n        balanceUpdater.updateState(currentBalance);\\n        return srcPaymentBalance;},\\n\\n      withdraw: amount => {\\n        amount = coerce(amount);\\n        const newPurseBalance = subtract(currentBalance, amount);\\n        const payment = makePayment();\\n        /* Commit point*/\\n        /* Move the withdrawn assets from this purse into a new payment*/\\n        /* which is returned. Total assets must remain conserved.*/\\n        currentBalance = newPurseBalance;\\n        balanceUpdater.updateState(currentBalance);\\n        paymentLedger.init(payment, amount);\\n        return payment;},\\n\\n      getCurrentAmount: () => currentBalance,\\n      getCurrentAmountNotifier: () => balanceNotifier,\\n      getAllegedBrand: () => brand,\\n      /* eslint-disable-next-line no-use-before-define*/\\n      getDepositFacet: () => depositFacet });\\n\\n\\n    const depositFacet = makeDepositFacet(purse);\\n    return purse;});\\n\\n\\n  /**\\n   * Reallocate assets from the `payments` passed in to new payments\\n   * created and returned, with balances from `newPaymentBalances`.\\n   * Enforces that total assets are conserved.\\n   *\\n   * Note that this is not the only operation that reallocates assets.\\n   * `purse.deposit` and `purse.withdraw` move assets between a purse and\\n   * a payment, and so must also enforce conservation there.\\n   *\\n   * @param {Payment[]} payments\\n   * @param {Amount[]} newPaymentBalances\\n   * @returns {Payment[]}\\n   */\\n  const reallocate = (payments, newPaymentBalances) => {\\n    /* There may be zero, one, or many payments as input to*/\\n    /* reallocate. We want to protect against someone passing in*/\\n    /* what appears to be multiple payments that turn out to actually*/\\n    /* be the same payment (an aliasing issue). The `combine` method*/\\n    /* legitimately needs to take in multiple payments, but we don't*/\\n    /* need to pay the costs of protecting against aliasing for the*/\\n    /* other uses.*/\\n\\n    if (payments.length > 1) {\\n      const antiAliasingStore = makeWeakStore('payment');\\n      payments.forEach(payment => {\\n        if (antiAliasingStore.has(payment)) {\\n          throw Error('same payment seen twice');}\\n\\n        antiAliasingStore.init(payment, undefined);});}\\n\\n\\n\\n    const total = payments.map(paymentLedger.get).reduce(add, emptyAmount);\\n\\n    const newTotal = newPaymentBalances.reduce(add, emptyAmount);\\n\\n    /* Invariant check*/\\n    assert.assert(isEqual(total, newTotal), 'rights were not conserved');\\n\\n    /* commit point*/\\n    payments.forEach(payment => paymentLedger.delete(payment));\\n\\n    const newPayments = newPaymentBalances.map(balance => {\\n      const newPayment = makePayment();\\n      paymentLedger.init(newPayment, balance);\\n      return newPayment;});\\n\\n\\n    return harden(newPayments);};\\n\\n\\n  /** @type {Issuer} */\\n  const issuer = marshal.Far(interfaces.makeFarName(allegedName, interfaces.ERTPKind.ISSUER), {\\n    getBrand: () => brand,\\n    getAllegedName: () => allegedName,\\n    getAmountMathKind: () => amountMathKind,\\n    makeEmptyPurse: makePurse,\\n\\n    isLive: paymentP => {\\n      return noShim.E.when(paymentP, payment => {\\n        return paymentLedger.has(payment);});},\\n\\n\\n    getAmountOf: paymentP => {\\n      return noShim.E.when(paymentP, payment => {\\n        assertKnownPayment(payment);\\n        return paymentLedger.get(payment);});},\\n\\n\\n\\n    burn: (paymentP, optAmount = undefined) => {\\n      return noShim.E.when(paymentP, payment => {\\n        assertKnownPayment(payment);\\n        const paymentBalance = paymentLedger.get(payment);\\n        assertAmountEqual(paymentBalance, optAmount);\\n        /* Commit point.*/\\n        paymentLedger.delete(payment);\\n        return paymentBalance;});},\\n\\n\\n    claim: (paymentP, optAmount = undefined) => {\\n      return noShim.E.when(paymentP, srcPayment => {\\n        assertKnownPayment(srcPayment);\\n        const srcPaymentBalance = paymentLedger.get(srcPayment);\\n        assertAmountEqual(srcPaymentBalance, optAmount);\\n        /* Commit point.*/\\n        const [payment] = reallocate([srcPayment], [srcPaymentBalance]);\\n        return payment;});},\\n\\n\\n    /* Payments in `fromPaymentsPArray` must be distinct. Alias*/\\n    /* checking is delegated to the `reallocate` function.*/\\n    combine: (fromPaymentsPArray, optTotalAmount = undefined) => {\\n      return Promise.all(fromPaymentsPArray).then(fromPaymentsArray => {\\n        fromPaymentsArray.every(assertKnownPayment);\\n        const totalPaymentsBalance = fromPaymentsArray.\\n        map(paymentLedger.get).\\n        reduce(add, emptyAmount);\\n        assertAmountEqual(totalPaymentsBalance, optTotalAmount);\\n        /* Commit point.*/\\n        const [payment] = reallocate(fromPaymentsArray, [totalPaymentsBalance]);\\n        return payment;});},\\n\\n\\n    /* payment to two payments, A and B*/\\n    split: (paymentP, paymentAmountA) => {\\n      return noShim.E.when(paymentP, srcPayment => {\\n        paymentAmountA = coerce(paymentAmountA);\\n        assertKnownPayment(srcPayment);\\n        const srcPaymentBalance = paymentLedger.get(srcPayment);\\n        const paymentAmountB = subtract(srcPaymentBalance, paymentAmountA);\\n        /* Commit point*/\\n        const newPayments = reallocate(\\n        [srcPayment],\\n        [paymentAmountA, paymentAmountB]);\\n\\n        return newPayments;});},\\n\\n\\n    splitMany: (paymentP, amounts) => {\\n      return noShim.E.when(paymentP, srcPayment => {\\n        assertKnownPayment(srcPayment);\\n        amounts = amounts.map(coerce);\\n        /* Commit point*/\\n        const newPayments = reallocate([srcPayment], amounts);\\n        return newPayments;});} });\\n\\n\\n\\n\\n  /** @type {Mint} */\\n  const mint = marshal.Far(interfaces.makeFarName(allegedName, interfaces.ERTPKind.MINT), {\\n    getIssuer: () => issuer,\\n    mintPayment: newAmount => {\\n      newAmount = coerce(newAmount);\\n      const payment = makePayment();\\n      paymentLedger.init(payment, newAmount);\\n      return payment;} });\\n\\n\\n\\n  return harden({\\n    mint,\\n    issuer,\\n    amountMath: deprecatedAmountMath.makeAmountMath(brand, amountMathKind),\\n    brand,\\n    amountMathKind });}\\n\\n\\n\\nharden(makeIssuerKit);exports.makeIssuerKit = makeIssuerKit;\",\n  \"ertp/src/localAmountMath.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var noShim = require('../../eventual-send/src/no-shim.js');var\\n\\n\\ndeprecatedAmountMath = require('./deprecatedAmountMath.js'); /**\\n * @deprecated Use `amountMath` as exported by `@agoric/ertp` directly\\n * @param {ERef<Issuer>} issuer\\n * @returns {Promise<DeprecatedAmountMath>}\\n */\\nconst makeLocalAmountMath = async issuer => {\\n  const [brand, amountMathKind] = await Promise.all([\\n  noShim.E(issuer).getBrand(),\\n  noShim.E(issuer).getAmountMathKind()]);\\n\\n  return deprecatedAmountMath.makeAmountMath(brand, amountMathKind);};\\n\\n\\nharden(makeLocalAmountMath);exports.makeLocalAmountMath = makeLocalAmountMath;\",\n  \"ertp/src/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var deprecatedAmountMath = require('./deprecatedAmountMath.js');var typeGuards = require('./typeGuards.js');var amountMath = require('./amountMath.js');var issuer = require('./issuer.js');var localAmountMath = require('./localAmountMath.js'); /* @ts-check*/exports.makeAmountMath = deprecatedAmountMath.makeAmountMath;exports.isNatValue = typeGuards.isNatValue;exports.isSetValue = typeGuards.isSetValue;exports.MathKind = amountMath.MathKind;exports.amountMath = amountMath.amountMath;exports.getMathKind = amountMath.getMathKind;exports.makeIssuerKit = issuer.makeIssuerKit;exports.makeLocalAmountMath = localAmountMath.makeLocalAmountMath;\",\n  \"zoe/src/contractSupport/priceAuthority.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../exported.js');var assert = require('../../../assert/src/assert.js');var noShim = require('../../../eventual-send/src/no-shim.js');var promiseKit = require('../../../promise-kit/src/promiseKit.js');var marshal = require('../../../marshal/src/marshal.js');require('../../../marshal/index.js');var amountMath = require('../../../ertp/src/amountMath.js');\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('../../../ertp/src/index.js'); /* @ts-check*/ /**\\n * @callback CompareAmount\\n * @param {Amount} amount\\n * @param {Amount} amountLimit\\n * @returns {boolean}\\n */ /** @type {CompareAmount} */const isLT = (amountOut, amountLimit) => !amountMath.amountMath.isGTE(amountOut, amountLimit); /** @type {CompareAmount} */const isLTE = (amount, amountLimit) => amountMath.amountMath.isGTE(amountLimit, amount);\\n\\n/** @type {CompareAmount} */\\nconst isGTE = (amount, amountLimit) => amountMath.amountMath.isGTE(amount, amountLimit);\\n\\n/** @type {CompareAmount} */\\nconst isGT = (amount, amountLimit) => !amountMath.amountMath.isGTE(amountLimit, amount);\\n\\n/**\\n * @typedef {Object} OnewayPriceAuthorityOptions\\n * @property {Issuer} quoteIssuer\\n * @property {Notifier<PriceQuote>} notifier\\n * @property {TimerService} timer\\n * @property {PriceQuoteCreate} createQuote\\n * @property {Brand} actualBrandIn\\n * @property {Brand} actualBrandOut\\n */\\n\\n/**\\n * @callback Trigger\\n * @param {PriceQuoteCreate} createInstantQuote\\n * @returns {Promise<void>}\\n */\\n\\n/**\\n * @param {OnewayPriceAuthorityOptions} opts\\n * @returns {PriceAuthorityKit}\\n */\\nfunction makeOnewayPriceAuthorityKit(opts) {\\n  const {\\n    timer,\\n    createQuote,\\n    actualBrandIn,\\n    actualBrandOut,\\n    quoteIssuer,\\n    notifier } =\\n  opts;\\n\\n  let haveFirstQuote = false;\\n  notifier.getUpdateSince().then(_ => haveFirstQuote = true);\\n\\n  /** @type {Set<Trigger>} */\\n  const triggers = new Set();\\n\\n  /**\\n   * @param {PriceQuoteCreate} triggerCreateQuote\\n   * @returns {Promise<void>}\\n   */\\n  const fireTriggers = async triggerCreateQuote => {\\n    if (!haveFirstQuote) {\\n      return;}\\n\\n    await Promise.all(\\n    [...triggers].map(trigger => trigger(triggerCreateQuote)));};\\n\\n\\n\\n  /**\\n   * Create a quoteWhen* function.\\n   *\\n   * @param {CompareAmount} compareAmount\\n   */\\n  const makeQuoteWhenOut = (compareAmount) =>\\n  /**\\n   * Return a quote when triggerWhen is true of the arguments.\\n   *\\n   * @param {Amount} amountIn the input value to the calcAmountTrigger\\n   * @param {Amount} amountOutLimit the value to compare with the output\\n   * of calcAmountTrigger\\n   */\\n  async function quoteWhenOutTrigger(amountIn, amountOutLimit) {\\n    amountMath.amountMath.coerce(amountIn, actualBrandIn);\\n    amountMath.amountMath.coerce(amountOutLimit, actualBrandOut);\\n\\n    /** @type {PromiseRecord<PriceQuote>} */\\n    const triggerPK = promiseKit.makePromiseKit();\\n\\n    /** @type {PriceQuoteTrigger} */\\n    const trigger = async createInstantQuote => {\\n      try {\\n        const quoteP = createInstantQuote(calcAmountOut => {\\n          if (!triggers.has(trigger)) {\\n            /* Already fired.*/\\n            return undefined;}\\n\\n          const amountOut = calcAmountOut(amountIn);\\n\\n          if (!compareAmount(amountOut, amountOutLimit)) {\\n            /* Don't fire the trigger yet.*/\\n            return undefined;}\\n\\n\\n          /* Generate the quote.*/\\n          return { amountIn, amountOut };});\\n\\n\\n        if (!quoteP) {\\n          /* We shouldn't resolve yet.*/\\n          return;}\\n\\n\\n        triggers.delete(trigger);\\n        triggerPK.resolve(quoteP);}\\n      catch (e) {\\n        /* Trigger failed, so reject and drop.*/\\n        triggerPK.reject(e);\\n        triggers.delete(trigger);}};\\n\\n\\n\\n    triggers.add(trigger);\\n\\n    /* Fire now, just in case.*/\\n    await trigger(createQuote);\\n\\n    return triggerPK.promise;};\\n\\n\\n  /**\\n   * Ensure that the brandIn/brandOut pair is supported.\\n   *\\n   * @param {Brand} brandIn\\n   * @param {Brand} brandOut\\n   */\\n  const assertBrands = (brandIn, brandOut) => {\\n    assert.assert.equal(\\n    brandIn,\\n    actualBrandIn,\\n    assert.details`Desired brandIn ${brandIn} must match ${actualBrandIn}`);\\n\\n    assert.assert.equal(\\n    brandOut,\\n    actualBrandOut,\\n    assert.details`Desired brandOut ${brandOut} must match ${actualBrandOut}`);};\\n\\n\\n\\n  /** @type {PriceAuthority} */\\n  const priceAuthority = marshal.Far('PriceAuthority', {\\n    getQuoteIssuer(brandIn, brandOut) {\\n      assertBrands(brandIn, brandOut);\\n      return quoteIssuer;},\\n\\n    getTimerService(brandIn, brandOut) {\\n      assertBrands(brandIn, brandOut);\\n      return timer;},\\n\\n    getPriceNotifier(brandIn, brandOut) {\\n      assertBrands(brandIn, brandOut);\\n      return notifier;},\\n\\n    async quoteGiven(amountIn, brandOut) {\\n      amountMath.amountMath.coerce(amountIn, actualBrandIn);\\n      assertBrands(amountIn.brand, brandOut);\\n\\n      await notifier.getUpdateSince();\\n      return createQuote(calcAmountOut => ({\\n        amountIn,\\n        amountOut: calcAmountOut(amountIn) }));},\\n\\n\\n    async quoteWanted(brandIn, amountOut) {\\n      amountMath.amountMath.coerce(amountOut, actualBrandOut);\\n      assertBrands(brandIn, amountOut.brand);\\n\\n      await notifier.getUpdateSince();\\n      return createQuote((calcAmountOut, calcAmountIn) => {\\n        /* We need to determine an amountIn that guarantees at least the amountOut.*/\\n        const amountIn = calcAmountIn(amountOut);\\n        const actualAmountOut = calcAmountOut(amountIn);\\n\\n        assert.assert(\\n        amountMath.amountMath.isGTE(actualAmountOut, amountOut),\\n        assert.details`Calculation of ${actualAmountOut} didn't cover expected ${amountOut}`);\\n\\n        return { amountIn, amountOut };});},\\n\\n\\n    async quoteAtTime(deadline, amountIn, brandOut) {\\n      assert.assert.typeof(deadline, 'bigint');\\n      amountMath.amountMath.coerce(amountIn, actualBrandIn);\\n      assertBrands(amountIn.brand, brandOut);\\n\\n      await notifier.getUpdateSince();\\n      const quotePK = promiseKit.makePromiseKit();\\n      await noShim.E(timer).setWakeup(\\n      deadline,\\n      marshal.Far('wakeObj', {\\n        async wake(timestamp) {\\n          try {\\n            const quoteP = createQuote(calcAmountOut => ({\\n              amountIn,\\n              amountOut: calcAmountOut(amountIn),\\n              timestamp }));\\n\\n\\n            /* We don't wait for the quote to be authenticated; resolve*/\\n            /* immediately.*/\\n            quotePK.resolve(quoteP);\\n            await quotePK.promise;}\\n          catch (e) {\\n            quotePK.reject(e);}} }));\\n\\n\\n\\n\\n\\n      /* Wait until the wakeup passes.*/\\n      return quotePK.promise;},\\n\\n    quoteWhenLT: makeQuoteWhenOut(isLT),\\n    quoteWhenLTE: makeQuoteWhenOut(isLTE),\\n    quoteWhenGTE: makeQuoteWhenOut(isGTE),\\n    quoteWhenGT: makeQuoteWhenOut(isGT) });\\n\\n\\n  return { priceAuthority, adminFacet: { fireTriggers } };}exports.makeOnewayPriceAuthorityKit = makeOnewayPriceAuthorityKit;\",\n  \"zoe/src/contractSupport/priceQuote.js\": \"'use strict';\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* @ts-check*/ /* PriceAuthorities return quotes as a pair of an amount and a payment, both*/ /* with the same value. The underlying amount wraps amountIn, amountOut, timer*/ /* and timestamp. The payment is issued by the quoteIssuer to support veracity*/ /* checking. These helpers make it easier to extract the components of the Quote*/\\n\\nconst getAmountIn = quote => quote.quoteAmount.value[0].amountIn;\\nconst getAmountOut = quote => quote.quoteAmount.value[0].amountOut;\\nconst getTimestamp = quote => quote.quoteAmount.value[0].timestamp;\\nconst getQuoteValues = quote => quote.quoteAmount.value[0];exports.getAmountIn = getAmountIn;exports.getAmountOut = getAmountOut;exports.getQuoteValues = getQuoteValues;exports.getTimestamp = getTimestamp;\",\n  \"zoe/src/contractSupport/stateMachine.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\n\\n\\nassert = require('../../../assert/src/assert.js'); /* @ts-check*/ /* allowedTransitions is an array of arrays which gets turned into a\\n * map. The map maps string states to an array of potential next\\n * states. For example,\\n * const allowedTransitions = [\\n ['open', ['closed']],\\n ['closed', []],\\n * ];\\n*/\\nconst makeStateMachine = (initialState, allowedTransitionsArray) => {\\n  let state = initialState;\\n  const allowedTransitions = new Map(allowedTransitionsArray);\\n  return harden({\\n    canTransitionTo: (nextState) =>\\n    allowedTransitions.get(state).includes(nextState),\\n    transitionTo: nextState => {\\n      assert.assert(allowedTransitions.get(state).includes(nextState));\\n      state = nextState;},\\n\\n    getStatus: _ => state });};\\n\\n\\nharden(makeStateMachine);exports.makeStateMachine = makeStateMachine;\",\n  \"zoe/src/contractSupport/statistics.js\": \"'use strict';\\n\\n\\n\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /**\\n * @template T\\n * @typedef {Object} TypedMath\\n * @property {(a: T, b: T) => T} add\\n * @property {(a: T, b: T) => T} divide\\n * @property {(a: T, b: T) => boolean} isGTE\\n */ /**\\n * Calculate the median of a set of samples\\n *\\n * @template T\\n * @param {Array<T>} samples the input measurements\\n * @param {TypedMath<T>} math\\n * @returns {T=} the median (undefined if no samples)\\n */const calculateMedian = (samples, math) => {const sorted = samples.sort((a, b) => {if (!math.isGTE(a, b)) {return -1;} else if (!math.isGTE(b, a)) {return 1;}\\n\\n    return 0;});\\n\\n\\n  if (sorted.length === 0) {\\n    /* No valid samples, don't report anything.*/\\n    return undefined;}\\n\\n\\n  if (sorted.length % 2 !== 0) {\\n    /* Odd length, just pick the middle element.*/\\n    return sorted[(sorted.length - 1) / 2];}\\n\\n\\n  /* Even length, take the mean of the two middle values.*/\\n  const secondIndex = sorted.length / 2;\\n  const sum = math.add(sorted[secondIndex - 1], sorted[secondIndex]);\\n  return math.divide(sum, 2);};exports.calculateMedian = calculateMedian;\",\n  \"zoe/src/contractFacet/offerSafety.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var amountMath = require('../../../ertp/src/amountMath.js');\\n\\n\\n\\nrequire('../../../ertp/src/index.js'); /* @ts-check*/ /**\\n * Helper to perform satisfiesWant and satisfiesGive. Is\\n * allocationAmount greater than or equal to requiredAmount for every\\n * keyword of giveOrWant?\\n *\\n * @param {AmountKeywordRecord} giveOrWant\\n * @param {AmountKeywordRecord} allocation\\n */\\nconst satisfiesInternal = (giveOrWant = {}, allocation) => {\\n  const isGTEByKeyword = ([keyword, requiredAmount]) => {\\n    /* If there is no allocation for a keyword, we know the giveOrWant*/\\n    /* is not satisfied without checking further.*/\\n    if (allocation[keyword] === undefined) {\\n      return false;}\\n\\n    const allocationAmount = allocation[keyword];\\n    return amountMath.amountMath.isGTE(allocationAmount, requiredAmount);};\\n\\n  return Object.entries(giveOrWant).every(isGTEByKeyword);};\\n\\n\\n/**\\n * For this allocation to satisfy what the user wanted, their\\n * allocated amounts must be greater than or equal to proposal.want.\\n *\\n * @param {ProposalRecord} proposal - the rules that accompanied the\\n * escrow of payments that dictate what the user expected to get back\\n * from Zoe. A proposal is a record with keys `give`, `want`, and\\n * `exit`. `give` and `want` are records with keywords as keys and\\n * amounts as values. The proposal is a user's understanding of the\\n * contract that they are entering when they make an offer.\\n * @param {AmountKeywordRecord} allocation - a record with keywords\\n * as keys and amounts as values. These amounts are the reallocation\\n * to be given to a user.\\n */\\nconst satisfiesWant = (proposal, allocation) =>\\nsatisfiesInternal(proposal.want, allocation);\\n\\n/**\\n * For this allocation to count as a full refund, the allocated\\n * amounts must be greater than or equal to what was originally\\n * offered (proposal.give).\\n *\\n * @param  {ProposalRecord} proposal - the rules that accompanied the\\n * escrow of payments that dictate what the user expected to get back\\n * from Zoe. A proposal is a record with keys `give`, `want`, and\\n * `exit`. `give` and `want` are records with keywords as keys and\\n * amounts as values. The proposal is a user's understanding of the\\n * contract that they are entering when they make an offer.\\n * @param  {AmountKeywordRecord} allocation - a record with keywords\\n * as keys and amounts as values. These amounts are the reallocation\\n * to be given to a user.\\n */\\nconst satisfiesGive = (proposal, allocation) =>\\nsatisfiesInternal(proposal.give, allocation);\\n\\n/**\\n * `isOfferSafe` checks offer safety for a single offer.\\n *\\n * Note: This implementation checks whether we fully satisfy\\n * `proposal.give` (giving a refund) or whether we fully satisfy\\n * `proposal.want`. Both can be fully satisfied.\\n *\\n * @param  {ProposalRecord} proposal - the rules that accompanied the\\n * escrow of payments that dictate what the user expected to get back\\n * from Zoe. A proposal is a record with keys `give`, `want`, and\\n * `exit`. `give` and `want` are records with keywords as keys and\\n * amounts as values. The proposal is a user's understanding of the\\n * contract that they are entering when they make an offer.\\n * @param  {AmountKeywordRecord} allocation - a record with keywords\\n * as keys and amounts as values. These amounts are the reallocation\\n * to be given to a user.\\n */\\nfunction isOfferSafe(proposal, allocation) {\\n  return (\\n    satisfiesGive(proposal, allocation) || satisfiesWant(proposal, allocation));}exports.isOfferSafe = isOfferSafe;exports.satisfiesWant = satisfiesWant;\",\n  \"zoe/src/objArrayConversion.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\n\\n\\n\\n\\n\\n\\n\\nassert = require('../../assert/src/assert.js'); /* @ts-check*/ /**\\n * @typedef {bigint|boolean|null|number|string|symbol|undefined} Primitive\\n * @typedef {string|number|symbol} PropertyName\\n */ /**\\n * @template T\\n * @template {PropertyName} U\\n * @param {T[]} array\\n * @param {U[]} keys\\n */const arrayToObj = (array, keys) => {assert.assert(array.length === keys.length,\\n  assert.details`array and keys must be of equal length`);\\n\\n  const obj =\\n  /** @type {Record<U, T>} */\\n  {};\\n  keys.forEach((key, i) => obj[key] = array[i]);\\n  return harden(obj);};\\n\\n\\n/**\\n * Assert all values from `part` appear in `whole`.\\n *\\n * @param {string[]} whole\\n * @param {string[]} part\\n */\\nconst assertSubset = (whole, part) => {\\n  part.forEach(key => {\\n    assert.assert.typeof(key, 'string');\\n    assert.assert(\\n    whole.includes(key),\\n    assert.details`key ${assert.quote(key)} was not one of the expected keys ${assert.quote(whole)}`);});};\\n\\n\\n\\n\\n/**\\n * By analogy with how `Array.prototype.map` will map the elements of\\n * an array to transformed elements of an array of the same shape,\\n * `objectMap` will do likewise for the string-named own enumerable\\n * properties of an object.\\n *\\n * `objectMap` is a convenience over\\n *    * using `Object.entries` to convert these property values into an array\\n *      of `[key, value]` pairs,\\n *    * a normal array map with this list and the provided callback, hopefully\\n *      producing a similar array of `[key, mappedValue]` pairs,\\n *    * using `Object.fromEntries` to put it all back together in a new\\n *      object whose own properties are according to that list of\\n *      mapped pairs.\\n *\\n * Some edge cases to be aware of\\n *    * If any of the original properties were accessors, `Object.entries`\\n *      will cause its `getter` to be called and will use the resulting\\n *      value.\\n *    * No matter whether the original property was an accessor, writable,\\n *      or configurable, all the properties of the returned object will be\\n *      writable, configurable, data properties.\\n *    * No matter what the original object may have inherited from, and\\n *      no matter whether it was a special kind of object such as an array,\\n *      the returned object will always be a plain object inheriting directly\\n *      from `Object.prototype` and whose state is only these new mapped\\n *      own properties.\\n *    * The caller-provided mapping function can map the entry to a new entry\\n *      with a different key, in which case the new object will have those\\n *      keys as its property names rather than the original's.\\n *\\n * Typical usage will be to apply `objectMap` to a pass-by-copy record, i.e.,\\n * and object for which `passStyleOf(original) === 'copyRecord'`. For these,\\n * none of these edge cases arise. If the mapping does not introduce\\n * symbol-named properties, then the result, once hardened, will also be a\\n * pass-by-copy record.\\n *\\n * @template T, U\\n * @template {keyof T} K\\n * @param {{ [K2 in keyof T]: T[K2] }} original\\n * @param {(pair: [K, T[K]]) => [K, U]} mapPairFn\\n * @returns {Record<K, U>}\\n */\\nconst objectMap = (original, mapPairFn) => {\\n  const ents = /** @type {[K, T[K]][]} */Object.entries(original);\\n  const mapEnts = ents.map(ent => mapPairFn(ent));\\n  return (/** @type {Record<K, U>} */harden(Object.fromEntries(mapEnts)));};exports.arrayToObj = arrayToObj;exports.assertSubset = assertSubset;exports.objectMap = objectMap;\",\n  \"zoe/src/contractSupport/zoeHelpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../exported.js');var assert = require('../../../assert/src/assert.js');var noShim = require('../../../eventual-send/src/no-shim.js');var promiseKit = require('../../../promise-kit/src/promiseKit.js');var sameStructure = require('../../../same-structure/src/sameStructure.js');require('../../../same-structure/index.js');var amountMath = require('../../../ertp/src/amountMath.js');require('../../../ertp/src/index.js');var offerSafety = require('../contractFacet/offerSafety.js');var objArrayConversion = require('../objArrayConversion.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst defaultAcceptanceMsg = `The offer has been accepted. Once the contract has been completed, please check your payout`;\\n\\nconst getKeysSorted = (obj) =>\\nharden(Object.getOwnPropertyNames(obj || {}).sort());\\n\\n/**\\n * Given toGains (an AmountKeywordRecord), and allocations (a pair,\\n * 'to' and 'from', of Allocations), all the entries in\\n * toGains will be added to 'to'. If fromLosses is defined, all the\\n * entries in fromLosses are subtracted from 'from'. (If fromLosses\\n * is not defined, toGains is subtracted from 'from'.)\\n *\\n * @param {FromToAllocations} allocations - the 'to' and 'from'\\n * allocations\\n * @param {AmountKeywordRecord} toGains - what should be gained in\\n * the 'to' allocation\\n * @param {AmountKeywordRecord} [fromLosses=toGains] - what should be lost in\\n * the 'from' allocation. If not defined, fromLosses is equal to\\n * toGains. Note that the total amounts should always be equal; it\\n * is the keywords that might be different.\\n * @returns {FromToAllocations} allocations - new allocations\\n *\\n * @typedef FromToAllocations\\n * @property {Allocation} from\\n * @property {Allocation} to\\n */\\nconst calcNewAllocations = (allocations, toGains, fromLosses = toGains) => {\\n  const subtract = (amount, amountToSubtract) => {\\n    if (amountToSubtract !== undefined) {\\n      return amountMath.amountMath.subtract(amount, amountToSubtract);}\\n\\n    return amount;};\\n\\n\\n  const add = (amount, amountToAdd) => {\\n    if (amount && amountToAdd) {\\n      return amountMath.amountMath.add(amount, amountToAdd);}\\n\\n    return amount || amountToAdd;};\\n\\n\\n  const newFromAllocation = objArrayConversion.objectMap(\\n  allocations.from,\\n  ([keyword, allocAmount]) => [\\n  keyword,\\n  subtract(allocAmount, fromLosses[keyword])]);\\n\\n\\n\\n  const allToKeywords = Object.keys({ ...allocations.to, ...toGains });\\n\\n  const newToAllocation = Object.fromEntries(\\n  allToKeywords.map(keyword => [\\n  keyword,\\n  add(allocations.to[keyword], toGains[keyword])]));\\n\\n\\n\\n  return harden({\\n    from: newFromAllocation,\\n    to: newToAllocation });};\\n\\n\\n\\nconst assertIssuerKeywords = (zcf, expected) => {\\n  const { issuers } = zcf.getTerms();\\n  const actual = getKeysSorted(issuers);\\n  expected = [...expected]; /* in case hardened*/\\n  expected.sort();\\n  assert.assert(\\n  sameStructure.sameStructure(actual, harden(expected)),\\n  assert.details`keywords: ${actual} were not as expected: ${expected}`);};\\n\\n\\n\\n/**\\n * @typedef {Object} ZcfSeatPartial\\n * @property {() => ProposalRecord} getProposal\\n * @property {() => Allocation} getCurrentAllocation\\n */\\n\\n/**\\n * Check whether an update to currentAllocation satisfies\\n * proposal.want. Note that this is half of the offer safety\\n * check; whether the allocation constitutes a refund is not\\n * checked. The update is merged with currentAllocation\\n * (update's values prevailing if the keywords are the same)\\n * to produce the newAllocation.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZcfSeatPartial} seat\\n * @param {AmountKeywordRecord} update\\n * @returns {boolean}\\n */\\nconst satisfies = (zcf, seat, update) => {\\n  const currentAllocation = seat.getCurrentAllocation();\\n  const newAllocation = { ...currentAllocation, ...update };\\n  const proposal = seat.getProposal();\\n  return offerSafety.satisfiesWant(proposal, newAllocation);};\\n\\n\\n/** @type {Trade} */\\nconst trade = (\\nzcf,\\nleft,\\nright,\\nleftHasExitedMsg = 'the left seat has exited',\\nrightHasExitedMsg = 'the right seat has exited') =>\\n{\\n  assert.assert(left.seat !== right.seat, assert.details`a seat cannot trade with itself`);\\n  assert.assert(!left.seat.hasExited(), leftHasExitedMsg);\\n  assert.assert(!right.seat.hasExited(), rightHasExitedMsg);\\n  let leftAllocation = left.seat.getCurrentAllocation();\\n  let rightAllocation = right.seat.getCurrentAllocation();\\n  try {\\n    /* for all the keywords and amounts in left.gains, transfer from*/\\n    /* right to left*/\\n    ({ from: rightAllocation, to: leftAllocation } = calcNewAllocations(\\n    { from: rightAllocation, to: leftAllocation },\\n    left.gains,\\n    right.losses));\\n\\n    /* For all the keywords and amounts in right.gains, transfer from*/\\n    /* left to right*/\\n    ({ from: leftAllocation, to: rightAllocation } = calcNewAllocations(\\n    { from: leftAllocation, to: rightAllocation },\\n    right.gains,\\n    left.losses));}\\n\\n  catch (err) {\\n    const newErr = new Error(\\n    `The trade between left ${left} and right ${right} failed.`);\\n\\n    assert.assert.note(newErr, assert.details`due to ${err}`);\\n    throw newErr;}\\n\\n\\n  /* Check whether reallocate would error before calling. If*/\\n  /* it would error, log information and throw.*/\\n  const offerSafeForLeft = left.seat.isOfferSafe(leftAllocation);\\n  const offerSafeForRight = right.seat.isOfferSafe(rightAllocation);\\n  if (!(offerSafeForLeft && offerSafeForRight)) {\\n    console.log(`currentLeftAllocation`, left.seat.getCurrentAllocation());\\n    console.log(`currentRightAllocation`, right.seat.getCurrentAllocation());\\n    console.log(`proposed left reallocation`, leftAllocation);\\n    console.log(`proposed right reallocation`, rightAllocation);\\n    /* show the constraints*/\\n    console.log(`left want`, left.seat.getProposal().want);\\n    console.log(`right want`, right.seat.getProposal().want);\\n\\n    if (!offerSafeForLeft) {\\n      console.log(`offer not safe for left`);}\\n\\n    if (!offerSafeForRight) {\\n      console.log(`offer not safe for right`);}\\n\\n    throw new Error(\\n    `The trade between left ${left} and right ${right} failed offer safety. Please check the log for more information`);}\\n\\n\\n\\n  try {\\n    zcf.reallocate(\\n    left.seat.stage(leftAllocation),\\n    right.seat.stage(rightAllocation));}\\n\\n  catch (err) {\\n    const newErr = Error(`The reallocation failed to conserve rights.`);\\n    assert.assert.note(newErr, assert.details`due to ${err}`);\\n    throw newErr;}};\\n\\n\\n\\n/** @type {Swap} */\\nconst swap = (\\nzcf,\\nleftSeat,\\nrightSeat,\\nleftHasExitedMsg = 'the left seat in swap() has exited',\\nrightHasExitedMsg = 'the right seat in swap() has exited') =>\\n{\\n  try {\\n    trade(\\n    zcf,\\n    {\\n      seat: leftSeat,\\n      gains: leftSeat.getProposal().want },\\n\\n    {\\n      seat: rightSeat,\\n      gains: rightSeat.getProposal().want },\\n\\n    leftHasExitedMsg,\\n    rightHasExitedMsg);}\\n\\n  catch (err) {\\n    leftSeat.fail(err);\\n    rightSeat.fail(err);\\n    throw err;}\\n\\n\\n  leftSeat.exit();\\n  rightSeat.exit();\\n  return defaultAcceptanceMsg;};\\n\\n\\n/**\\n * @type {Swap}\\n * Swap such that both seats gain what they want and lose everything\\n * that they gave. Only good for exact and entire swaps where each\\n * seat wants everything that the other seat has. The benefit of using\\n * this method is that the keywords of each seat do not matter.\\n */\\nconst swapExact = (\\nzcf,\\nleftSeat,\\nrightSeat,\\nleftHasExitedMsg = 'the left seat in swapExact() has exited',\\nrightHasExitedMsg = 'the right seat in swapExact() has exited') =>\\n{\\n  try {\\n    trade(\\n    zcf,\\n    {\\n      seat: leftSeat,\\n      gains: leftSeat.getProposal().want,\\n      losses: leftSeat.getProposal().give },\\n\\n    {\\n      seat: rightSeat,\\n      gains: rightSeat.getProposal().want,\\n      losses: rightSeat.getProposal().give },\\n\\n    leftHasExitedMsg,\\n    rightHasExitedMsg);}\\n\\n  catch (err) {\\n    leftSeat.fail(err);\\n    rightSeat.fail(err);\\n    throw err;}\\n\\n\\n  leftSeat.exit();\\n  rightSeat.exit();\\n  return defaultAcceptanceMsg;};\\n\\n\\n/**\\n * @typedef ExpectedRecord\\n * @property {Record<Keyword, null>} [want]\\n * @property {Record<Keyword, null>} [give]\\n * @property {Partial<Record<keyof ProposalRecord['exit'], null>>} [exit]\\n */\\n\\n/**\\n * Check the seat's proposal against an `expected` record that says\\n * what shape of proposal is acceptable.\\n *\\n * This ExpectedRecord is like a Proposal, but the amounts in 'want'\\n * and 'give' should be null; the exit clause should specify a rule with\\n * null contents. If the client submits an offer which does not match\\n * these expectations, the seat will be exited (and payments refunded).\\n *\\n * @param {ZCFSeat} seat\\n * @param {ExpectedRecord} expected\\n */\\nconst assertProposalShape = (seat, expected) => {\\n  assert.assert.typeof(expected, 'object');\\n  assert.assert(!Array.isArray(expected), assert.details`Expected must be an non-array object`);\\n  const assertValuesNull = e => {\\n    if (e !== undefined) {\\n      Object.values(e).forEach((value) =>\\n      assert.assert(\\n      value === null,\\n      assert.details`The value of the expected record must be null but was ${value}`));}};\\n\\n\\n\\n\\n\\n  /* Assert values of the expected record are all null. We do not*/\\n  /* check the values of the actual proposal.*/\\n  assertValuesNull(expected.give);\\n  assertValuesNull(expected.want);\\n  assertValuesNull(expected.exit);\\n\\n  const actual = seat.getProposal();\\n  const assertKeys = (a, e) => {\\n    if (e !== undefined) {\\n      assert.assert(\\n      sameStructure.sameStructure(getKeysSorted(a), getKeysSorted(e)),\\n      assert.details`actual ${a} did not match expected ${e}`);}};\\n\\n\\n\\n  assertKeys(actual.give, expected.give);\\n  assertKeys(actual.want, expected.want);\\n  assertKeys(actual.exit, expected.exit);};\\n\\n\\n/* Given a brand, assert that the issuer uses NAT amountMath. */\\nconst assertUsesNatMath = (zcf, brand) => {\\n  assert.assert(\\n  zcf.getMathKind(brand) === amountMath.MathKind.NAT,\\n  assert.details`issuer must use NAT amountMath`);};\\n\\n\\n\\nconst depositToSeatSuccessMsg = `Deposit and reallocation successful.`;\\n\\n/**\\n * Deposit payments such that their amounts are reallocated to a seat.\\n * The `amounts` and `payments` records must have corresponding\\n * keywords.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} recipientSeat\\n * @param {AmountKeywordRecord} amounts\\n * @param {PaymentPKeywordRecord} payments\\n * @returns {Promise<string>} `Deposit and reallocation successful.`\\n */\\n\\nasync function depositToSeat(zcf, recipientSeat, amounts, payments) {\\n  assert.assert(!recipientSeat.hasExited(), 'The recipientSeat cannot have exited.');\\n\\n  /* We will create a temporary offer to be able to escrow our payments*/\\n  /* with Zoe.*/\\n  function reallocateAfterDeposit(tempSeat) {\\n    /* After the assets are deposited, reallocate them onto the recipient seat and*/\\n    /* exit the temporary seat. Note that the offerResult is the return value of this*/\\n    /* function, so this synchronous trade must happen before the*/\\n    /* offerResult resolves.*/\\n    trade(\\n    zcf,\\n    { seat: tempSeat, gains: {} },\\n    { seat: recipientSeat, gains: amounts });\\n\\n    tempSeat.exit();\\n    return depositToSeatSuccessMsg;}\\n\\n  const invitation = zcf.makeInvitation(\\n  reallocateAfterDeposit,\\n  'temporary seat for deposit');\\n\\n  const proposal = harden({ give: amounts });\\n  harden(payments);\\n  /* To escrow the payment, we must get the Zoe Service facet and*/\\n  /* make an offer*/\\n  const zoe = zcf.getZoeService();\\n  const tempUserSeat = noShim.E(zoe).offer(invitation, proposal, payments);\\n  /* This will be a promise for the string: `Deposit and reallocation*/\\n  /* successful.` It will only fulfill after the assets have been*/\\n  /* successfully reallocated to the recipient seat.*/\\n  return noShim.E(tempUserSeat).getOfferResult();}\\n\\n\\n/**\\n * Withdraw payments from a seat. Note that withdrawing the amounts of\\n * the payments must not and cannot violate offer safety for the seat. The\\n * `amounts` and `payments` records must have corresponding keywords.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} seat\\n * @param {AmountKeywordRecord} amounts\\n * @returns {Promise<PaymentPKeywordRecord>}\\n */\\nasync function withdrawFromSeat(zcf, seat, amounts) {\\n  assert.assert(!seat.hasExited(), 'The seat cannot have exited.');\\n  const { zcfSeat: tempSeat, userSeat: tempUserSeatP } = zcf.makeEmptySeatKit();\\n  trade(zcf, { seat: tempSeat, gains: amounts }, { seat, gains: {} });\\n  tempSeat.exit();\\n  return noShim.E(tempUserSeatP).getPayouts();}\\n\\n\\n/**\\n * Save all of the issuers in an issuersKeywordRecord to ZCF, using\\n * the method `zcf.saveIssuer`. This does not error if any of the keywords\\n * already exist. If the keyword is already present, it is ignored.\\n *\\n * @param {ContractFacet} zcf\\n * @param {IssuerKeywordRecord} issuerKeywordRecord Issuers to save to\\n * ZCF\\n */\\nasync function saveAllIssuers(zcf, issuerKeywordRecord = harden({})) {\\n  const { issuers } = zcf.getTerms();\\n  const issuersPSaved = Object.entries(issuerKeywordRecord).map(\\n  ([keyword, issuer]) => {\\n    /* If the keyword does not yet exist, add it and the*/\\n    /* associated issuer.*/\\n    if (issuers[keyword] === undefined) {\\n      return zcf.saveIssuer(issuer, keyword);}\\n\\n    return undefined;});\\n\\n\\n  return Promise.all(issuersPSaved);}\\n\\n\\n/** @type {MapKeywords} */\\nconst mapKeywords = (keywordRecord = {}, keywordMapping) => {\\n  return Object.fromEntries(\\n  Object.entries(keywordRecord).map(([keyword, value]) => {\\n    if (keywordMapping[keyword] === undefined) {\\n      return [keyword, value];}\\n\\n    return [keywordMapping[keyword], value];}));};\\n\\n\\n\\n/** @type {Reverse} */\\nconst reverse = (keywordRecord = {}) => {\\n  return Object.fromEntries(\\n  Object.entries(keywordRecord).map(([key, value]) => [value, key]));};\\n\\n\\n\\n/** @type {OfferTo} */\\nconst offerTo = async (\\nzcf,\\ninvitation,\\nkeywordMapping = {},\\nproposal,\\nfromSeat,\\ntoSeat) =>\\n{\\n  const definedToSeat = toSeat !== undefined ? toSeat : fromSeat;\\n\\n  const zoe = zcf.getZoeService();\\n  const mappingReversed = reverse(keywordMapping);\\n\\n  /* the proposal is in the other contract's keywords, but we want to*/\\n  /* use `proposal.give` to withdraw*/\\n  const payments = await withdrawFromSeat(\\n  zcf,\\n  fromSeat,\\n  /* `proposal.give` may be undefined*/\\n  mapKeywords(proposal.give, mappingReversed));\\n\\n\\n  /* Map to the other contract's keywords*/\\n  const paymentsForOtherContract = mapKeywords(payments, keywordMapping);\\n\\n  const userSeatPromise = noShim.E(zoe).offer(\\n  invitation,\\n  proposal,\\n  paymentsForOtherContract);\\n\\n\\n  const depositedPromiseKit = promiseKit.makePromiseKit();\\n\\n  const doDeposit = async payoutPayments => {\\n    const amounts = await noShim.E(userSeatPromise).getCurrentAllocation();\\n\\n    /* Map back to the original contract's keywords*/\\n    const mappedAmounts = mapKeywords(amounts, mappingReversed);\\n    const mappedPayments = mapKeywords(payoutPayments, mappingReversed);\\n    await depositToSeat(zcf, definedToSeat, mappedAmounts, mappedPayments);\\n    depositedPromiseKit.resolve(mappedAmounts);};\\n\\n\\n  noShim.E(userSeatPromise).\\n  getPayouts().\\n  then(doDeposit);\\n\\n  return harden({ userSeatPromise, deposited: depositedPromiseKit.promise });};exports.assertIssuerKeywords = assertIssuerKeywords;exports.assertProposalShape = assertProposalShape;exports.assertUsesNatMath = assertUsesNatMath;exports.defaultAcceptanceMsg = defaultAcceptanceMsg;exports.depositToSeat = depositToSeat;exports.depositToSeatSuccessMsg = depositToSeatSuccessMsg;exports.mapKeywords = mapKeywords;exports.offerTo = offerTo;exports.satisfies = satisfies;exports.saveAllIssuers = saveAllIssuers;exports.swap = swap;exports.swapExact = swapExact;exports.trade = trade;exports.withdrawFromSeat = withdrawFromSeat;\",\n  \"zoe/src/contractSupport/ratio.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var assert = require('../../../assert/src/assert.js');var nat_esm = require('../../../nat/dist/nat.esm.js');var safeMath = require('./safeMath.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\nconst { multiply, floorDivide } = safeMath.natSafeMath;\\n\\n/* make a Ratio, which represents a fraction. It is a pass-by-copy record.*/\\n/**/\\n/* The natural syntax for the most common operations we want to support*/\\n/* are Amount * Ratio and Amount / Ratio. Since the operations want to adhere to*/\\n/* the ratio rather than the amount, we settled on a calling convention of*/\\n/* multiplyBy(Amount, Ratio) and divideBy(Amount, Ratio).*/\\n/**/\\n/* The most common kind of Ratio can be applied to Amounts of a particular*/\\n/* brand, and produces results of the same brand. This represents a multiplier*/\\n/* that is only applicable to that brand. The less common kind of Ratio can be*/\\n/* applied to one particular brand of amounts, and produces results of another*/\\n/* particular brand. This represents some kind of exchange rate. The*/\\n/* brand-checking helps us ensure that normal Ratios aren't applied to amounts*/\\n/* of the wrong brand, and that exchange rates are only used in the appropriate*/\\n/* direction.*/\\n\\nconst PERCENT = 100n;\\n\\nconst ratioPropertyNames = ['numerator', 'denominator'];\\n\\nconst assertIsRatio = ratio => {\\n  const propertyNames = Object.getOwnPropertyNames(ratio);\\n  assert.assert(\\n  propertyNames.length === 2,\\n  assert.details`Ratio ${ratio} must be a record with 2 fields.`);\\n\\n  for (const name of propertyNames) {\\n    assert.assert(\\n    ratioPropertyNames.includes(name),\\n    assert.details`Parameter must be a Ratio record, but ${ratio} has ${assert.quote(name)}`);}\\n\\n\\n  nat_esm.Nat(ratio.numerator.value);\\n  nat_esm.Nat(ratio.denominator.value);};\\n\\n\\n/**\\n * @param {NatValue} numerator\\n * @param {Brand} numeratorBrand\\n * @param {NatValue} denominator\\n * @param {Brand} denominatorBrand\\n * @returns {Ratio}\\n */\\nconst makeRatio = (\\nnumerator,\\nnumeratorBrand,\\ndenominator = PERCENT,\\ndenominatorBrand = numeratorBrand) =>\\n{\\n  assert.assert(\\n  denominator > 0n,\\n  assert.details`No infinite ratios! Denominator was 0/${assert.quote(denominatorBrand)}`);\\n\\n\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* use amountMath's constructor here rather than building the record directly*/\\n  return harden({\\n    numerator: { value: nat_esm.Nat(numerator), brand: numeratorBrand },\\n    denominator: { value: nat_esm.Nat(denominator), brand: denominatorBrand } });};\\n\\n\\n\\nconst makeRatioFromAmounts = (numeratorAmount, denominatorAmount) => {\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* coerce amounts using a native amountMath operation.*/\\n\\n  return makeRatio(\\n  nat_esm.Nat(numeratorAmount.value),\\n  numeratorAmount.brand,\\n  nat_esm.Nat(denominatorAmount.value),\\n  denominatorAmount.brand);};\\n\\n\\n\\nconst multiplyBy = (amount, ratio) => {\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* coerce amount using a native amountMath operation.*/\\n  assert.assert(amount.brand, assert.details`Expected an amount: ${amount}`);\\n  nat_esm.Nat(amount.value);\\n\\n  assertIsRatio(ratio);\\n  assert.assert(\\n  amount.brand === ratio.denominator.brand,\\n  assert.details`amount's brand ${assert.quote(amount.brand)} must match ratio's denominator ${assert.quote(\\n  ratio.denominator.brand)\\n  }`);\\n\\n\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* use amountMath's constructor here rather than building the record directly*/\\n  return harden({\\n    value: floorDivide(\\n    multiply(amount.value, ratio.numerator.value),\\n    ratio.denominator.value),\\n\\n    brand: ratio.numerator.brand });};\\n\\n\\n\\nconst divideBy = (amount, ratio) => {\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* coerce amount using a native amountMath operation.*/\\n  assert.assert(amount.brand, assert.details`Expected an amount: ${amount}`);\\n  nat_esm.Nat(amount.value);\\n\\n  assertIsRatio(ratio);\\n  assert.assert(\\n  amount.brand === ratio.numerator.brand,\\n  assert.details`amount's brand ${assert.quote(amount.brand)} must match ratio's numerator ${assert.quote(\\n  ratio.numerator.brand)\\n  }`);\\n\\n\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* use amountMath's constructor here rather than building the record directly*/\\n  return harden({\\n    value: floorDivide(\\n    multiply(amount.value, ratio.denominator.value),\\n    ratio.numerator.value),\\n\\n    brand: ratio.denominator.brand });};\\n\\n\\n\\nconst invertRatio = ratio => {\\n  assertIsRatio(ratio);\\n\\n  return makeRatio(\\n  ratio.denominator.value,\\n  ratio.denominator.brand,\\n  ratio.numerator.value,\\n  ratio.numerator.brand);};exports.assertIsRatio = assertIsRatio;exports.divideBy = divideBy;exports.invertRatio = invertRatio;exports.makeRatio = makeRatio;exports.makeRatioFromAmounts = makeRatioFromAmounts;exports.multiplyBy = multiplyBy;\",\n  \"zoe/src/contractSupport/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var safeMath = require('./safeMath.js');var bondingCurves = require('./bondingCurves.js');var priceAuthority = require('./priceAuthority.js');var priceQuote = require('./priceQuote.js');var stateMachine = require('./stateMachine.js');var statistics = require('./statistics.js');var zoeHelpers = require('./zoeHelpers.js');var ratio = require('./ratio.js'); /* @ts-check*/exports.natSafeMath = safeMath.natSafeMath;exports.calcLiqValueToMint = bondingCurves.calcLiqValueToMint;exports.calcSecondaryRequired = bondingCurves.calcSecondaryRequired;exports.calcValueToRemove = bondingCurves.calcValueToRemove;exports.getInputPrice = bondingCurves.getInputPrice;exports.getOutputPrice = bondingCurves.getOutputPrice;exports.makeOnewayPriceAuthorityKit = priceAuthority.makeOnewayPriceAuthorityKit;exports.getAmountIn = priceQuote.getAmountIn;exports.getAmountOut = priceQuote.getAmountOut;exports.getQuoteValues = priceQuote.getQuoteValues;exports.getTimestamp = priceQuote.getTimestamp;exports.makeStateMachine = stateMachine.makeStateMachine;exports.calculateMedian = statistics.calculateMedian;exports.assertIssuerKeywords = zoeHelpers.assertIssuerKeywords;exports.assertProposalShape = zoeHelpers.assertProposalShape;exports.assertUsesNatMath = zoeHelpers.assertUsesNatMath;exports.defaultAcceptanceMsg = zoeHelpers.defaultAcceptanceMsg;exports.depositToSeat = zoeHelpers.depositToSeat;exports.offerTo = zoeHelpers.offerTo;exports.satisfies = zoeHelpers.satisfies;exports.saveAllIssuers = zoeHelpers.saveAllIssuers;exports.swap = zoeHelpers.swap;exports.swapExact = zoeHelpers.swapExact;exports.trade = zoeHelpers.trade;exports.withdrawFromSeat = zoeHelpers.withdrawFromSeat;exports.assertIsRatio = ratio.assertIsRatio;exports.divideBy = ratio.divideBy;exports.invertRatio = ratio.invertRatio;exports.makeRatio = ratio.makeRatio;exports.makeRatioFromAmounts = ratio.makeRatioFromAmounts;exports.multiplyBy = ratio.multiplyBy;\"\n};\n  const nsBundle = {};\n\n  function createEvalString(filename) {\n      const code = sourceBundle[filename];\n      if (!code) {\n        return undefined;\n      }\n      return `\\\n(function getExport(require, exports) { \\\n  'use strict'; \\\n  const module = { exports }; \\\n  \\\n  ${code}\n  return module.exports;\n})\n//# sourceURL=${filePrefix}/${filename}\n`;\n    }\n\n  function computeExports(filename, exportPowers, exports) {\n      const { require: systemRequire, _log } = exportPowers;\n      // This captures the endowed require.\n      const match = filename.match(/^(.*)\\/[^/]+$/);\n      const thisdir = match ? match[1] : '.';\n      const contextRequire = mod => {\n        // Do path algebra to find the actual source.\n        const els = mod.split('/');\n        let prefix;\n        if (els[0][0] === '@') {\n          // Scoped name.\n          prefix = els.splice(0, 2).join('/');\n        } else if (els[0][0] === '.') {\n          // Relative.\n          els.unshift(...thisdir.split('/'));\n        } else {\n          // Bare or absolute.\n          prefix = els.splice(0, 1);\n        }\n\n        const suffix = [];\n        for (const el of els) {\n          if (el === '.' || el === '') {\n            // Do nothing.\n          } else if (el === '..') {\n            // Traverse upwards.\n            suffix.pop();\n          } else {\n            suffix.push(el);\n          }\n        }\n\n        // log(mod, prefix, suffix);\n        if (prefix !== undefined) {\n          suffix.unshift(prefix);\n        }\n        let modPath = suffix.join('/');\n        if (modPath.startsWith('./')) {\n          modPath = modPath.slice(2);\n        }\n        // log('requiring', modPath);\n        if (!(modPath in nsBundle)) {\n          // log('evaluating', modPath);\n          // Break cycles, but be tolerant of modules\n          // that completely override their exports object.\n          nsBundle[modPath] = {};\n          nsBundle[modPath] = computeExports(\n            modPath,\n            exportPowers,\n            nsBundle[modPath],\n          );\n        }\n\n        // log('returning', nsBundle[modPath]);\n        return nsBundle[modPath];\n      };\n\n      const code = createEvalString(filename);\n      if (!code) {\n        // log('missing code for', filename, sourceBundle);\n        if (systemRequire) {\n          return systemRequire(filename);\n        }\n        throw Error(\n          `require(${JSON.stringify(\n            filename,\n          )}) failed; no toplevel require endowment`,\n        );\n      }\n\n      // log('evaluating', code);\n      return nestedEvaluate(code)(contextRequire, exports);\n    }\n\n  // Evaluate the entrypoint recursively, seeding the exports.\n  const systemRequire = typeof require === 'undefined' ? undefined : require;\n  return computeExports(entrypoint, { require: systemRequire }, {});\n}\n//# sourceURL=/bundled-source/...-preamble.js\n","sourceMap":"//# sourceURL=/bundled-source/...-preamble.js\n","moduleFormat":"nestedEvaluate"},"bundleName":"coveredCall"};