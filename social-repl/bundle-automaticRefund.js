export default {"bundle":{"source":"function getExportWithNestedEvaluate(filePrefix) {\n  'use strict';\n  // Serialised sources.\n  if (filePrefix === undefined) {\n    filePrefix = \"/bundled-source/...\";\n  }\n  const moduleFormat = \"nestedEvaluate\";\n  const entrypoint = \"zoe/src/contracts/automaticRefund.js\";\n  const sourceBundle = {\n  \"zoe/src/contracts/automaticRefund.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var marshal = require('../../../marshal/src/marshal.js');require('../../../marshal/index.js');\\n\\n\\n\\n\\n\\nrequire('../../exported.js'); /* @ts-check*/ /**\\n * This is a very trivial contract to explain and test Zoe.\\n * AutomaticRefund just gives you back what you put in.\\n * AutomaticRefund tells Zoe to complete the\\n * offer, which gives the user their payout through Zoe. Other\\n * contracts will use these same steps, but they will have more\\n * sophisticated logic and interfaces.\\n *\\n * Since the contract doesn't attempt any reallocation, the offer can contain\\n * anything in `give` and `want`. The amount in `give` will be returned, and\\n * `want` will be ignored.\\n *\\n * @type {ContractStartFn}\\n * @param {ContractFacet} zcf\\n */\\nconst start = zcf => {\\n  let offersCount = 0n;\\n\\n  /** @type {OfferHandler} */\\n  const refund = seat => {\\n    offersCount += 1n;\\n    seat.exit();\\n    return `The offer was accepted`;};\\n\\n  const makeRefundInvitation = () => zcf.makeInvitation(refund, 'getRefund');\\n\\n  /** @type {AutomaticRefundPublicFacet} */\\n  const publicFacet = marshal.Far('publicFacet', {\\n    getOffersCount: () => offersCount,\\n    makeInvitation: makeRefundInvitation });\\n\\n\\n  const creatorInvitation = makeRefundInvitation();\\n\\n  return harden({ creatorInvitation, publicFacet });};\\n\\n\\nharden(start);exports.start = start;\",\n  \"nat/dist/nat.esm.js\": \"'use strict';\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* Copyright (C) 2011 Google Inc.*/ /* Copyright (C) 2018 Agoric*/ /**/ /* Licensed under the Apache License, Version 2.0 (the \\\"License\\\");*/ /* you may not use this file except in compliance with the License.*/ /* You may obtain a copy of the License at*/ /**/ /* http://www.apache.org/licenses/LICENSE-2.0*/ /**/ /* Unless required by applicable law or agreed to in writing, software*/ /* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,*/ /* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/ /* See the License for the specific language governing permissions and*/ /* limitations under the License.*/ /* @ts-check*/ /**\\n * Is `allegedNum` a number in the [contiguous range of exactly and\\n * unambiguously\\n * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)\\n *  natural numbers (non-negative integers)?\\n *\\n * To qualify `allegedNum` must either be a\\n * non-negative `bigint`, or a non-negative `number` representing an integer\\n * within range of [integers safely representable in\\n * floating point](https://tc39.es/ecma262/#sec-number.issafeinteger).\\n *\\n * @param {any} allegedNum\\n * @returns {boolean}\\n */\\nfunction isNat(allegedNum) {\\n  if (typeof allegedNum === 'bigint') {\\n    return allegedNum >= 0;}\\n\\n\\n  return Number.isSafeInteger(allegedNum) && allegedNum >= 0;}\\n\\n\\n/**\\n * If `allegedNumber` passes the `isNat` test, then return it as a bigint.\\n * Otherwise throw an appropriate error.\\n *\\n * If `allegedNum` is neither a bigint nor a number, `Nat` throws a `TypeError`.\\n * Otherwise, if it is not a [safely\\n * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)\\n * non-negative integer, `Nat` throws a `RangeError`.\\n * Otherwise, it is converted to a bigint if necessary and returned.\\n *\\n * @param {bigint | number} allegedNum\\n * @returns {bigint}\\n */\\nfunction Nat(allegedNum) {\\n  if (typeof allegedNum === 'bigint') {\\n    if (allegedNum < 0) {\\n      throw new RangeError(`${allegedNum} is negative`);}\\n\\n    return allegedNum;}\\n\\n\\n  if (typeof allegedNum === 'number') {\\n    if (!Number.isSafeInteger(allegedNum)) {\\n      throw new RangeError(`${allegedNum} not a safe integer`);}\\n\\n    if (allegedNum < 0) {\\n      throw new RangeError(`${allegedNum} is negative`);}\\n\\n    return BigInt(allegedNum);}\\n\\n\\n  throw new TypeError(\\n  `${allegedNum} is a ${typeof allegedNum} but must be a bigint or a number`);}exports.Nat = Nat;exports.isNat = isNat;\",\n  \"assert/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* @ts-check*/ /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /* Based on*/ /* https://github.com/Agoric/SES-shim/blob/master/packages/ses/src/error/types.js*/ /* Coordinate edits until we refactor to avoid this duplication*/ /**\\n * @callback BaseAssert\\n * The `assert` function itself.\\n *\\n * @param {*} flag The truthy/falsy value\\n * @param {Details=} optDetails The details to throw\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {asserts flag}\\n */ /**\\n * @callback AssertMakeError\\n *\\n * The `assert.error` method, recording details for the console.\\n *\\n * The optional `optDetails` can be a string.\\n * @param {Details=} optDetails The details of what was asserted\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {Error}\\n */ /**\\n * @callback AssertFail\\n *\\n * The `assert.fail` method.\\n *\\n * Fail an assertion, recording details to the console and\\n * raising an exception with just type information.\\n *\\n * The optional `optDetails` can be a string for backwards compatibility\\n * with the nodejs assertion library.\\n * @param {Details=} optDetails The details of what was asserted\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {never}\\n */ /**\\n * @callback AssertEqual\\n * The `assert.equal` method\\n *\\n * Assert that two values must be `Object.is`.\\n * @param {*} actual The value we received\\n * @param {*} expected What we wanted\\n * @param {Details=} optDetails The details to throw\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {void}\\n */ /* Type all the overloads of the assertTypeof function.*/ /* There may eventually be a better way to do this, but*/ /* thems the breaks with Typescript 4.0.*/ /**\\n * @callback AssertTypeofBigint\\n * @param {any} specimen\\n * @param {'bigint'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is bigint}\\n *\\n * @callback AssertTypeofBoolean\\n * @param {any} specimen\\n * @param {'boolean'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is boolean}\\n *\\n * @callback AssertTypeofFunction\\n * @param {any} specimen\\n * @param {'function'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is Function}\\n *\\n * @callback AssertTypeofNumber\\n * @param {any} specimen\\n * @param {'number'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is number}\\n *\\n * @callback AssertTypeofObject\\n * @param {any} specimen\\n * @param {'object'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is Record<any, any> | null}\\n *\\n * @callback AssertTypeofString\\n * @param {any} specimen\\n * @param {'string'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is string}\\n *\\n * @callback AssertTypeofSymbol\\n * @param {any} specimen\\n * @param {'symbol'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is symbol}\\n *\\n * @callback AssertTypeofUndefined\\n * @param {any} specimen\\n * @param {'undefined'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is undefined}\\n */ /**\\n * The `assert.typeof` method\\n *\\n * @typedef {AssertTypeofBigint & AssertTypeofBoolean & AssertTypeofFunction & AssertTypeofNumber & AssertTypeofObject & AssertTypeofString & AssertTypeofSymbol & AssertTypeofUndefined} AssertTypeof\\n */ /**\\n * @callback AssertString\\n * The `assert.string` method.\\n *\\n * `assert.string(v)` is equivalent to `assert.typeof(v, 'string')`. We\\n * special case this one because it is the most frequently used.\\n *\\n * Assert an expected typeof result.\\n * @param {any} specimen The value to get the typeof\\n * @param {Details=} optDetails The details to throw\\n */ /**\\n * @callback AssertNote\\n * The `assert.note` method.\\n *\\n * Annotate this error with these details, potentially to be used by an\\n * augmented console, like the causal console of `console.js`, to\\n * provide extra information associated with logged errors.\\n *\\n * @param {Error} error\\n * @param {Details} detailsNote\\n * @returns {void}\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {{}} DetailsToken\\n * A call to the `details` template literal makes and returns a fresh details\\n * token, which is a frozen empty object associated with the arguments of that\\n * `details` template literal expression.\\n */ /**\\n * @typedef {string | DetailsToken} Details\\n * Either a plain string, or made by the `details` template literal tag.\\n */ /**\\n * @typedef {Object} StringablePayload\\n * Holds the payload passed to quote so that its printed form is visible.\\n * @property {() => string} toString How to print the payload\\n */ /**\\n * To \\\"declassify\\\" and quote a substitution value used in a\\n * details`...` template literal, enclose that substitution expression\\n * in a call to `quote`. This states that the argument should appear quoted\\n * (as if with `JSON.stringify`), in the error message of the thrown error. The\\n * payload itself is still passed unquoted to the console as it would be\\n * without `quote`.\\n *\\n * Starting from the example in the `details` comment, say instead that the\\n * color the sky is supposed to be is also computed. Say that we still don't\\n * want to reveal the sky's actual color, but we do want the thrown error's\\n * message to reveal what color the sky was supposed to be:\\n * ```js\\n * assert.equal(\\n *   sky.color,\\n *   color,\\n *   details`${sky.color} should be ${quote(color)}`,\\n * );\\n * ```\\n *\\n * The normal convention is to locally rename `details` to `X` and import `q`\\n * and `assert` unmodified.\\n * ```js\\n * import { assert, details as X, q } from \\\\'@agoric/assert\\\\';\\n * ```\\n * so the above example would then be\\n * ```js\\n * assert.equal(\\n *   sky.color,\\n *   color,\\n *   X`${sky.color} should be ${q(color)}`,\\n * );\\n * ```\\n *\\n * @callback AssertQuote\\n * @param {*} payload What to declassify\\n * @returns {StringablePayload} The declassified payload\\n */ /**\\n * @callback Raise\\n *\\n * To make an `assert` which terminates some larger unit of computation\\n * like a transaction, vat, or process, call `makeAssert` with a `Raise`\\n * callback, where that callback actually performs that larger termination.\\n * If possible, the callback should also report its `reason` parameter as\\n * the alleged reason for the termination.\\n *\\n * @param {Error} reason\\n */ /**\\n * @callback MakeAssert\\n *\\n * Makes and returns an `assert` function object that shares the bookkeeping\\n * state defined by this module with other `assert` function objects made by\\n * `makeAssert`. This state is per-module-instance and is exposed by the\\n * `loggedErrorHandler` above. We refer to `assert` as a \\\"function object\\\"\\n * because it can be called directly as a function, but also has methods that\\n * can be called.\\n *\\n * If `optRaise` is provided, the returned `assert` function object will call\\n * `optRaise(reason)` before throwing the error. This enables `optRaise` to\\n * engage in even more violent termination behavior, like terminating the vat,\\n * that prevents execution from reaching the following throw. However, if\\n * `optRaise` returns normally, which would be unusual, the throw following\\n * `optRaise(reason)` would still happen.\\n *\\n * @param {Raise=} optRaise\\n * @returns {Assert}\\n */ /**\\n * @typedef {(template: TemplateStringsArray | string[], ...args: any) => DetailsToken} DetailsTag\\n *\\n * Use the `details` function as a template literal tag to create\\n * informative error messages. The assertion functions take such messages\\n * as optional arguments:\\n * ```js\\n * assert(sky.isBlue(), details`${sky.color} should be \\\"blue\\\"`);\\n * ```\\n * The details template tag returns a `DetailsToken` object that can print\\n * itself with the formatted message in two ways.\\n * It will report the real details to\\n * the console but include only the typeof information in the thrown error\\n * to prevent revealing secrets up the exceptional path. In the example\\n * above, the thrown error may reveal only that `sky.color` is a string,\\n * whereas the same diagnostic printed to the console reveals that the\\n * sky was green.\\n *\\n * The `raw` member of a `template` is ignored, so a simple\\n * `string[]` can also be used as a template.\\n */ /**\\n * assert that expr is truthy, with an optional details to describe\\n * the assertion. It is a tagged template literal like\\n * ```js\\n * assert(expr, details`....`);`\\n * ```\\n *\\n * The literal portions of the template are assumed non-sensitive, as\\n * are the `typeof` types of the substitution values. These are\\n * assembled into the thrown error message. The actual contents of the\\n * substitution values are assumed sensitive, to be revealed to\\n * the console only. We assume only the virtual platform's owner can read\\n * what is written to the console, where the owner is in a privileged\\n * position over computation running on that platform.\\n *\\n * The optional `optDetails` can be a string for backwards compatibility\\n * with the nodejs assertion library.\\n *\\n * @typedef { BaseAssert & {\\n *   typeof: AssertTypeof,\\n *   error: AssertMakeError,\\n *   fail: AssertFail,\\n *   equal: AssertEqual,\\n *   string: AssertString,\\n *   note: AssertNote,\\n *   details: DetailsTag,\\n *   quote: AssertQuote,\\n *   makeAssert: MakeAssert,\\n * } } Assert\\n */\",\n  \"assert/src/assert.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js'); /* global globalThis */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst { freeze } = Object;\\n\\n/** @type {Assert} */\\nconst globalAssert = globalThis.assert;\\n\\nif (globalAssert === undefined) {\\n  throw new Error(\\n  `Cannot initialize @agoric/assert, missing globalThis.assert`);}\\n\\n\\n\\nconst missing = [\\n'fail',\\n'equal',\\n'typeof',\\n'string',\\n'note',\\n'details',\\n'quote',\\n'makeAssert'].\\nfilter(name => globalAssert[name] === undefined);\\nif (missing.length > 0) {\\n  throw new Error(\\n  `Cannot initialize @agoric/assert, missing globalThis.assert methods ${missing.join(\\n  ', ')\\n  }`);}\\n\\n\\n\\nconst { details, quote, makeAssert } = globalAssert;\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Prepend the correct indefinite article onto a noun, typically a typeof result\\n * e.g., \\\"an Object\\\" vs. \\\"a Number\\\"\\n *\\n * @deprecated\\n * @param {string} str The noun to prepend\\n * @returns {string} The noun prepended with a/an\\n */\\nfunction an(str) {\\n  str = `${str}`;\\n  if (str.length >= 1 && 'aeiouAEIOU'.includes(str[0])) {\\n    return `an ${str}`;}\\n\\n  return `a ${str}`;}\\n\\nfreeze(an);exports.an = an;exports.assert = globalAssert;exports.details = details;exports.makeAssert = makeAssert;exports.q = quote;exports.quote = quote;\",\n  \"promise-kit/src/promiseKit.js\": \"'use strict';\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* global globalThis */ /* @ts-check*/ /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/\\n\\nconst BestPipelinablePromise = globalThis.HandledPromise || Promise;\\n\\n/**\\n * @template T\\n * @typedef {Object} PromiseRecord A reified Promise\\n * @property {(value: ERef<T>) => void} resolve\\n * @property {(reason: any) => void} reject\\n * @property {Promise<T>} promise\\n */\\n\\n/**\\n * @template T\\n * @typedef {T | PromiseLike<T>} ERef\\n * A reference of some kind for to an object of type T. It may be a direct\\n * reference to a local T. It may be a local presence for a remote T. It may\\n * be a promise for a local or remote T. Or it may even be a thenable\\n * (a promise-like non-promise with a \\\"then\\\" method) for a T.\\n */\\n\\n/**\\n * Needed to prevent type errors where functions are detected to be undefined.\\n */\\nconst NOOP_INITIALIZER = harden(_ => {});\\n\\n/**\\n * makePromiseKit() builds a Promise object, and returns a record\\n * containing the promise itself, as well as separate facets for resolving\\n * and rejecting it.\\n *\\n * @template T\\n * @returns {PromiseRecord<T>}\\n */\\nfunction makePromiseKit() {\\n  /** @type {(value: T) => void} */\\n  let res = NOOP_INITIALIZER;\\n  /** @type {(reason: any) => void} */\\n  let rej = NOOP_INITIALIZER;\\n\\n  const p = new BestPipelinablePromise((resolve, reject) => {\\n    res = resolve;\\n    rej = reject;});\\n\\n  /* Node.js adds the `domain` property which is not a standard*/\\n  /* property on Promise. Because we do not know it to be ocap-safe,*/\\n  /* we remove it.*/\\n  if (p.domain) {\\n    /* deleting p.domain may break functionality. To retain current*/\\n    /* functionality at the expense of safety, set unsafe to true.*/\\n    const unsafe = false;\\n    if (unsafe) {\\n      const originalDomain = p.domain;\\n      Object.defineProperty(p, 'domain', {\\n        get() {\\n          return originalDomain;} });} else\\n\\n\\n    {\\n      delete p.domain;}}\\n\\n\\n  return harden({ promise: p, resolve: res, reject: rej });}\\n\\nharden(makePromiseKit);\\n\\n/**\\n * Determine if the argument is a Promise.\\n *\\n * @param {any} maybePromise The value to examine\\n * @returns {maybePromise is Promise} Whether it is a promise\\n */\\nfunction isPromise(maybePromise) {\\n  return Promise.resolve(maybePromise) === maybePromise;}\\n\\nharden(isPromise);exports.isPromise = isPromise;exports.makePromiseKit = makePromiseKit;\",\n  \"marshal/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference path=\\\"extra-types.d.ts\\\" />*/ /**\\n * @typedef { \\\"bigint\\\" | \\\"boolean\\\" | \\\"null\\\" | \\\"number\\\" | \\\"string\\\" | \\\"symbol\\\" | \\\"undefined\\\" | \\\"copyArray\\\" | \\\"copyRecord\\\" | \\\"copyError\\\" | \\\"promise\\\" | \\\"presence\\\" } PassStyle\\n * TODO \\\"presence\\\" above should indirect through REMOTE_STYLE to prepare\\n * for changing it to \\\"remotable\\\"\\n */ /* TODO declare more precise types throughout this file, so the type system*/ /* and IDE can be more helpful.*/ /**\\n * @typedef {*} Passable\\n *\\n * A Passable value that may be marshalled. It is classified as one of\\n * PassStyle. A Passable must be hardened.\\n *\\n * A Passable has a pass-by-copy superstructure. This includes the atomic\\n * pass-by-copy primitives (\\\"bigint\\\" | \\\"boolean\\\" | \\\"null\\\" | \\\"number\\\" |\\n * \\\"string\\\" | \\\"undefined\\\") and the composite pass-by-copy objects (\\\"copyArray\\\" |\\n * \\\"copyRecord\\\" | \\\"copyError\\\"). The composite pass-by-copy objects that may\\n * contain other Passables.\\n *\\n * A Passable's pass-by-copy superstructure ends in PassableCap leaves. The\\n * Passable can be further classified by the nature of these leaves. Since a\\n * Passable is hardened, its structure and classification is stable --- its\\n * structure and classification cannot change even if some of the objects are\\n * proxies.\\n */ /**\\n * @typedef {Passable} Comparable\\n *\\n * A Comparable is a Passable in which none of the leaves of the pass-by-copy\\n * superstructure are promises. Two Comparables may be compared by\\n * for equivalence according to `sameStructure`, which is the strongest\\n * equivalence class supported by marshal's distributed object semantics.\\n */ /**\\n * @typedef {Comparable} OnlyData\\n *\\n * A Comparable is OnlyData when its pass-by-copy superstructure has no leaves,\\n * i.e., when all the leaves of the data structure tree are primitive data\\n * types or empty composites.\\n */ /**\\n * @typedef {OnlyData} PureData\\n *\\n * An OnlyData value is PureData when it contains no hidden mutable state,\\n * e.g., when none of its pass-by-copy composite data objects are proxies. This\\n * cannot be determined by inspection. It can only be achieved by trusted\\n * construction. A PureData value cannot be used as a communications channel,\\n * and can therefore be safely shared with subgraphs that should not be able\\n * to communicate with each other.\\n */ /**\\n * @typedef {*} Remotable\\n * Might be an object explicitly deemed to be `Remotable`, an object inferred\\n * to be Remotable, or a remote presence of a Remotable.\\n */ /**\\n * @typedef {Promise | Remotable} PassableCap\\n * The leaves of a Passable's pass-by-copy superstructure.\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @template Slot\\n * @callback ConvertValToSlot\\n * @param {PassableCap} val\\n * @returns {Slot}\\n */ /**\\n * @template Slot\\n * @callback ConvertSlotToVal\\n * @param {Slot} slot\\n * @param {InterfaceSpec=} iface\\n * @returns {PassableCap}\\n */ /**\\n * @template T\\n * @typedef {{ '@qclass': T }} EncodingClass\\n */ /**\\n * @typedef {EncodingClass<'NaN'> |\\n * EncodingClass<'undefined'> |\\n * EncodingClass<'Infinity'> |\\n * EncodingClass<'-Infinity'> |\\n * EncodingClass<'bigint'> & { digits: string } |\\n * EncodingClass<'@@asyncIterator'> |\\n * EncodingClass<'ibid'> & { index: number } |\\n * EncodingClass<'error'> & { name: string, message: string, errorId?: string } |\\n * EncodingClass<'slot'> & { index: number, iface?: InterfaceSpec } |\\n * EncodingClass<'hilbert'> & { original: Encoding, rest?: Encoding }} EncodingUnion\\n * @typedef {{ [index: string]: Encoding, '@qclass'?: undefined }} EncodingRecord\\n * We exclude '@qclass' as a property in encoding records.\\n * @typedef {EncodingUnion | null | string | boolean | number | EncodingRecord} EncodingElement\\n */ /**\\n * @typedef {EncodingElement | NestedArray<EncodingElement>} Encoding\\n * The JSON structure that the data portion of a Passable serializes to.\\n *\\n * The QCLASS 'hilbert' is a reference to the Hilbert Hotel\\n * of https://www.ias.edu/ideas/2016/pires-hilbert-hotel\\n * If QCLASS appears as a property name in the data, we encode it instead\\n * as a QCLASS record of type 'hilbert'. To do so, we must move the other\\n * parts of the record into fields of the hilbert record.\\n */ /**\\n * @template Slot\\n * @typedef CapData\\n * @property {Encoding} body\\n * @property {Slot[]} slots\\n */ /**\\n * @template Slot\\n * @callback Serialize\\n * @param {Passable} val\\n * @returns {CapData<Slot>}\\n */ /**\\n * @typedef {\\\"allowCycles\\\" | \\\"warnOfCycles\\\" | \\\"forbidCycles\\\"} CyclePolicy\\n */ /**\\n * @template Slot\\n * @callback Unserialize\\n * @param {CapData<Slot>} data\\n * @param {CyclePolicy=} cyclePolicy\\n * @returns {Passable}\\n */ /**\\n * @template Slot\\n * @typedef Marshal\\n * @property {Serialize<Slot>} serialize\\n * @property {Unserialize<Slot>} unserialize\\n */ /**\\n * @template Slot\\n * @callback MakeMarshal\\n * @param {ConvertValToSlot=} convertValToSlot\\n * @param {ConvertSlotToVal=} convertSlotToVal\\n * @param {MakeMarshalOptions=} options\\n * @returns {Marshal}\\n */ /**\\n * @typedef MakeMarshalOptions\\n * @property {string=} marshalName\\n * @property {'on'|'off'=} errorTagging\\n * @property {(err: Error) => void=} marshalSaveError\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {string} InterfaceSpec\\n * This is an interface specification.\\n * For now, it is just a string, but will eventually be any OnlyData. Either\\n * way, it must remain pure, so that it can be safely shared by subgraphs that\\n * are not supposed to be able to communicate.\\n */ /**\\n * @callback MarshalGetInterfaceOf\\n * Simple semantics, just tell what interface (or undefined) a remotable has.\\n *\\n * @param {*} maybeRemotable the value to check\\n * @returns {InterfaceSpec|undefined} the interface specification, or undefined\\n * if not a deemed to be a Remotable\\n */\",\n  \"marshal/src/ibidTables.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var nat_esm = require('../../nat/dist/nat.esm.js');var assert = require('../../assert/src/assert.js');\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('./types.js'); /* @ts-check*/ /**\\n * The ibid logic relies on\\n *    * JSON.stringify on an array visiting array indexes from 0 to\\n *      arr.length -1 in order, and not visiting anything else.\\n *    * JSON.parse of a record (a plain object) creating an object on\\n *      which a getOwnPropertyNames will enumerate properties in the\\n *      same order in which they appeared in the parsed JSON string.\\n */\\nconst makeReplacerIbidTable = () => {\\n  /** @type {Map<object, number>} */\\n  const ibidMap = new Map();\\n  let ibidCount = 0;\\n\\n  return harden({\\n    /**\\n     * @param {object} obj\\n     */\\n    has(obj) {\\n      return ibidMap.has(obj);},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    get(obj) {\\n      return ibidMap.get(obj);},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    add(obj) {\\n      ibidMap.set(obj, ibidCount);\\n      ibidCount += 1;} });};\\n\\n\\n\\nharden(makeReplacerIbidTable);\\n\\n\\n/**\\n * @param {CyclePolicy} cyclePolicy\\n */\\nconst makeReviverIbidTable = cyclePolicy => {\\n  const ibids = [];\\n  const unfinishedIbids = new WeakSet();\\n\\n  return harden({\\n    /**\\n     * @param {number} allegedIndex\\n     * @returns {object}\\n     */\\n    get(allegedIndex) {\\n      const index = Number(nat_esm.Nat(allegedIndex));\\n      assert.assert(index < ibids.length, assert.details`ibid out of range: ${index}`, RangeError);\\n      const result = ibids[index];\\n      if (unfinishedIbids.has(result)) {\\n        switch (cyclePolicy) {\\n          case 'allowCycles':{\\n              break;}\\n\\n          case 'warnOfCycles':{\\n              console.log(`Warning: ibid cycle at ${index}`);\\n              break;}\\n\\n          case 'forbidCycles':{\\n              assert.assert.fail(assert.details`Ibid cycle at ${assert.quote(index)}`, TypeError);}\\n\\n          default:{\\n              assert.assert.fail(\\n              assert.details`Unrecognized cycle policy: ${assert.quote(cyclePolicy)}`,\\n              TypeError);}}}\\n\\n\\n\\n\\n      return result;},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    register(obj) {\\n      ibids.push(obj);\\n      return obj;},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    start(obj) {\\n      ibids.push(obj);\\n      unfinishedIbids.add(obj);\\n      return obj;},\\n\\n    /**\\n     * @param {object} obj\\n     */\\n    finish(obj) {\\n      unfinishedIbids.delete(obj);\\n      return obj;} });};\\n\\n\\n\\nharden(makeReviverIbidTable);exports.makeReplacerIbidTable = makeReplacerIbidTable;exports.makeReviverIbidTable = makeReviverIbidTable;\",\n  \"marshal/src/marshal.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var nat_esm = require('../../nat/dist/nat.esm.js');var assert = require('../../assert/src/assert.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');require('./types.js');var ibidTables = require('./ibidTables.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst {\\n  getPrototypeOf,\\n  setPrototypeOf,\\n  create,\\n  getOwnPropertyDescriptors,\\n  defineProperties,\\n  is,\\n  isFrozen,\\n  fromEntries,\\n  prototype: objectPrototype } =\\nObject;\\n\\nconst { ownKeys } = Reflect;\\n\\n/* TODO: Use just 'remote' when we're willing to make a breaking change.*/\\nconst REMOTE_STYLE = 'presence';\\n\\nconst PASS_STYLE = Symbol.for('passStyle');\\n\\n/** @type {MarshalGetInterfaceOf} */\\nfunction getInterfaceOf(val) {\\n  if (typeof val !== 'object' || val === null) {\\n    return undefined;}\\n\\n  if (val[PASS_STYLE] !== REMOTE_STYLE) {\\n    return undefined;}\\n\\n  assert.assert(isFrozen(val), assert.details`Remotable ${val} must be frozen`, TypeError);\\n  const iface = val[Symbol.toStringTag];\\n  assert.assert.typeof(\\n  iface,\\n  'string',\\n  assert.details`Remotable interface currently can only be a string`);\\n\\n  return iface;}\\n\\n\\n/**\\n * Do a deep copy of the object, handling Proxies and recursion.\\n * The resulting copy is guaranteed to be pure data, as well as hardened.\\n * Such a hardened, pure copy cannot be used as a communications path.\\n *\\n * @template T\\n * @param {T & OnlyData} val input value.  NOTE: Must be hardened!\\n * @param {WeakMap<any,any>} [already=new WeakMap()]\\n * @returns {T & PureData} pure, hardened copy\\n */\\nfunction pureCopy(val, already = new WeakMap()) {\\n  /* eslint-disable-next-line no-use-before-define*/\\n  const passStyle = passStyleOf(val);\\n  switch (passStyle) {\\n    case 'bigint':\\n    case 'boolean':\\n    case 'null':\\n    case 'number':\\n    case 'string':\\n    case 'undefined':\\n    case 'symbol':\\n      return val;\\n\\n    case 'copyArray':\\n    case 'copyRecord':{\\n        const obj = /** @type {Object} */val;\\n        if (already.has(obj)) {\\n          return already.get(obj);}\\n\\n\\n        /* Create a new identity.*/\\n        const copy = /** @type {T} */passStyle === 'copyArray' ? [] : {};\\n\\n        /* Prevent recursion.*/\\n        already.set(obj, copy);\\n\\n        /* Make a deep copy on the new identity.*/\\n        /* Object.entries(obj) takes a snapshot (even if a Proxy).*/\\n        /* Since we already know it is a copyRecord or copyArray, we*/\\n        /* know that Object.entries is safe enough. On a copyRecord it*/\\n        /* will represent all the own properties. On a copyArray it*/\\n        /* will represent all the own properties except for the length.*/\\n        Object.entries(obj).forEach(([prop, value]) => {\\n          copy[prop] = pureCopy(value, already);});\\n\\n        return harden(copy);}\\n\\n\\n    case 'copyError':{\\n        const unk = /** @type {unknown} */val;\\n        const err = /** @type {Error} */unk;\\n\\n        if (already.has(err)) {\\n          return already.get(err);}\\n\\n\\n        const { name, message } = err;\\n\\n        /* eslint-disable-next-line no-use-before-define*/\\n        const EC = getErrorConstructor(`${name}`) || Error;\\n        const copy = harden(new EC(`${message}`));\\n        already.set(err, copy);\\n\\n        const unk2 = /** @type {unknown} */harden(copy);\\n        return (/** @type {T} */unk2);}\\n\\n\\n    case REMOTE_STYLE:{\\n        assert.assert.fail(\\n        assert.details`Input value ${assert.quote(\\n        passStyle)\\n        } cannot be copied as it must be passed by reference`,\\n        TypeError);}\\n\\n\\n\\n    case 'promise':{\\n        assert.assert.fail(assert.details`Promises cannot be copied`, TypeError);}\\n\\n\\n    default:\\n      assert.assert.fail(\\n      assert.details`Input value ${assert.quote(passStyle)} is not recognized as data`,\\n      TypeError);}}\\n\\n\\n\\nharden(pureCopy);\\n\\n\\nconst errorConstructors = new Map([\\n['Error', Error],\\n['EvalError', EvalError],\\n['RangeError', RangeError],\\n['ReferenceError', ReferenceError],\\n['SyntaxError', SyntaxError],\\n['TypeError', TypeError],\\n['URIError', URIError]]);\\n\\n\\nfunction getErrorConstructor(name) {\\n  return errorConstructors.get(name);}\\n\\n\\n/**\\n * For most of these classification tests, we do strict validity `assert`s,\\n * throwing if we detect something invalid. For errors, we need to remember\\n * the error itself exists to help us diagnose a bug that's likely more\\n * pressing than a validity bug in the error itself. Thus, whenever it is safe\\n * to do so, we prefer to let the error test succeed and to couch these\\n * complaints as notes on the error.\\n *\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyError(val) {\\n  /* TODO: Need a better test than instanceof*/\\n  if (!(val instanceof Error)) {\\n    return false;}\\n\\n  const proto = getPrototypeOf(val);\\n  const { name } = val;\\n  const EC = getErrorConstructor(name);\\n  if (!EC || EC.prototype !== proto) {\\n    assert.assert.note(\\n    val,\\n    assert.details`Errors must inherit from an error class .prototype ${val}`);}\\n\\n\\n\\n  const {\\n    message: mDesc,\\n    /* Allow but ignore only extraneous own `stack` property.*/\\n    stack: _optStackDesc,\\n    ...restDescs } =\\n  getOwnPropertyDescriptors(val);\\n  if (ownKeys(restDescs).length >= 1) {\\n    assert.assert.note(\\n    val,\\n    assert.details`Passed Error has extra unpassed properties ${restDescs}`);}\\n\\n\\n  if (mDesc) {\\n    if (typeof mDesc.value !== 'string') {\\n      assert.assert.note(\\n      val,\\n      assert.details`Passed Error \\\"message\\\" ${mDesc} must be a string-valued data property.`);}\\n\\n\\n    if (mDesc.enumerable) {\\n      assert.assert.note(\\n      val,\\n      assert.details`Passed Error \\\"message\\\" ${mDesc} must not be enumerable`);}}\\n\\n\\n\\n  return true;}\\n\\n\\n/**\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyArray(val) {\\n  if (!Array.isArray(val)) {\\n    return false;}\\n\\n  assert.assert(\\n  getPrototypeOf(val) === Array.prototype,\\n  assert.details`Malformed array: ${val}`,\\n  TypeError);\\n\\n  const len = val.length;\\n  const descs = getOwnPropertyDescriptors(val);\\n  for (let i = 0; i < len; i += 1) {\\n    const desc = descs[i];\\n    assert.assert(desc, assert.details`Arrays must not contain holes: ${assert.quote(i)}`, TypeError);\\n    assert.assert(\\n    'value' in desc,\\n    assert.details`Arrays must not contain accessors: ${assert.quote(i)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    typeof desc.value !== 'function',\\n    assert.details`Arrays must not contain methods: ${assert.quote(i)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    desc.enumerable,\\n    assert.details`Array elements must be enumerable: ${assert.quote(i)}`,\\n    TypeError);}\\n\\n\\n  assert.assert(\\n  ownKeys(descs).length === len + 1,\\n  assert.details`Arrays must not have non-indexes: ${val}`,\\n  TypeError);\\n\\n  return true;}\\n\\n\\n/**\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyRecord(val) {\\n  const proto = getPrototypeOf(val);\\n  if (proto !== objectPrototype) {\\n    return false;}\\n\\n  const descs = getOwnPropertyDescriptors(val);\\n  const descKeys = ownKeys(descs);\\n\\n  for (const descKey of descKeys) {\\n    if (typeof descKey === 'symbol') {\\n      return false;}\\n\\n    const desc = descs[descKey];\\n    if (typeof desc.value === 'function') {\\n      return false;}}\\n\\n\\n  for (const descKey of descKeys) {\\n    assert.assert.typeof(\\n    descKey,\\n    'string',\\n    assert.details`Pass by copy records can only have string-named own properties`);\\n\\n    const desc = descs[descKey];\\n    assert.assert(\\n    !('get' in desc),\\n    assert.details`Records must not contain accessors: ${assert.quote(descKey)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    desc.enumerable,\\n    assert.details`Record fields must be enumerable: ${assert.quote(descKey)}`,\\n    TypeError);}\\n\\n\\n  return true;}\\n\\n\\nconst makeRemotableProto = (oldProto, allegedName) => {\\n  assert.assert(\\n  oldProto === objectPrototype || oldProto === null,\\n  assert.details`For now, remotables cannot inherit from anything unusual`);\\n\\n  /* Assign the arrow function to a variable to set its .name.*/\\n  const toString = () => `[${allegedName}]`;\\n  return harden(\\n  create(oldProto, {\\n    [PASS_STYLE]: { value: REMOTE_STYLE },\\n    toString: { value: toString },\\n    [Symbol.toStringTag]: { value: allegedName } }));};\\n\\n\\n\\n\\n/**\\n * Throw if val is not the correct shape for the prototype of a Remotable.\\n *\\n * TODO: It would be nice to typedef this shape and then declare that this\\n * function asserts it, but we can't declare a type with PASS_STYLE from JSDoc.\\n *\\n * @param {{ [PASS_STYLE]: string, [Symbol.toStringTag]: string, toString: () =>\\n * void}} val the value to verify\\n */\\nconst assertRemotableProto = val => {\\n  assert.assert.typeof(val, 'object', assert.details`cannot serialize non-objects like ${val}`);\\n  assert.assert(!Array.isArray(val), assert.details`Arrays cannot be pass-by-remote`);\\n  assert.assert(val !== null, assert.details`null cannot be pass-by-remote`);\\n\\n  const protoProto = getPrototypeOf(val);\\n  assert.assert(\\n  protoProto === objectPrototype || protoProto === null,\\n  assert.details`The Remotable Proto marker cannot inherit from anything unusual`);\\n\\n  assert.assert(isFrozen(val), assert.details`The Remotable proto must be frozen`);\\n  const {\\n    [PASS_STYLE]: { value: passStyleValue },\\n    toString: { value: toStringValue },\\n    /* @ts-ignore https://github.com/microsoft/TypeScript/issues/1863*/\\n    [Symbol.toStringTag]: { value: toStringTagValue },\\n    ...rest } =\\n  getOwnPropertyDescriptors(val);\\n  assert.assert(\\n  ownKeys(rest).length === 0,\\n  assert.details`Unexpect properties on Remotable Proto ${ownKeys(rest)}`);\\n\\n  assert.assert(\\n  passStyleValue === REMOTE_STYLE,\\n  assert.details`Expected ${assert.quote(REMOTE_STYLE)}, not ${assert.quote(passStyleValue)}`);\\n\\n  assert.assert.typeof(toStringValue, 'function', assert.details`toString must be a function`);\\n  assert.assert.typeof(toStringTagValue, 'string', assert.details`@@toStringTag must be a string`);};\\n\\n\\n/**\\n * Ensure that val could become a legitimate remotable.  This is used\\n * internally both in the construction of a new remotable and\\n * mustPassByRemote.\\n *\\n * @param {*} val The remotable candidate to check\\n */\\nfunction assertCanBeRemotable(val) {\\n  /* throws exception if cannot*/\\n  assert.assert.typeof(val, 'object', assert.details`cannot serialize non-objects like ${val}`);\\n  assert.assert(!Array.isArray(val), assert.details`Arrays cannot be pass-by-remote`);\\n  assert.assert(val !== null, assert.details`null cannot be pass-by-remote`);\\n\\n  const descs = getOwnPropertyDescriptors(val);\\n  const keys = ownKeys(descs); /* enumerable-and-not, string-or-Symbol*/\\n  keys.forEach(key => {\\n    assert.assert(\\n    /* Typecast needed due to https://github.com/microsoft/TypeScript/issues/1863*/\\n    !('get' in descs[/** @type {string} */key]),\\n    assert.details`cannot serialize objects with getters like ${assert.quote(String(key))} in ${val}`);\\n\\n    assert.assert.typeof(\\n    /* @ts-ignore https://github.com/microsoft/TypeScript/issues/1863*/\\n    val[key],\\n    'function',\\n    assert.details`cannot serialize objects with non-methods like ${assert.quote(\\n    String(key))\\n    } in ${val}`);\\n\\n    assert.assert(\\n    key !== PASS_STYLE,\\n    assert.details`A pass-by-remote cannot shadow ${assert.quote(PASS_STYLE)}`);});}\\n\\n\\n\\n\\n/**\\n * @param {Remotable} val\\n */\\nfunction assertRemotable(val) {\\n  assert.assert(isFrozen(val), assert.details`cannot serialize non-frozen objects like ${val}`);\\n\\n  assertCanBeRemotable(val);\\n\\n  const p = getPrototypeOf(val);\\n  if (p !== null && p !== objectPrototype) {\\n    assertRemotableProto(p);}}\\n\\n\\n\\n/**\\n * This is the equality comparison used by JavaScript's Map and Set\\n * abstractions, where NaN is the same as NaN and -0 is the same as\\n * 0. Marshal serializes -0 as zero, so the semantics of our distributed\\n * object system does not distinguish 0 from -0.\\n *\\n * `sameValueZero` is the EcmaScript spec name for this equality comparison,\\n * but TODO we need a better name for the API.\\n *\\n * @param {any} x\\n * @param {any} y\\n * @returns {boolean}\\n */\\nfunction sameValueZero(x, y) {\\n  return x === y || is(x, y);}\\n\\n\\n/**\\n * objects can only be passed in one of two/three forms:\\n * 1: pass-by-remote: all properties (own and inherited) are methods,\\n *    the object itself is of type object, not function\\n * 2: pass-by-copy: all string-named own properties are data, not methods\\n *    the object must inherit from objectPrototype or null\\n * 3: the empty object is pass-by-remote, for identity comparison\\n *\\n * all objects must be frozen\\n *\\n * anything else will throw an error if you try to serialize it\\n * with these restrictions, our remote call/copy protocols expose all useful\\n * behavior of these objects: pass-by-remote objects have no other data (so\\n * there's nothing else to copy), and pass-by-copy objects have no other\\n * behavior (so there's nothing else to invoke)\\n *\\n * How would val be passed?  For primitive values, the answer is\\n *   * 'null' for null\\n *   * throwing an error for a symbol, whether registered or not.\\n *   * that value's typeof string for all other primitive values\\n * For frozen objects, the possible answers\\n *   * 'copyRecord' for non-empty records with only data properties\\n *   * 'copyArray' for arrays with only data properties\\n *   * 'copyError' for instances of Error with only data properties\\n *   * REMOTE_STYLE for non-array objects with only method properties\\n *   * 'promise' for genuine promises only\\n *   * throwing an error on anything else, including thenables.\\n * We export passStyleOf so other algorithms can use this module's\\n * classification.\\n *\\n * @param {Passable} val\\n * @returns {PassStyle}\\n */\\nfunction passStyleOf(val) {\\n  const typestr = typeof val;\\n  switch (typestr) {\\n    case 'object':{\\n        if (getInterfaceOf(val)) {\\n          return REMOTE_STYLE;}\\n\\n        if (val === null) {\\n          return 'null';}\\n\\n        assert.assert(\\n        isFrozen(val),\\n        assert.details`Cannot pass non-frozen objects like ${val}. Use harden()`);\\n\\n        if (promiseKit.isPromise(val)) {\\n          return 'promise';}\\n\\n        assert.assert(\\n        typeof val.then !== 'function',\\n        assert.details`Cannot pass non-promise thenables`);\\n\\n        if (isPassByCopyError(val)) {\\n          return 'copyError';}\\n\\n        if (isPassByCopyArray(val)) {\\n          return 'copyArray';}\\n\\n        if (isPassByCopyRecord(val)) {\\n          return 'copyRecord';}\\n\\n        assertRemotable(val);\\n        /* console.log(`--- @@marshal: pass-by-ref object without Far/Remotable`);*/\\n        /* assert.fail(X`pass-by-ref object without Far/Remotable`);*/\\n        return REMOTE_STYLE;}\\n\\n    case 'function':{\\n        assert.assert.fail(assert.details`Bare functions like ${val} are disabled for now`);}\\n\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case 'symbol':{\\n        return typestr;}\\n\\n    default:{\\n        assert.assert.fail(assert.details`Unrecognized typeof ${assert.quote(typestr)}`, TypeError);}}}\\n\\n\\n\\n\\n/**\\n * Special property name that indicates an encoding that needs special\\n * decoding.\\n */\\nconst QCLASS = '@qclass';\\n\\n\\n/**\\n * @template Slot\\n * @type {ConvertValToSlot<Slot>}\\n */\\nconst defaultValToSlotFn = x => x;\\n/**\\n * @template Slot\\n * @type {ConvertSlotToVal<Slot>}\\n */\\nconst defaultSlotToValFn = (x, _) => x;\\n\\n/**\\n * @template Slot\\n * @type {MakeMarshal<Slot>}\\n */\\nfunction makeMarshal(\\nconvertValToSlot = defaultValToSlotFn,\\nconvertSlotToVal = defaultSlotToValFn,\\n{\\n  marshalName = 'anon-marshal',\\n  errorTagging = 'on',\\n  /* We prefer that the caller instead log to somewhere hidden*/\\n  /* to be revealed when correlating with the received error.*/\\n  marshalSaveError = (err) =>\\n  console.log('Temporary logging of sent error', err) } =\\n{})\\n{\\n  assert.assert.typeof(marshalName, 'string');\\n  assert.assert(\\n  errorTagging === 'on' || errorTagging === 'off',\\n  assert.details`The errorTagging option can only be \\\"on\\\" or \\\"off\\\" ${errorTagging}`);\\n\\n  /* Ascending numbers identifying the sending of errors relative to this*/\\n  /* marshal instance.*/\\n  let errorCount = 0;\\n  const nextErrorId = () => {\\n    errorCount += 1;\\n    return `error:${marshalName}#${errorCount}`;};\\n\\n\\n  /**\\n   * @template Slot\\n   * @param {Passable} val\\n   * @param {Slot[]} slots\\n   * @param {WeakMap<Passable,number>} slotMap\\n   * @param {InterfaceSpec=} iface\\n   * @returns {Encoding}\\n   */\\n  function serializeSlot(val, slots, slotMap, iface = undefined) {\\n    let slotIndex;\\n    if (slotMap.has(val)) {\\n      slotIndex = slotMap.get(val);\\n      assert.assert.typeof(slotIndex, 'number');} else\\n    {\\n      const slot = convertValToSlot(val);\\n\\n      slotIndex = slots.length;\\n      slots.push(slot);\\n      slotMap.set(val, slotIndex);}\\n\\n\\n    /* if (iface === undefined && passStyleOf(val) === REMOTE_STYLE) {\\n     // iface = `Alleged: remotable at slot ${slotIndex}`;\\n     if (\\n     getPrototypeOf(val) === objectPrototype &&\\n     ownKeys(val).length === 0\\n     ) {\\n     // For now, skip the diagnostic if we have a pure empty object\\n     } else {\\n     try {\\n     assert.fail(X`Serialize ${val} generates needs iface`);\\n     } catch (err) {\\n     console.info(err);\\n     }\\n     }\\n     }\\n     */\\n\\n\\n    if (iface === undefined) {\\n      return harden({\\n        [QCLASS]: 'slot',\\n        index: slotIndex });}\\n\\n\\n    return harden({\\n      [QCLASS]: 'slot',\\n      iface,\\n      index: slotIndex });}\\n\\n\\n\\n  /**\\n   * @template Slot\\n   * @type {Serialize<Slot>}\\n   */\\n  const serialize = root => {\\n    const slots = [];\\n    /* maps val (promise or remotable) to index of slots[]*/\\n    const slotMap = new Map();\\n    const ibidTable = ibidTables.makeReplacerIbidTable();\\n\\n    /**\\n     * Must encode `val` into plain JSON data *canonically*, such that\\n     * `sameStructure(v1, v2)` implies\\n     * `JSON.stringify(encode(v1)) === JSON.stringify(encode(v2))`\\n     * For each record, we only accept sortable property names\\n     * (no anonymous symbols). On the encoded form the sort\\n     * order of these names must be the same as their enumeration\\n     * order, so a `JSON.stringify` of the encoded form agrees with\\n     * a canonical-json stringify of the encoded form.\\n     *\\n     * @param {Passable} val\\n     * @returns {Encoding}\\n     */\\n    const encode = val => {\\n      /* First we handle all primitives. Some can be represented directly as*/\\n      /* JSON, and some must be encoded as [QCLASS] composites.*/\\n      const passStyle = passStyleOf(val);\\n      switch (passStyle) {\\n        case 'null':{\\n            return null;}\\n\\n        case 'undefined':{\\n            return harden({ [QCLASS]: 'undefined' });}\\n\\n        case 'string':\\n        case 'boolean':{\\n            return val;}\\n\\n        case 'number':{\\n            if (Number.isNaN(val)) {\\n              return harden({ [QCLASS]: 'NaN' });}\\n\\n            if (is(val, -0)) {\\n              return 0;}\\n\\n            if (val === Infinity) {\\n              return harden({ [QCLASS]: 'Infinity' });}\\n\\n            if (val === -Infinity) {\\n              return harden({ [QCLASS]: '-Infinity' });}\\n\\n            return val;}\\n\\n        case 'bigint':{\\n            return harden({\\n              [QCLASS]: 'bigint',\\n              digits: String(val) });}\\n\\n\\n        case 'symbol':{\\n            switch (val) {\\n              case Symbol.asyncIterator:{\\n                  return harden({\\n                    [QCLASS]: '@@asyncIterator' });}\\n\\n\\n              default:{\\n                  assert.assert.fail(assert.details`Unsupported symbol ${assert.quote(String(val))}`);}}}\\n\\n\\n\\n        default:{\\n            /* if we've seen this object before, serialize a backref*/\\n            if (ibidTable.has(val)) {\\n              /* Backreference to prior occurrence*/\\n              const index = ibidTable.get(val);\\n              assert.assert.typeof(index, 'number');\\n              return harden({\\n                [QCLASS]: 'ibid',\\n                index });}\\n\\n\\n            ibidTable.add(val);\\n\\n            switch (passStyle) {\\n              case 'copyRecord':{\\n                  if (QCLASS in val) {\\n                    /* Hilbert hotel*/\\n                    const { [QCLASS]: qclassValue, ...rest } = val;\\n                    if (ownKeys(rest).length === 0) {\\n                      return harden({\\n                        [QCLASS]: 'hilbert',\\n                        original: encode(qclassValue) });} else\\n\\n                    {\\n                      return harden({\\n                        [QCLASS]: 'hilbert',\\n                        original: encode(qclassValue),\\n                        /* This means the rest will get an ibid entry even*/\\n                        /* though it is not any of the original objects.*/\\n                        rest: encode(harden(rest)) });}}\\n\\n\\n\\n                  /* Currently copyRecord allows only string keys so this will*/\\n                  /* work. If we allow sortable symbol keys, this will need to*/\\n                  /* become more interesting.*/\\n                  const names = ownKeys(val).sort();\\n                  return fromEntries(names.map(name => [name, encode(val[name])]));}\\n\\n              case 'copyArray':{\\n                  return val.map(encode);}\\n\\n              case 'copyError':{\\n                  /* We deliberately do not share the stack, but it would*/\\n                  /* be useful to log the stack locally so someone who has*/\\n                  /* privileged access to the throwing Vat can correlate*/\\n                  /* the problem with the remote Vat that gets this*/\\n                  /* summary. If we do that, we could allocate some random*/\\n                  /* identifier and include it in the message, to help*/\\n                  /* with the correlation.*/\\n\\n                  if (errorTagging === 'on') {\\n                    const errorId = nextErrorId();\\n                    assert.assert.note(val, assert.details`Sent as ${errorId}`);\\n                    marshalSaveError(val);\\n                    return harden({\\n                      [QCLASS]: 'error',\\n                      errorId,\\n                      message: `${val.message}`,\\n                      name: `${val.name}` });} else\\n\\n                  {\\n                    return harden({\\n                      [QCLASS]: 'error',\\n                      message: `${val.message}`,\\n                      name: `${val.name}` });}}\\n\\n\\n\\n              case REMOTE_STYLE:{\\n                  const iface = getInterfaceOf(val);\\n                  /* console.log(`serializeSlot: ${val}`);*/\\n                  return serializeSlot(val, slots, slotMap, iface);}\\n\\n              case 'promise':{\\n                  /* console.log(`serializeSlot: ${val}`);*/\\n                  return serializeSlot(val, slots, slotMap);}\\n\\n              default:{\\n                  assert.assert.fail(assert.details`unrecognized passStyle ${assert.quote(passStyle)}`, TypeError);}}}}};\\n\\n\\n\\n\\n\\n\\n    const encoded = encode(root);\\n\\n    return harden({\\n      body: JSON.stringify(encoded),\\n      slots });};\\n\\n\\n\\n  function makeFullRevive(slots, cyclePolicy) {\\n    /* ibid table is shared across recursive calls to fullRevive.*/\\n    const ibidTable = ibidTables.makeReviverIbidTable(cyclePolicy);\\n\\n    /**\\n     * We stay close to the algorithm at\\n     * https://tc39.github.io/ecma262/#sec-json.parse , where\\n     * fullRevive(harden(JSON.parse(str))) is like JSON.parse(str, revive))\\n     * for a similar reviver. But with the following differences:\\n     *\\n     * Rather than pass a reviver to JSON.parse, we first call a plain\\n     * (one argument) JSON.parse to get rawTree, and then post-process\\n     * the rawTree with fullRevive. The kind of revive function\\n     * handled by JSON.parse only does one step in post-order, with\\n     * JSON.parse doing the recursion. By contrast, fullParse does its\\n     * own recursion, enabling it to interpret ibids in the same\\n     * pre-order in which the replacer visited them, and enabling it\\n     * to break cycles.\\n     *\\n     * In order to break cycles, the potentially cyclic objects are\\n     * not frozen during the recursion. Rather, the whole graph is\\n     * hardened before being returned. Error objects are not\\n     * potentially recursive, and so may be harmlessly hardened when\\n     * they are produced.\\n     *\\n     * fullRevive can produce properties whose value is undefined,\\n     * which a JSON.parse on a reviver cannot do. If a reviver returns\\n     * undefined to JSON.parse, JSON.parse will delete the property\\n     * instead.\\n     *\\n     * fullRevive creates and returns a new graph, rather than\\n     * modifying the original tree in place.\\n     *\\n     * fullRevive may rely on rawTree being the result of a plain call\\n     * to JSON.parse. However, it *cannot* rely on it having been\\n     * produced by JSON.stringify on the replacer above, i.e., it\\n     * cannot rely on it being a valid marshalled\\n     * representation. Rather, fullRevive must validate that.\\n     *\\n     * @param {Encoding} rawTree must be hardened\\n     */\\n    function fullRevive(rawTree) {\\n      if (Object(rawTree) !== rawTree) {\\n        /* primitives pass through*/\\n        return rawTree;}\\n\\n      /* Assertions of the above to narrow the type.*/\\n      assert.assert.typeof(rawTree, 'object');\\n      assert.assert(rawTree !== null);\\n      if (QCLASS in rawTree) {\\n        const qclass = rawTree[QCLASS];\\n        assert.assert.typeof(\\n        qclass,\\n        'string',\\n        assert.details`invalid qclass typeof ${assert.quote(typeof qclass)}`);\\n\\n        assert.assert(!Array.isArray(rawTree));\\n        /* Switching on `encoded[QCLASS]` (or anything less direct, like*/\\n        /* `qclass`) does not discriminate rawTree in typescript@4.2.3 and*/\\n        /* earlier.*/\\n        switch (rawTree['@qclass']) {\\n          /* Encoding of primitives not handled by JSON*/\\n          case 'undefined':{\\n              return undefined;}\\n\\n          case 'NaN':{\\n              return NaN;}\\n\\n          case 'Infinity':{\\n              return Infinity;}\\n\\n          case '-Infinity':{\\n              return -Infinity;}\\n\\n          case 'bigint':{\\n              const { digits } = rawTree;\\n              assert.assert.typeof(\\n              digits,\\n              'string',\\n              assert.details`invalid digits typeof ${assert.quote(typeof digits)}`);\\n\\n              return BigInt(digits);}\\n\\n          case '@@asyncIterator':{\\n              return Symbol.asyncIterator;}\\n\\n\\n          case 'ibid':{\\n              const { index } = rawTree;\\n              return ibidTable.get(index);}\\n\\n\\n          case 'error':{\\n              const { name, message, errorId } = rawTree;\\n              assert.assert.typeof(\\n              name,\\n              'string',\\n              assert.details`invalid error name typeof ${assert.quote(typeof name)}`);\\n\\n              assert.assert.typeof(\\n              message,\\n              'string',\\n              assert.details`invalid error message typeof ${assert.quote(typeof message)}`);\\n\\n              const EC = getErrorConstructor(`${name}`) || Error;\\n              const error = harden(new EC(`${message}`));\\n              ibidTable.register(error);\\n              if (typeof errorId === 'string') {\\n                /* errorId is a late addition so be tolerant of its absence.*/\\n                assert.assert.note(error, assert.details`Received as ${errorId}`);}\\n\\n              return error;}\\n\\n\\n          case 'slot':{\\n              const { index, iface } = rawTree;\\n              const slot = slots[Number(nat_esm.Nat(index))];\\n              return ibidTable.register(convertSlotToVal(slot, iface));}\\n\\n\\n          case 'hilbert':{\\n              const { original, rest } = rawTree;\\n              assert.assert(\\n              'original' in rawTree,\\n              assert.details`Invalid Hilbert Hotel encoding ${rawTree}`);\\n\\n              const result = ibidTable.start({});\\n              result[QCLASS] = fullRevive(original);\\n              if ('rest' in rawTree) {\\n                assert.assert(\\n                rest !== undefined,\\n                assert.details`Rest encoding must not be undefined`);\\n\\n                const restObj = fullRevive(rest);\\n                /* TODO really should assert that `passStyleOf(rest)` is*/\\n                /* `'copyRecord'` but we'd have to harden it and it is too*/\\n                /* early to do that.*/\\n                assert.assert(\\n                !(QCLASS in restObj),\\n                assert.details`Rest must not contain its own definition of ${assert.quote(QCLASS)}`);\\n\\n                defineProperties(result, getOwnPropertyDescriptors(restObj));}\\n\\n              return ibidTable.finish(result);}\\n\\n\\n          default:{\\n              assert.assert.fail(assert.details`unrecognized ${assert.quote(QCLASS)} ${assert.quote(qclass)}`, TypeError);}}} else\\n\\n\\n      if (Array.isArray(rawTree)) {\\n        const { length } = rawTree;\\n        const result = ibidTable.start([]);\\n        for (let i = 0; i < length; i += 1) {\\n          result[i] = fullRevive(rawTree[i]);}\\n\\n        return ibidTable.finish(result);} else\\n      {\\n        const result = ibidTable.start({});\\n        for (const name of ownKeys(rawTree)) {\\n          assert.assert.typeof(\\n          name,\\n          'string',\\n          assert.details`Property ${name} of ${rawTree} must be a string`);\\n\\n          result[name] = fullRevive(rawTree[name]);}\\n\\n        return ibidTable.finish(result);}}\\n\\n\\n    return fullRevive;}\\n\\n\\n  /**\\n   * @template Slot\\n   * @type {Unserialize<Slot>}\\n   */\\n  function unserialize(data, cyclePolicy = 'forbidCycles') {\\n    assert.assert.typeof(\\n    data.body,\\n    'string',\\n    assert.details`unserialize() given non-capdata (.body is ${data.body}, not string)`);\\n\\n    assert.assert(\\n    Array.isArray(data.slots),\\n    assert.details`unserialize() given non-capdata (.slots are not Array)`);\\n\\n    const rawTree = harden(JSON.parse(data.body));\\n    const fullRevive = makeFullRevive(data.slots, cyclePolicy);\\n    return harden(fullRevive(rawTree));}\\n\\n\\n  return harden({\\n    serialize,\\n    unserialize });}\\n\\n\\n\\n/**\\n * Create and register a Remotable.  After this, getInterfaceOf(remotable)\\n * returns iface.\\n *\\n * // https://github.com/Agoric/agoric-sdk/issues/804\\n *\\n * @param {InterfaceSpec} [iface='Remotable'] The interface specification for\\n * the remotable. For now, a string iface must be \\\"Remotable\\\" or begin with\\n * \\\"Alleged: \\\", to serve as the alleged name. More general ifaces are not yet\\n * implemented. This is temporary. We include the\\n * \\\"Alleged\\\" as a reminder that we do not yet have SwingSet or Comms Vat\\n * support for ensuring this is according to the vat hosting the object.\\n * Currently, Alice can tell Bob about Carol, where VatA (on Alice's behalf)\\n * misrepresents Carol's `iface`. VatB and therefore Bob will then see\\n * Carol's `iface` as misrepresented by VatA.\\n * @param {undefined} [props=undefined] Currently may only be undefined.\\n * That plan is that own-properties are copied to the remotable\\n * @param {object} [remotable={}] The object used as the remotable\\n * @returns {object} remotable, modified for debuggability\\n */\\nconst Remotable = (iface = 'Remotable', props = undefined, remotable = {}) => {\\n  /* TODO unimplemented*/\\n  assert.assert.typeof(\\n  iface,\\n  'string',\\n  assert.details`Interface ${iface} must be a string; unimplemented`);\\n\\n  /* TODO unimplemented*/\\n  assert.assert(\\n  iface === 'Remotable' || iface.startsWith('Alleged: '),\\n  assert.details`For now, iface ${assert.quote(\\n  iface)\\n  } must be \\\"Remotable\\\" or begin with \\\"Alleged: \\\"; unimplemented`);\\n\\n  iface = pureCopy(harden(iface));\\n  /* TODO: When iface is richer than just string, we need to get the allegedName*/\\n  /* in a different way.*/\\n  const allegedName = iface;\\n  assert.assert(props === undefined, assert.details`Remotable props not yet implemented ${props}`);\\n\\n  /* Fail fast: check that the unmodified object is able to become a Remotable.*/\\n  assertCanBeRemotable(remotable);\\n\\n  /* Ensure that the remotable isn't already marked.*/\\n  assert.assert(\\n  !(PASS_STYLE in remotable),\\n  assert.details`Remotable ${remotable} is already marked as a ${assert.quote(\\n  remotable[PASS_STYLE])\\n  }`);\\n\\n  /* Ensure that the remotable isn't already frozen.*/\\n  assert.assert(!isFrozen(remotable), assert.details`Remotable ${remotable} is already frozen`);\\n  const remotableProto = makeRemotableProto(\\n  getPrototypeOf(remotable),\\n  allegedName);\\n\\n\\n  /* Take a static copy of the enumerable own properties as data properties.*/\\n  /* const propDescs = getOwnPropertyDescriptors({ ...props });*/\\n  const mutateHardenAndCheck = target => {\\n    /* defineProperties(target, propDescs);*/\\n    setPrototypeOf(target, remotableProto);\\n    harden(target);\\n    assertCanBeRemotable(target);};\\n\\n\\n  /* Fail fast: check a fresh remotable to see if our rules fit.*/\\n  mutateHardenAndCheck({});\\n\\n  /* Actually finish the new remotable.*/\\n  mutateHardenAndCheck(remotable);\\n\\n  /* COMMITTED!*/\\n  /* We're committed, so keep the interface for future reference.*/\\n  assert.assert(iface !== undefined); /* To make TypeScript happy*/\\n  return remotable;};\\n\\n\\nharden(Remotable);\\n\\n\\n/**\\n * A concise convenience for the most common `Remotable` use.\\n *\\n * @param {string} farName This name will be prepended with `Alleged: `\\n * for now to form the `Remotable` `iface` argument.\\n * @param {object} [remotable={}] The object used as the remotable\\n * @returns {object} remotable, modified for debuggability\\n */\\nconst Far = (farName, remotable = {}) =>\\nRemotable(`Alleged: ${farName}`, undefined, remotable);\\n\\nharden(Far);exports.Far = Far;exports.QCLASS = QCLASS;exports.REMOTE_STYLE = REMOTE_STYLE;exports.Remotable = Remotable;exports.getErrorConstructor = getErrorConstructor;exports.getInterfaceOf = getInterfaceOf;exports.makeMarshal = makeMarshal;exports.passStyleOf = passStyleOf;exports.pureCopy = pureCopy;exports.sameValueZero = sameValueZero;\",\n  \"marshal/src/marshal-stringify.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');require('./types.js');var\\n\\n\\n\\n\\n\\n\\nmarshal = require('./marshal.js'); /* @ts-check*/ /** @type {ConvertValToSlot<any>} */\\nconst doNotConvertValToSlot = (val) =>\\nassert.assert.fail(assert.details`Marshal's stringify rejects presences and promises ${val}`);\\n\\n/** @type {ConvertSlotToVal<any>} */\\nconst doNotConvertSlotToVal = (slot, _iface) =>\\nassert.assert.fail(assert.details`Marshal's parse must not encode any slots ${slot}`);\\n\\nconst badArrayHandler = harden({\\n  get: (_target, name, _receiver) => {\\n    if (name === 'length') {\\n      return 0;}\\n\\n    assert.assert.fail(assert.details`Marshal's parse must not encode any slot positions ${name}`);} });\\n\\n\\n\\nconst badArray = harden(new Proxy(harden([]), badArrayHandler));\\n\\nconst { serialize, unserialize } = marshal.makeMarshal(\\ndoNotConvertValToSlot,\\ndoNotConvertSlotToVal,\\n{ errorTagging: 'off' });\\n\\n\\n/**\\n * @param {OnlyData} val\\n * @returns {string}\\n */\\nconst stringify = val => serialize(val).body;\\nharden(stringify);\\n\\n/**\\n * @param {string} str\\n * @returns {OnlyData}\\n */\\nconst parse = (str) =>\\nunserialize(\\nharden({\\n  body: str,\\n  slots: badArray }));\\n\\n\\nharden(parse);exports.parse = parse;exports.stringify = stringify;\",\n  \"marshal/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var marshal = require('./src/marshal.js');var marshalStringify = require('./src/marshal-stringify.js');exports.Far = marshal.Far;exports.QCLASS = marshal.QCLASS;exports.REMOTE_STYLE = marshal.REMOTE_STYLE;exports.Remotable = marshal.Remotable;exports.getErrorConstructor = marshal.getErrorConstructor;exports.getInterfaceOf = marshal.getInterfaceOf;exports.makeMarshal = marshal.makeMarshal;exports.passStyleOf = marshal.passStyleOf;exports.pureCopy = marshal.pureCopy;exports.sameValueZero = marshal.sameValueZero;exports.parse = marshalStringify.parse;exports.stringify = marshalStringify.stringify;\",\n  \"zoe/src/contractFacet/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {any} Completion\\n * Any passable non-thenable. Often an explanatory string.\\n *\\n * @typedef {Error|any} TerminationReason\\n * Something provided as an explanation to a termination request. Usually an\\n * Error but not required to be so.\\n */ /**\\n * @callback ZCFMakeEmptySeatKit\\n * @param {ExitRule=} exit\\n * @returns {ZCFSeatKit}\\n */ /**\\n * @callback GetAmountMath\\n * @param {Brand} brand\\n * @returns {DeprecatedAmountMath}\\n */ /**\\n * @typedef {Object} ContractFacet\\n *\\n * The Zoe interface specific to a contract instance. The Zoe Contract\\n * Facet is an API object used by running contract instances to access\\n * the Zoe state for that instance. The Zoe Contract Facet is accessed\\n * synchronously from within the contract, and usually is referred to\\n * in code as zcf.\\n *\\n * @property {Reallocate} reallocate - reallocate amounts among seats\\n * @property {(keyword: Keyword) => void} assertUniqueKeyword - check\\n * whether a keyword is valid and unique and could be added in\\n * `saveIssuer`\\n * @property {SaveIssuer} saveIssuer - save an issuer to ZCF and Zoe\\n * and get the amountMath and brand synchronously accessible after\\n * saving\\n * @property {MakeInvitation} makeInvitation\\n * @property {(completion: Completion) => void} shutdown\\n * @property {(reason: TerminationReason) => void} shutdownWithFailure\\n * @property {Assert} assert\\n * @property {() => ZoeService} getZoeService\\n * @property {() => Issuer} getInvitationIssuer\\n * @property {() => Terms} getTerms\\n * @property {(issuer: Issuer) => Brand} getBrandForIssuer\\n * @property {(brand: Brand) => Issuer} getIssuerForBrand\\n * @property {GetAmountMath} getAmountMath\\n * @property {(brand: Brand) => AmountMathKind} getMathKind\\n * @property {MakeZCFMint} makeZCFMint\\n * @property {ZCFMakeEmptySeatKit} makeEmptySeatKit\\n * @property {SetTestJig} setTestJig\\n * @property {() => void} stopAcceptingOffers\\n */ /**\\n * @typedef {(seatStaging1: SeatStaging, seatStaging2: SeatStaging,\\n * ...seatStagingRest: Array<SeatStaging>) => void} Reallocate\\n *\\n * The contract can reallocate over seatStagings, which are\\n * associations of seats with reallocations.\\n *\\n * The reallocation will only succeed if the reallocation 1) conserves\\n * rights (the amounts specified have the same total value as the\\n * current total amount), and 2) is 'offer-safe' for all parties\\n * involved. Offer safety is checked at the staging step.\\n *\\n * The reallocation is partial, meaning that it applies only to the\\n * seats associated with the seatStagings. By induction, if rights\\n * conservation and offer safety hold before, they will hold after a\\n * safe reallocation, even though we only re-validate for the seats\\n * whose allocations will change. Since rights are conserved for the\\n * change, overall rights will be unchanged, and a reallocation can\\n * only effect offer safety for seats whose allocations change.\\n */ /**\\n * @callback SaveIssuer\\n *\\n * Informs Zoe about an issuer and returns a promise for acknowledging\\n * when the issuer is added and ready.\\n *\\n * @param {ERef<Issuer>} issuerP Promise for issuer\\n * @param {Keyword} keyword Keyword for added issuer\\n * @returns {Promise<IssuerRecord>} Issuer is added and ready\\n */ /**\\n * @callback MakeInvitation\\n *\\n * Make a credible Zoe invitation for a particular smart contract\\n * indicated by the `instance` in the details of the invitation. Zoe\\n * also puts the `installation` and a unique `handle` in the details of\\n * the invitation. The contract must provide a `description` for the\\n * invitation and should include whatever information is\\n * necessary for a potential buyer of the invitation to know what they are\\n * getting in the `customProperties`. `customProperties` will be\\n * placed in the details of the invitation.\\n *\\n * @param {OfferHandler=} offerHandler - a contract specific function\\n * that handles the offer, such as saving it or performing a trade\\n * @param {string} description\\n * @param {Object=} customProperties\\n * @returns {Promise<Invitation>}\\n */ /**\\n * @callback MakeZCFMint\\n * @param {Keyword} keyword\\n * @param {AmountMathKind=} amountMathKind\\n * @param {DisplayInfo=} displayInfo\\n * @returns {Promise<ZCFMint>}\\n */ /**\\n * @callback SetTestJig\\n * @param {() => any} testFn\\n * @returns {void}\\n */ /**\\n * @callback ZCFMintMintGains\\n * @param {AmountKeywordRecord} gains\\n * @param {ZCFSeat=} zcfSeat\\n * @returns {ZCFSeat}\\n */ /**\\n * @typedef {Object} ZCFMint\\n * @property {() => IssuerRecord} getIssuerRecord\\n * @property {ZCFMintMintGains} mintGains\\n * All the amounts in gains must be of this ZCFMint's brand.\\n * The gains' keywords are in the namespace of that seat.\\n * Add the gains to that seat's allocation.\\n * The resulting state must be offer safe. (Currently, increasing assets can\\n * never violate offer safety anyway.)\\n *\\n * Mint that amount of assets into the pooled purse.\\n * If a seat is provided, it is returned. Otherwise a new seat is\\n * returned.\\n * TODO unimplemented\\n * This creation-on-demand is not yet implemented.\\n *\\n * @property {(losses: AmountKeywordRecord,\\n *             zcfSeat: ZCFSeat,\\n *            ) => void} burnLosses\\n * All the amounts in losses must be of this ZCFMint's brand.\\n * The losses' keywords are in the namespace of that seat.\\n * Subtract losses from that seat's allocation.\\n * The resulting state must be offer safe.\\n *\\n * Burn that amount of assets from the pooled purse.\\n */ /**\\n * @callback ZCFSeatFail\\n *\\n * fail called with the reason for this failure, where reason is\\n * normally an instanceof Error.\\n * @param {Error=} reason\\n * @returns {Error}\\n */ /**\\n * @callback ZCFSeatKickOut\\n *\\n * called with the reason for this failure,\\n * where reason is normally an instanceof Error. This method is\\n * deprecated as of 0.9.1-dev.3 in favor of fail().\\n * @param {Error=} reason\\n * @returns {Error}\\n */ /**\\n * @callback ZCFGetAmountAllocated\\n * The brand is used for filling in an empty amount if the `keyword`\\n * is not present in the allocation\\n * @param {Keyword} keyword\\n * @param {Brand=} brand\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} ZCFSeat\\n * @property {() => void} exit\\n * @property {ZCFSeatFail} fail\\n * @property {ZCFSeatKickOut} kickOut\\n * @property {() => Notifier<Allocation>} getNotifier\\n * @property {() => boolean} hasExited\\n * @property {() => ProposalRecord} getProposal\\n * @property {ZCFGetAmountAllocated} getAmountAllocated\\n * @property {() => Allocation} getCurrentAllocation\\n * @property {(newAllocation: Allocation) => boolean} isOfferSafe\\n * @property {(newAllocation: Allocation) => SeatStaging} stage\\n */ /**\\n * @typedef {Object} SeatStaging\\n * @property {() => ZCFSeat} getSeat\\n * @property {() => Allocation} getStagedAllocation\\n */ /**\\n * @typedef {{ zcfSeat: ZCFSeat, userSeat: ERef<UserSeat>}} ZcfSeatKit\\n */ /**\\n * @callback OfferHandler\\n * @param {ZCFSeat} seat\\n * @returns any\\n */ /**\\n * @callback ContractStartFn\\n * @param {ContractFacet} zcf\\n * @returns {ContractStartFnResult}\\n */ /**\\n * @typedef {Object} ContractStartFnResult\\n * @property {Object=} creatorFacet\\n * @property {Promise<Invitation>=} creatorInvitation\\n * @property {Object=} publicFacet\\n */\",\n  \"zoe/src/zoeService/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {Object} ZoeService\\n *\\n * Zoe provides a framework for deploying and working with smart\\n * contracts. It is accessed as a long-lived and well-trusted service\\n * that enforces offer safety for the contracts that use it. Zoe has a\\n * single `invitationIssuer` for the entirety of its lifetime. By\\n * having a reference to Zoe, a user can get the `invitationIssuer`\\n * and thus validate any `invitation` they receive from someone else.\\n *\\n * Zoe has two different facets: the public Zoe service and the\\n * contract facet (ZCF). Each contract instance has a copy of ZCF\\n * within its vat. The contract and ZCF never have direct access to\\n * the users' payments or the Zoe purses.\\n *\\n * @property {() => Issuer} getInvitationIssuer\\n *\\n * Zoe has a single `invitationIssuer` for the entirety of its\\n * lifetime. By having a reference to Zoe, a user can get the\\n * `invitationIssuer` and thus validate any `invitation` they receive\\n * from someone else. The mint associated with the invitationIssuer\\n * creates the ERTP payments that represent the right to interact with\\n * a smart contract in particular ways.\\n *\\n * @property {Install} install\\n * @property {StartInstance} startInstance\\n * @property {Offer} offer\\n * @property {(instance: Instance) => Object} getPublicFacet\\n * @property {(instance: Instance) => IssuerKeywordRecord} getIssuers\\n * @property {(instance: Instance) => BrandKeywordRecord} getBrands\\n * @property {(instance: Instance) => Object} getTerms\\n * @property {(invitation: ERef<Invitation>) => Promise<Instance>} getInstance\\n * @property {(invitation: ERef<Invitation>) => Promise<Installation>} getInstallation\\n * @property {(invitation: ERef<Invitation>) => Promise<InvitationDetails>}\\n * getInvitationDetails - return an object with the instance,\\n * installation, description, invitation handle, and any custom properties\\n * specific to the contract.\\n */ /**\\n * @callback Install\\n *\\n * Create an installation by safely evaluating the code and\\n * registering it with Zoe. Returns an installation.\\n *\\n * @param {SourceBundle} bundle\\n * @returns {Promise<Installation>}\\n */ /**\\n * @callback StartInstance\\n * Zoe is long-lived. We can use Zoe to create smart contract\\n * instances by specifying a particular contract installation to use,\\n * as well as the `terms` of the contract. The `terms.issuers` is a\\n * record mapping string names (keywords) to issuers, such as `{\\n * Asset: simoleanIssuer}`. (Note that the keywords must begin with a\\n * capital letter and must be ASCII identifiers.) Parties to the\\n * contract will use the keywords to index their proposal and their\\n * payments.\\n *\\n * The custom terms are the arguments to the contract, such as the\\n * number of bids an auction will wait for before closing. Custom\\n * terms are up to the discretion of the smart contract. We get back\\n * the creator facet, public facet, and creator invitation as defined\\n * by the contract.\\n *\\n * @param {ERef<Installation>} installation\\n * @param {IssuerKeywordRecord=} issuerKeywordRecord\\n * @param {Object=} terms\\n * @returns {Promise<StartInstanceResult>}\\n */ /**\\n * @callback Offer\\n *\\n * To redeem an invitation, the user normally provides a proposal (their\\n * rules for the offer) as well as payments to be escrowed by Zoe.  If\\n * either the proposal or payments would be empty, indicate this by\\n * omitting that argument or passing undefined, rather than passing an\\n * empty record.\\n *\\n * The proposal has three parts: `want` and `give` are used by Zoe to\\n * enforce offer safety, and `exit` is used to specify the particular\\n * payout-liveness policy that Zoe can guarantee. `want` and `give`\\n * are objects with keywords as keys and amounts as values.\\n * `paymentKeywordRecord` is a record with keywords as keys, and the\\n * values are the actual payments to be escrowed. A payment is\\n * expected for every rule under `give`.\\n *\\n * @param {ERef<Invitation>} invitation\\n * @param {Proposal=} proposal\\n * @param {PaymentPKeywordRecord=} paymentKeywordRecord\\n * @returns {Promise<UserSeat>} seat\\n */ /**\\n * @typedef {Object} UserSeat\\n * @property {() => Promise<Allocation>} getCurrentAllocation\\n * @property {() => Promise<ProposalRecord>} getProposal\\n * @property {() => Promise<PaymentPKeywordRecord>} getPayouts\\n * @property {(keyword: Keyword) => Promise<Payment>} getPayout\\n * @property {() => Promise<OfferResult>} getOfferResult\\n * @property {() => void=} tryExit\\n * @property {() => Promise<boolean>} hasExited\\n * @property {() => Promise<Notifier<Allocation>>} getNotifier\\n */ /**\\n * @typedef {any} OfferResult\\n */ /**\\n * @typedef {Object} AdminFacet\\n * @property {() => Promise<Completion>} getVatShutdownPromise\\n * @property {() => any} getVatStats\\n */ /**\\n * @typedef {Object} StartInstanceResult\\n * @property {any} creatorFacet\\n * @property {any} publicFacet\\n * @property {Instance} instance\\n * @property {Payment | undefined} creatorInvitation\\n * @property {AdminFacet} adminFacet\\n */ /**\\n * @typedef {Partial<ProposalRecord>} Proposal\\n *\\n * @typedef {{give: AmountKeywordRecord,\\n *            want: AmountKeywordRecord,\\n *            exit: ExitRule\\n *           }} ProposalRecord\\n */ /**\\n * @typedef {Record<Keyword,Amount>} AmountKeywordRecord\\n *\\n * The keys are keywords, and the values are amounts. For example:\\n * { Asset: amountMath.make(5n, assetBrand), Price:\\n * amountMath.make(9n, priceBrand) }\\n */ /**\\n * @typedef {Object} Waker\\n * @property {() => void} wake\\n */ /**\\n * @typedef {bigint} Deadline\\n */ /**\\n * @typedef {Object} Timer\\n * @property {(deadline: Deadline, wakerP: ERef<Waker>) => void} setWakeup\\n */ /**\\n * @typedef {Object} OnDemandExitRule\\n * @property {null} onDemand\\n */ /**\\n * @typedef {Object} WaivedExitRule\\n * @property {null} waived\\n */ /**\\n * @typedef {Object} AfterDeadlineExitRule\\n * @property {{timer:Timer, deadline:Deadline}} afterDeadline\\n */ /**\\n * @typedef {OnDemandExitRule | WaivedExitRule | AfterDeadlineExitRule} ExitRule\\n *\\n * The possible keys are 'waived', 'onDemand', and 'afterDeadline'.\\n * `timer` and `deadline` only are used for the `afterDeadline` key.\\n * The possible records are:\\n * `{ waived: null }`\\n * `{ onDemand: null }`\\n * `{ afterDeadline: { timer :Timer<Deadline>, deadline :Deadline } }\\n */ /**\\n * @typedef {Handle<'Instance'>} Instance\\n */ /**\\n * @typedef {Object} VatAdminSvc\\n * @property {(bundle: SourceBundle) => RootAndAdminNode} createVat\\n * @property {(BundleName: string) => RootAndAdminNode} createVatByName\\n */ /**\\n * @typedef {Record<string, any>} SourceBundle Opaque type for a JSONable source bundle\\n */ /**\\n * @typedef {Record<Keyword,ERef<Payment>>} PaymentPKeywordRecord\\n * @typedef {Record<Keyword,Payment>} PaymentKeywordRecord\\n */ /**\\n * @typedef {Object} StandardInvitationDetails\\n * @property {Installation} installation\\n * @property {Instance} instance\\n * @property {InvitationHandle} handle\\n * @property {string} description\\n */ /**\\n * @typedef {StandardInvitationDetails & Record<string, any>} InvitationDetails\\n */ /**\\n * @typedef {Object} Installation\\n * @property {() => SourceBundle} getBundle\\n */\",\n  \"zoe/src/contractSupport/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @callback Trade\\n * Trade between left and right so that left and right end up with\\n * the declared gains and losses.\\n * @param {ContractFacet} zcf\\n * @param {SeatGainsLossesRecord} left\\n * @param {SeatGainsLossesRecord} right\\n * @param {string} [leftHasExitedMsg] A custom error message if\\n * the left seat has been exited already\\n * @param {string} [rightHasExitedMsg] A custom error message if the\\n * right seat has been exited already\\n * @returns {void}\\n *\\n * @typedef {Object} SeatGainsLossesRecord\\n * @property {ZCFSeat} seat\\n * @property {AmountKeywordRecord} gains - what the seat will\\n * gain as a result of this trade\\n * @property {AmountKeywordRecord=} losses - what the seat will\\n * give up as a result of this trade. Losses is optional, but can\\n * only be omitted if the keywords for both seats are the same.\\n * If losses is not defined, the gains of the other seat is\\n * subtracted.\\n */ /**\\n * @callback Swap\\n * If two seats can satisfy each other's wants, trade enough to\\n * satisfy the wants of both seats and exit both seats.\\n *\\n * The surplus remains with the original seat. For example if seat A\\n * gives 5 moola and seat B only wants 3 moola, seat A retains 2\\n * moola.\\n *\\n * If leftSeat has exited already, both seats will fail\\n * with an error message (provided by 'leftHasExitedMsg'). Similarly,\\n * if rightSeat has exited already, both seats fail\\n * with an error message (provided by 'rightHasExitedMsg').\\n *\\n * If the swap fails, no assets are transferred, both seats will fail,\\n * and the function throws.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} leftSeat\\n * @param {ZCFSeat} rightSeat\\n * @param {string} [leftHasExitedMsg]\\n * @param {string} [rightHasExitedMsg]\\n * @returns {string}\\n */ /**\\n * @typedef {Object} OfferToReturns\\n *\\n * The return value of offerTo is a promise for the userSeat for the\\n * offer to the other contract, and a promise (`deposited`) which\\n * resolves when the payout for the offer has been deposited to the `toSeat`\\n * @property {Promise<UserSeat>} userSeatPromise\\n * @property {Promise<AmountKeywordRecord>} deposited\\n */ /**\\n * @typedef {Record<Keyword,Keyword>} KeywordKeywordRecord\\n *\\n * A mapping of keywords to keywords.\\n */ /**\\n * @callback OfferTo\\n *\\n * Make an offer to another contract instance (labeled contractB below),\\n * withdrawing the payments for the offer from a seat in the current\\n * contract instance (contractA) and depositing the payouts in another\\n * seat in the current contract instance (contractA).\\n *\\n * @param {ContractFacet} zcf\\n *   Zoe Contract Facet for contractA\\n *\\n * @param {ERef<Invitation>} invitation\\n *   Invitation to contractB\\n *\\n * @param {KeywordKeywordRecord=} keywordMapping\\n *   Mapping of keywords used in contractA to keywords to be used in\\n *   contractB. Note that the pathway to deposit the payout back to\\n *   contractA reverses this mapping.\\n *\\n * @param {Proposal} proposal\\n *   The proposal for the offer to be made to contractB\\n *\\n * @param {ZCFSeat} fromSeat\\n *   The seat in contractA to take the offer payments from.\\n *\\n * @param {ZCFSeat=} toSeat\\n *   The seat in contractA to deposit the payout of the offer to.\\n *   If `toSeat` is not provided, this defaults to the `fromSeat`.\\n *\\n * @returns {OfferToReturns}\\n */ /**\\n * @callback Reverse\\n *\\n * Given a mapping of keywords to keywords, invert the keys and\\n * values. This is used to map the offers made to another contract\\n * back to the keywords used in the first contract.\\n * @param {KeywordKeywordRecord=} keywordRecord\\n * @returns {KeywordKeywordRecord }\\n */ /**\\n * @callback MapKeywords\\n *\\n * Remap the keywords of an amountKeywordRecord or a\\n * PaymentPKeywordRecord according to a mapping. This is used to remap\\n * from keywords used in contractA to keywords used in contractB and\\n * vice versa in `offerTo`\\n *\\n * @param {AmountKeywordRecord | PaymentPKeywordRecord | undefined }\\n * keywordRecord\\n * @param {KeywordKeywordRecord} keywordMapping\\n */ /**\\n * @typedef {Object} Ratio\\n * @property {Amount} numerator\\n * @property {Amount} denominator\\n */ /**\\n * @callback MakeRatio\\n * @param {bigint} numerator\\n * @param {Brand} numeratorBrand\\n * @param {bigint=} denominator The default denomiator is 100\\n * @param {Brand=} denominatorBrand The default is to reuse the numeratorBrand\\n * @returns {Ratio}\\n */ /**\\n * @callback MakeRatioFromAmounts\\n * @param {Amount} numerator\\n * @param {Amount} denominator\\n * @returns {Ratio}\\n */ /**\\n * @callback MultiplyBy\\n * @param {Amount} amount\\n * @param {Ratio} ratio\\n * @returns {amount}\\n */ /**\\n * @callback DivideBy\\n * @param {Amount} amount\\n * @param {Ratio} ratio\\n * @returns {amount}\\n */ /**\\n * @callback InvertRatio\\n * @param {Ratio} ratio\\n * @returns {Ratio}\\n */\",\n  \"zoe/src/contracts/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} SellItemsPublicFacet\\n * @property {() => Issuer} getItemsIssuer\\n * @property {() => Amount} getAvailableItems\\n *\\n * @typedef {Object} SellItemsCreatorOnly\\n * @property {() => Promise<Invitation>} makeBuyerInvitation\\n *\\n * @typedef {SellItemsPublicFacet & SellItemsCreatorOnly} SellItemsCreatorFacet\\n */ /**\\n * @typedef {Object} SellItemsParameters\\n * @property {Record<string, any>} customValueProperties\\n * @property {bigint} count\\n * @property {Issuer} moneyIssuer\\n * @property {Installation} sellItemsInstallation\\n * @property {Amount} pricePerItem\\n *\\n * @typedef {Object} SellItemsResult\\n * @property {UserSeat} sellItemsCreatorSeat\\n * @property {SellItemsCreatorFacet} sellItemsCreatorFacet\\n * @property {Instance} sellItemsInstance\\n * @property {SellItemsPublicFacet} sellItemsPublicFacet\\n *\\n * @typedef {Object} MintAndSellNFTCreatorFacet\\n * @property {(sellParams: SellItemsParameters) => Promise<SellItemsResult>} sellTokens\\n * @property {() => Issuer} getIssuer\\n */ /**\\n * @typedef {Object} AutomaticRefundPublicFacet\\n * @property {() => bigint} getOffersCount\\n * @property {() => Promise<Invitation>} makeInvitation\\n */ /**\\n * @typedef {Object} SimpleExchangePublicFacet\\n * @property {() => Promise<Invitation>} makeInvitation\\n * @property {() => Notifier<any>} getNotifier\\n */\",\n  \"zoe/src/contracts/loan/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Notifier<Timestamp>} PeriodNotifier\\n *\\n *  The Notifier that provides notifications that periods have passed.\\n *  Since notifiers can't be relied on to produce an output every time\\n *  they should, we'll track the time of last payment, and catch up if\\n *  any times have been missed. Compound interest will be calculated\\n *  using the interestRate.\\n */ /**\\n * @typedef {Instance} AutoswapInstance\\n *   The running contract instance for an Autoswap or Multipool\\n *   Autoswap installation.  The publicFacet from the Autoswap\\n *   instance is used for producing an invitation to sell the\\n *   collateral on liquidation.\\n */ /**\\n * @typedef LoanTerms\\n *\\n * @property {Ratio} mmr - Maintenance Margin Requirement, a Ratio record.\\n * Default is 150%\\n *\\n * @property {AutoswapInstance} autoswapInstance\\n *\\n * @property {PriceAuthority} priceAuthority\\n *\\n *   Used for getting the current value of collateral and setting\\n *   liquidation triggers.\\n *\\n * @property {PeriodNotifier} periodNotifier\\n *\\n * @property {Ratio} interestRate\\n *   The rate in basis points that will be multiplied with the debt on\\n *   every period to compound interest.\\n *\\n * @property {RelativeTime} interestPeriod\\n *\\n * @property {Brand} loanBrand\\n * @property {Brand} collateralBrand\\n */ /**\\n * @typedef LenderSeatProperty\\n * @property {ZCFSeat} lenderSeat\\n *\\n *   The ZCFSeat representing the lender's position in the contract.\\n */ /**\\n * @typedef {LoanTerms & LenderSeatProperty} LoanConfigWithLender\\n *\\n * The loan now has a lenderSeat, which is added to the config.\\n */ /**\\n * @typedef BorrowerConfigProperties\\n *\\n * @property {ZCFSeat} collateralSeat\\n *\\n *   The ZCFSeat holding the collateral in escrow after the borrower\\n *   escrows it\\n *\\n * @property {() => Amount} getDebt\\n *\\n *   A function to get the current debt\\n *\\n * @property {PromiseRecord<PriceQuote>} liquidationPromiseKit\\n *\\n *   PromiseKit that includes a promise that resolves to a PriceQuote\\n *   when liquidation is triggered\\n */ /**\\n * @typedef BorrowerConfigPropertiesMinusDebt\\n *\\n * @property {ZCFSeat} collateralSeat\\n *\\n *   The ZCFSeat holding the collateral in escrow after the borrower\\n *   escrows it\\n *\\n * @property {PromiseRecord<PriceQuote>} liquidationPromiseKit\\n *\\n *   PromiseKit that includes a promise that resolves to a PriceQuote\\n *   when liquidation is triggered\\n */ /**\\n * @typedef {LoanConfigWithLender & BorrowerConfigProperties } LoanConfigWithBorrower\\n *\\n * The loan has a lender, a borrower, and collateral escrowed.\\n */ /**\\n * @typedef {LoanConfigWithLender & BorrowerConfigPropertiesMinusDebt\\n * } LoanConfigWithBorrowerMinusDebt\\n */ /**\\n * @callback ScheduleLiquidation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n */ /**\\n * @callback MakeLendInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanTerms} config\\n * @returns {Promise<Invitation>} lendInvitation\\n */ /**\\n * @callback MakeBorrowInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithLender} config\\n * @returns {Promise<Invitation>} borrowInvitation\\n */ /**\\n * @callback MakeCloseLoanInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {Promise<Invitation>} closeLoanInvitation\\n */ /**\\n * Allows holder to add collateral to the contract. Exits the seat\\n * after adding.\\n *\\n * @callback MakeAddCollateralInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {Promise<Invitation>} addCollateralInvitation\\n */ /**\\n * @callback Liquidate\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {void}\\n */ /**\\n * @callback MakeDebtCalculator\\n * @param {DebtCalculatorConfig} debtCalculatorConfig\\n */ /**\\n * @callback CalcInterestFn\\n * @param {Amount} oldDebt\\n * @param {Ratio} interestRate\\n * @returns {Amount} interest\\n */ /**\\n * @typedef {Object} DebtCalculatorConfig\\n * @property {CalcInterestFn} calcInterestFn\\n *\\n *   A function to calculate the interest, given the debt value and an\\n *   interest rate in basis points.\\n *\\n * @property {Amount} originalDebt\\n *\\n *   The debt at the start of the loan, in Loan brand\\n *\\n * @property {PeriodNotifier} periodNotifier\\n *\\n *   The AsyncIterable to notify when a period has occurred\\n *\\n * @property {Ratio} interestRate\\n * @property {RelativeTime} interestPeriod\\n *\\n *  the period at which the outstanding debt increases by the interestRate\\n *\\n * @property {ContractFacet} zcf\\n *\\n * @property {LoanConfigWithBorrowerMinusDebt} configMinusGetDebt\\n * @property {Timestamp} basetime The starting point from which to calculate\\n * interest.\\n */ /**\\n * @typedef {Object} ConfigMinusGetDebt\\n * @property {ZCFSeat} collateralSeat\\n * @property {PromiseRecord<any>} liquidationPromiseKit\\n * @property {bigint} [mmr]\\n * @property {Handle<'Instance'>} autoswapInstance\\n * @property {PriceAuthority} priceAuthority\\n * @property {PeriodNotifier} periodNotifier\\n * @property {bigint} interestRate\\n * @property {RelativeTime} interestPeriod\\n * @property {ZCFSeat} lenderSeat\\n */ /**\\n * @typedef {Object} BorrowFacet\\n *\\n * @property {() => Promise<Invitation>} makeCloseLoanInvitation\\n *\\n * Make an invitation to close the loan by repaying the debt\\n *   (including interest).\\n *\\n * @property {() => Promise<Invitation>} makeAddCollateralInvitation\\n *\\n * Make an invitation to add collateral to protect against liquidation\\n *\\n * @property {() => Promise<PriceQuote>} getLiquidationPromise\\n *\\n * Get a promise for a priceQuote that will resolve if liquidation\\n * occurs. The priceQuote is for the value of the collateral that\\n * triggered the liquidation. This may be lower than expected if the\\n * price is moving quickly.\\n *\\n * @property {() => Timestamp} getLastCalculationTimestamp\\n *\\n * Get the timestamp at which the debt was most recently recalculated.\\n *\\n * @property {() => Notifier<Amount>} getDebtNotifier\\n *\\n * Get a Notifier that will be updated when the current debt (an Amount with the Loan\\n * Brand) changes. This will increase as interest is added.\\n *\\n * @property {() => Amount} getRecentCollateralAmount\\n *\\n * Get a recent report of the amount of collateral in the loan\\n */\",\n  \"zoe/src/contracts/multipoolAutoswap/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} AutoswapPublicFacet\\n * @property {() => Promise<Invitation>} makeSwapInvitation synonym for\\n * makeSwapInInvitation\\n * @property {() => Promise<Invitation>} makeSwapInInvitation make an invitation\\n * that allows one to do a swap in which the In amount is specified and the Out\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeSwapOutInvitation make an invitation\\n * that allows one to do a swap in which the Out amount is specified and the In\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeAddLiquidityInvitation make an\\n * invitation that allows one to add liquidity to the pool.\\n * @property {() => Promise<Invitation>} makeRemoveLiquidityInvitation make an\\n * invitation that allows one to remove liquidity from the pool.\\n * @property {() => Issuer} getLiquidityIssuer\\n * @property {() => bigint} getLiquiditySupply get the current value of\\n * liquidity held by investors.\\n * @property {(amountIn: Amount, brandOut: Brand) => Amount} getInputPrice\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price.\\n * @property {(amountOut: Amount, brandIn: Brand) => Amount} getOutputPrice\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price\\n * @property {() => Record<string, Amount>} getPoolAllocation get an\\n * AmountKeywordRecord showing the current balances in the pool.\\n */ /**\\n * @typedef {Object} PriceAmountPair\\n *\\n * @property {Amount} amountOut\\n * @property {Amount} amountIn\\n */ /**\\n * @typedef {Object} Pool\\n * @property {(inputAmount: Amount, outputBrand: Brand) => PriceAmountPair } getPriceGivenAvailableInput\\n * @property {(inputBrand: Brand, outputAmount: Amount) => PriceAmountPair } getPriceGivenRequiredOutput\\n * @property {() => bigint} getLiquiditySupply\\n * @property {() => Issuer} getLiquidityIssuer\\n * @property {(seat: ZCFSeat) => string} addLiquidity\\n * @property {(seat: ZCFSeat) => string} removeLiquidity\\n * @property {() => ZCFSeat} getPoolSeat\\n * @property {() => Amount} getSecondaryAmount\\n * @property {() => Amount} getCentralAmount\\n */ /**\\n * @typedef {Object} MultipoolAutoswapPublicFacet\\n * @property {(issuer: Issuer, keyword: Keyword) => Promise<Issuer>} addPool\\n * add a new liquidity pool\\n * @property {() => Promise<Invitation>} makeSwapInvitation synonym for\\n * makeSwapInInvitation\\n * @property {() => Promise<Invitation>} makeSwapInInvitation make an invitation\\n * that allows one to do a swap in which the In amount is specified and the Out\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeSwapOutInvitation make an invitation\\n * that allows one to do a swap in which the Out amount is specified and the In\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeAddLiquidityInvitation make an\\n * invitation that allows one to add liquidity to the pool.\\n * @property {() => Promise<Invitation>} makeRemoveLiquidityInvitation make an\\n * invitation that allows one to remove liquidity from the pool.\\n * @property {(brand: Brand) => Issuer} getLiquidityIssuer\\n * @property {(brand: Brand) => bigint} getLiquiditySupply get the current value of\\n * liquidity in the pool for brand held by investors.\\n * @property {(amountIn: Amount, brandOut: Brand) => Amount} getInputPrice\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price.\\n * @property {(amountOut: Amount, brandIn: Brand) => Amount} getOutputPrice\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price\\n * @property {(amountIn: Amount, brandOut: Brand) => PriceAmountPair} getPriceGivenAvailableInput\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price. Include the minimum\\n * amountIn required to gain that much.\\n * @property {(amountOut: Amount, brandIn: Brand) => PriceAmountPair} getPriceGivenRequiredOutput\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price. Include the maximum amount\\n * of amountOut that can be gained for that amountIn.\\n * @property {(brand: Brand) => Record<string, Amount>} getPoolAllocation get an\\n * AmountKeywordRecord showing the current balances in the pool for brand.\\n */\",\n  \"zoe/src/contracts/priceAggregatorTypes.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} OracleAdmin\\n * @property {() => Promise<void>} delete Remove the oracle from the aggregator\\n * @property {(result: any) => Promise<void>} pushResult rather than waiting for\\n * the polling query, push a result directly from this oracle\\n */ /**\\n * @callback PriceAggregatorCreatorFacetInitOracle\\n * @param {Instance} oracleInstance\\n * @param {unknown=} query\\n * @returns {Promise<OracleAdmin>}\\n */ /**\\n * @typedef {Object} PriceAggregatorCreatorFacet\\n * @property {(quoteMint: Mint) => Promise<void>} initializeQuoteMint\\n * @property {PriceAggregatorCreatorFacetInitOracle} initOracle\\n */ /**\\n * @typedef {Object} PriceAggregatorPublicFacet\\n * @property {() => PriceAuthority} getPriceAuthority\\n */ /**\\n * @typedef {Object} PriceAggregatorKit\\n * @property {PriceAggregatorPublicFacet} publicFacet\\n * @property {PriceAggregatorCreatorFacet} creatorFacet\\n */ /**\\n * @typedef {Object} OraclePublicFacet the public methods accessible from the\\n * contract instance\\n * @property {(query: any) => ERef<Invitation>} makeQueryInvitation create an\\n * invitation for an oracle query\\n * @property {(query: any) => ERef<any>} query make an unpaid query\\n */ /**\\n * @callback OracleCreatorFacetMakeWithdrawInvitation\\n * @param {boolean=} total\\n * @returns {ERef<Invitation>}\\n */ /**\\n * @typedef {Object} OracleCreatorFacet the private methods accessible from the\\n * contract instance\\n * @property {() => AmountKeywordRecord} getCurrentFees get the current\\n * fee amounts\\n * @property {OracleCreatorFacetMakeWithdrawInvitation}\\n * makeWithdrawInvitation create an invitation to withdraw fees\\n * @property {() => Promise<Invitation>} makeShutdownInvitation\\n *   Make an invitation to withdraw all fees and shutdown\\n */ /**\\n * @typedef {Object} OraclePrivateParameters\\n * @property {OracleHandler} oracleHandler\\n */ /**\\n * @typedef {Object} OracleInitializationFacet\\n * @property {(privateParams: OraclePrivateParameters) => OracleCreatorFacet} initialize\\n */ /**\\n * @typedef {Object} OracleStartFnResult\\n * @property {OracleInitializationFacet} creatorFacet\\n * @property {OraclePublicFacet} publicFacet\\n * @property {Instance} instance\\n */ /**\\n * @typedef {Object} OracleKit\\n * @property {OracleCreatorFacet} creatorFacet\\n * @property {OraclePublicFacet} publicFacet\\n * @property {Instance} instance\\n */ /**\\n * @typedef {Object} OracleReply\\n * @property {any} reply\\n * @property {Amount} [requiredFee]\\n */ /**\\n * @typedef {Object} OracleHandler\\n * @property {(query: any, fee: Amount) => Promise<OracleReply>} onQuery\\n * callback to reply to a query\\n * @property {(query: any, reason: any) => void} onError notice an error\\n * @property {(query: any, reply: any, requiredFee: Amount | undefined) => void}\\n * onReply notice a successful reply\\n */\",\n  \"zoe/src/contracts/callSpread/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {'long' | 'short'} PositionKind\\n */ /**\\n * @callback MakeOptionInvitation\\n * @param {PositionKind} positionKind\\n * @returns {Promise<Payment>}\\n */ /**\\n * @typedef {Object} PayoffHandler\\n * @property {() => void} schedulePayoffs\\n * @property  {MakeOptionInvitation} makeOptionInvitation\\n */ /**\\n * @callback MakePayoffHandler\\n * @param {ContractFacet} zcf\\n * @param {Record<PositionKind,PromiseRecord<ZCFSeat>>} seatPromiseKits\\n * @param {ZCFSeat} collateralSeat\\n * @returns {PayoffHandler}\\n */ /**\\n * @callback Scale\\n * @param {Amount} amount\\n * @returns {Amount}\\n */ /**\\n * @callback MakePercent\\n * @param {bigint} value\\n * @param {Brand} brand\\n * @param {bigint=} base\\n * @returns {Percent}\\n */ /**\\n * @callback MakeCanonicalPercent\\n * @param {Brand} brand\\n * @returns {Percent}\\n */ /**\\n * @callback CalculatePercent\\n * @param {Amount} numerator\\n * @param {Amount} denominator\\n * @param {bigint=} base\\n * @returns {Percent}\\n */ /**\\n * @typedef {Object} Percent\\n * @property {Scale} scale\\n * @property {() => Percent} complement\\n * @property {() => Ratio} makeRatio\\n */ /**\\n * @typedef {Object} CalculateSharesReturn\\n * Return value from calculateShares, which represents the portions assigned to\\n * the long and short side of a transaction. These will be two non-negative\\n * integers that sum to 100.\\n * @property {Ratio} longShare\\n * @property {Ratio} shortShare\\n */ /**\\n * @callback CalculateShares\\n * calculate the portion (as a percentage) of the collateral that should be\\n * allocated to the long side of a call spread contract. price gives the value\\n * of the underlying asset at closing that determines the payouts to the parties\\n *\\n * if price <= strikePrice1, return Ratio representing 0\\n * if price >= strikePrice2, return Ratio representing 1.\\n * Otherwise return longShare and shortShare representing ratios between 0% and\\n * 100% reflecting the position of the price in the range from strikePrice1 to\\n * strikePrice2.\\n * @param {Brand} collateralBrand\\n * @param {Amount} price\\n * @param {Amount} strikePrice1\\n * @param {Amount} strikePrice2\\n * @returns {CalculateSharesReturn}\\n */ /**\\n * @callback oneMinus\\n * @param {Ratio} ratio\\n * @returns {Ratio}\\n */ /**\\n * @callback Make100Percent\\n * @param {Brand} brand\\n * @returns {Ratio}\\n */ /**\\n * @callback Make0Percent\\n * @param {Brand} brand\\n * @returns {Ratio}\\n */\",\n  \"zoe/src/contracts/exported.js\": \"'use strict';require('./types.js');require('./loan/types.js');require('./multipoolAutoswap/types.js');require('./priceAggregatorTypes.js');require('./callSpread/types.js');\",\n  \"zoe/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @template {string} H - the name of the handle\\n * @typedef {H & {}} Handle A type constructor for an opaque type\\n * identified by the H string. This uses an intersection type\\n * ('MyHandle' & {}) to tag the handle's type even though the actual\\n * value is just an empty object.\\n */ /**\\n * @typedef {string} Keyword\\n * @typedef {Handle<'Invitation'>} InvitationHandle - an opaque handle for an invitation\\n * @typedef {Record<Keyword,Issuer>} IssuerKeywordRecord\\n * @typedef {Record<Keyword,Brand>} BrandKeywordRecord\\n * @typedef {Record<Keyword, DeprecatedAmountMath>} DeprecatedAmountMathKeywordRecord\\n */ /**\\n * @typedef {Object} StandardTerms\\n * @property {IssuerKeywordRecord} issuers - record with\\n * keywords keys, issuer values\\n * @property {BrandKeywordRecord} brands - record with keywords\\n * keys, brand values\\n * @property {DeprecatedAmountMathKeywordRecord} maths - record with keywords\\n * keys, amountMath values\\n *\\n * @typedef {StandardTerms & Record<string, any>} Terms\\n *\\n * @typedef {object} InstanceRecord\\n * @property {Installation} installation\\n * @property {Terms} terms - contract parameters\\n *\\n * @typedef {Object} IssuerRecord\\n * @property {Brand} brand\\n * @property {Issuer} issuer\\n * @property {DeprecatedAmountMath} amountMath\\n * @property {AmountMathKind} mathKind\\n * @property {any} [displayInfo]\\n *\\n * @typedef {AmountKeywordRecord} Allocation\\n * @typedef {Record<Keyword,AmountMath>} AmountMathKeywordRecord\\n */ /**\\n * @typedef {Payment} Invitation\\n */\",\n  \"zoe/tools/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} PriceQuote\\n * @property {Amount} quoteAmount Amount whose value is a PriceQuoteValue\\n * @property {ERef<Payment> | null} quotePayment The `quoteAmount` wrapped as a payment\\n */ /**\\n * @typedef {[PriceDescription]} PriceQuoteValue A single-valued set of\\n * PriceDescriptions.  This is the `value` in PriceQuote.quoteAmount (`{ brand,\\n * value: PriceQuoteValue }`).\\n */ /**\\n * @typedef {Object} PriceDescription A description of a single quote\\n * @property {Amount} amountIn The amount supplied to a trade\\n * @property {Amount} amountOut The quoted result of trading `amountIn`\\n * @property {TimerService} timer The service that gave the `timestamp`\\n * @property {Timestamp} timestamp A timestamp according to `timer` for the\\n * quote\\n * @property {any=} conditions Additional conditions for the quote\\n */ /**\\n * @callback PriceQuoteCreate\\n * @param {PriceQuery} priceQuery\\n * @returns {ERef<PriceQuote> | undefined}\\n */ /**\\n * @callback PriceQuoteTrigger\\n * @param {PriceQuoteCreate} createQuote\\n */ /**\\n * @typedef {Object} PriceAuthorityAdmin\\n * @property {(createQuote: PriceQuoteCreate) => Promise<void>} fireTriggers\\n */ /**\\n * @typedef {Object} PriceAuthorityKit\\n * @property {PriceAuthority} priceAuthority\\n * @property {PriceAuthorityAdmin} adminFacet\\n */ /**\\n * @typedef {Object} PriceAuthority An object that mints PriceQuotes and handles\\n * triggers and notifiers for changes in the price\\n *\\n * @property {(brandIn: Brand, brandOut: Brand) => ERef<Issuer>} getQuoteIssuer\\n * Get the ERTP issuer of PriceQuotes for a given brandIn/brandOut pair\\n *\\n * @property {(brandIn: Brand, brandOut: Brand) => ERef<TimerService>}\\n * getTimerService get the timer used in PriceQuotes for a given\\n * brandIn/brandOut pair\\n *\\n * @property {(amountIn: Amount, brandOut: Brand) => ERef<Notifier<PriceQuote>>}\\n * makeQuoteNotifier Be notified of the latest PriceQuotes for a given\\n * `amountIn`.  The rate at which these are issued may be very different between\\n * `priceAuthorities`.\\n *\\n * @property {(deadline: Timestamp, amountIn: Amount, brandOut: Brand) =>\\n * Promise<PriceQuote>} quoteAtTime Resolves after `deadline` passes on the\\n * priceAuthority's timerService with the price quote of `amountIn` at that time\\n *\\n * @property {(amountIn: Amount, brandOut: Brand) => Promise<PriceQuote>}\\n * quoteGiven get a quote corresponding to the specified amountIn\\n *\\n * @property {(brandIn: Brand, amountOut: Amount) => Promise<PriceQuote>}\\n * quoteWanted get a quote corresponding to the specified amountOut\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenGT Resolve when a price quote of `amountIn` exceeds `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenGTE Resolve when a price quote of `amountIn` reaches or exceeds\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenLTE Resolve when a price quote of `amountIn` reaches or drops below\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenLT Resolve when the price quote of `amountIn` drops below\\n * `amountOutLimit`\\n */ /**\\n * @typedef {(amount: Amount) => Amount} PriceCalculator\\n */ /**\\n * @callback PriceQuery\\n * @param {PriceCalculator} calcAmountIn\\n * @param {PriceCalculator} calcAmountOut\\n * @returns {{ amountIn: Amount, amountOut: Amount, timestamp?: Timestamp }=}\\n */\",\n  \"notifier/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').ERef<T>} ERef\\n */ /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').PromiseRecord<T>} PromiseRecord\\n */ /**\\n * @template T\\n * @typedef {Object} IterationObserver<T>\\n * A valid sequence of calls to the methods of an `IterationObserver`\\n * represents an iteration. A valid sequence consists of any number of calls\\n * to `updateState` with the successive non-final values, followed by a\\n * final call to either `finish` with a successful `completion` value\\n * or `fail` with the alleged `reason` for failure. After at most one\\n * terminating calls, no further calls to these methods are valid and must be\\n * rejected.\\n * @property {(nonFinalValue: T) => void} updateState\\n * @property {(completion: T) => void} finish\\n * @property {(reason: any) => void} fail\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {number | undefined} UpdateCount a value used to mark the position\\n * in the update stream. For the last state, the updateCount is undefined.\\n */ /**\\n * @template T\\n * @typedef {Object} UpdateRecord<T>\\n * @property {T} value is whatever state the service wants to publish\\n * @property {UpdateCount} updateCount is a value that identifies the update\\n */ /**\\n * @template T\\n * @callback GetUpdateSince<T> Can be called repeatedly to get a sequence of\\n * update records\\n * @param {UpdateCount} [updateCount] return update record as of an update\\n * count. If the `updateCount` argument is omitted or differs from the current\\n * update count, return the current record.\\n * Otherwise, after the next state change, the promise will resolve to the\\n * then-current value of the record.\\n * @returns {Promise<UpdateRecord<T>>} resolves to the corresponding\\n * update\\n */ /**\\n * @template T\\n * @typedef {Object} BaseNotifier<T> an object that can be used to get the\\n * current state or updates\\n * @property {GetUpdateSince<T>} getUpdateSince return update record as of an\\n * update count.\\n */ /**\\n * @typedef {any} NotifierInternals Purposely opaque. Will be shared between\\n * machines, so it must be same to expose. But other software should avoid\\n * depending on its internal structure.\\n */ /**\\n * @template T\\n * @typedef {BaseNotifier<T> & AsyncIterable<T>} Notifier<T> an object that can\\n * be used to get the current state or updates\\n *\\n * @property {() => NotifierInternals} getSharableNotifierInternals\\n * Used to replicate the multicast values at other sites. To manually create a\\n * local representative of a Notification, do\\n * ```js\\n * localIterable =\\n *   makeNotifier(E(remoteIterable).getSharableNotifierInternals());\\n * ```\\n * The resulting `localIterable` also supports such remote use, and\\n * will return access to the same representation.\\n */ /**\\n * @template T\\n * @typedef {Object} NotifierRecord<T> the produced notifier/updater pair\\n * @property {IterationObserver<T>} updater the (closely-held) notifier producer\\n * @property {Notifier<T>} notifier the (widely-held) notifier consumer\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /* eslint-disable-next-line jsdoc/require-property*/ /**\\n * @template T\\n * @typedef {Object} BaseSubscription<T>\\n */ /**\\n * @typedef {any} SubscriptionInternals Purposely opaque. Will be shared between\\n * machines, so it must be same to expose. But other software should avoid\\n * depending on its internal structure.\\n */ /**\\n * @template T\\n * @typedef {BaseSubscription<T> & AsyncIterable<T>} Subscription<T>\\n * A form of AsyncIterable supporting distributed and multicast usage.\\n *\\n * @property {() => SubscriptionInternals} getSharableSubscriptionInternals\\n * Used to replicate the multicast values at other sites. To manually create a\\n * local representative of a Subscription, do\\n * ```js\\n * localIterable =\\n *   makeAsyncIterable(E(remoteIterable).getSharableSubscriptionInternals());\\n * ```\\n * The resulting `localIterable` also supports such remote use, and\\n * will return access to the same representation.\\n */ /**\\n * @template T\\n * @typedef {AsyncIterator<T> & AsyncIterable<T>} SubscriptionIterator<T>\\n * an AsyncIterator supporting distributed and multicast usage.\\n *\\n * @property {() => Subscription<T>} subscribe\\n * Get a new subscription whose starting position is this iterator's current\\n * position.\\n */ /**\\n * @template T\\n * @typedef {Object} SubscriptionRecord<T>\\n * @property {IterationObserver<T>} publication\\n * @property {Subscription<T>} subscription\\n */\",\n  \"notifier/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"ertp/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').ERef<T>} ERef\\n */ /**\\n * @typedef {Ximport('@agoric/marshal').InterfaceSpec} InterfaceSpec\\n * @typedef {Ximport('@agoric/marshal').GetInterfaceOf} GetInterfaceOf\\n */ /**\\n * @typedef {Object} Amount\\n * Amounts are descriptions of digital assets, answering the questions\\n * \\\"how much\\\" and \\\"of what kind\\\". Amounts are values labeled with a brand.\\n * AmountMath executes the logic of how amounts are changed when digital\\n * assets are merged, separated, or otherwise manipulated. For\\n * example, a deposit of 2 bucks into a purse that already has 3 bucks\\n * gives a new purse balance of 5 bucks. An empty purse has 0 bucks. AmountMath\\n * relies heavily on polymorphic MathHelpers, which manipulate the unbranded\\n * portion.\\n *\\n * @property {Brand} brand\\n * @property {Value} value\\n */ /**\\n * @typedef {NatValue | SetValue} Value\\n * Values describe the value of something that can be owned or shared.\\n * Fungible values are normally represented by natural numbers. Other\\n * values may be represented as strings naming a particular right, or\\n * an arbitrary object that sensibly represents the rights at issue.\\n *\\n * Value must be Comparable. (Would be nice to type this correctly.)\\n */ /**\\n * @typedef {'nat' | 'set' | 'strSet'} AmountMathKind\\n */ /**\\n * @callback MakeEmpty\\n * @param {Brand} brand\\n * @param {AmountMathKind=} mathKind\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} AmountMath\\n * Logic for manipulating amounts.\\n *\\n * Amounts are the canonical description of tradable goods. They are manipulated\\n * by issuers and mints, and represent the goods and currency carried by purses and\\n * payments. They can be used to represent things like currency, stock, and the\\n * abstract right to participate in a particular exchange.\\n *\\n * @property {(allegedValue: Value, brand: Brand) => Amount} make\\n * Make an amount from a value by adding the brand.\\n *\\n * @property {(allegedAmount: Amount, brand: Brand) => Amount} coerce\\n * Make sure this amount is valid and return it if so.\\n *\\n * @property {(amount: Amount, brand: Brand) => Value} getValue\\n * Extract and return the value.\\n *\\n * @property {MakeEmpty} makeEmpty\\n * Return the amount representing an empty amount. This is the\\n * identity element for MathHelpers.add and MatHelpers.subtract.\\n *\\n * @property {(amount: Amount) => Amount} makeEmptyFromAmount\\n * Return the amount representing an empty amount, using another\\n * amount as the template for the brand and mathKind.\\n *\\n * @property {(amount: Amount, brand?: Brand) => boolean} isEmpty\\n * Return true if the Amount is empty. Otherwise false.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => boolean} isGTE\\n * Returns true if the leftAmount is greater than or equal to the\\n * rightAmount. For non-scalars, \\\"greater than or equal to\\\" depends\\n * on the kind of amount, as defined by the MathHelpers. For example,\\n * whether rectangle A is greater than rectangle B depends on whether rectangle\\n * A includes rectangle B as defined by the logic in MathHelpers.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => boolean} isEqual\\n * Returns true if the leftAmount equals the rightAmount. We assume\\n * that if isGTE is true in both directions, isEqual is also true\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => Amount} add\\n * Returns a new amount that is the union of both leftAmount and rightAmount.\\n *\\n * For fungible amount this means adding the values. For other kinds of\\n * amount, it usually means including all of the elements from both\\n * left and right.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => Amount} subtract\\n * Returns a new amount that is the leftAmount minus the rightAmount\\n * (i.e. everything in the leftAmount that is not in the\\n * rightAmount). If leftAmount doesn't include rightAmount\\n * (subtraction results in a negative), throw  an error. Because the\\n * left amount must include the right amount, this is NOT equivalent\\n * to set subtraction.\\n */ /**\\n * @typedef {Object} DisplayInfo\\n * @property {number=} decimalPlaces\\n *   Tells the display software how many decimal places to move the\\n *   decimal over to the left, or in other words, which position corresponds to whole\\n *   numbers. We require fungible digital assets to be represented in\\n *   integers, in the smallest unit (i.e. USD might be represented in mill,\\n *   a thousandth of a dollar. In that case, `decimalPlaces` would be 3.)\\n *   This property is optional, and for non-fungible digital assets,\\n *   should not be specified.\\n *   The decimalPlaces property should be used for *display purposes only*. Any\\n *   other use is an anti-pattern.\\n */ /**\\n * @typedef {Object} Brand\\n * The brand identifies the kind of issuer, and has a function to get the\\n * alleged name for the kind of asset described. The alleged name (such\\n * as 'BTC' or 'moola') is provided by the maker of the issuer and should\\n * not be trusted as accurate.\\n *\\n * Every amount created by a particular AmountMath will share the same brand,\\n * but recipients cannot rely on the brand to verify that a purported amount\\n * represents the issuer they intended, since the same brand can be reused by\\n * a misbehaving issuer.\\n *\\n * @property {(allegedIssuer: ERef<Issuer>) => Promise<boolean>} isMyIssuer Should be used with\\n * `issuer.getBrand` to ensure an issuer and brand match.\\n * @property {() => string} getAllegedName\\n * @property {() => DisplayInfo} getDisplayInfo\\n *  Give information to UI on how to display the amount.\\n */ /**\\n * @typedef {ERef<Payment>} PaymentP\\n */ /**\\n * @callback IssuerBurn\\n * @param {PaymentP} payment\\n * @param {Amount=} optAmount\\n * @returns {Promise<Amount>}\\n */ /**\\n * @callback IssuerClaim\\n * @param {PaymentP} payment\\n * @param {Amount=} optAmount\\n * @returns {Promise<Payment>}\\n */ /**\\n * @typedef {Object} Issuer\\n * The issuer cannot mint a new amount, but it can create empty purses and\\n * payments. The issuer can also transform payments (splitting payments,\\n * combining payments, burning payments, and claiming payments\\n * exclusively). The issuer should be gotten from a trusted source and\\n * then relied upon as the decider of whether an untrusted payment is valid.\\n *\\n * @property {() => Brand} getBrand Get the Brand for this Issuer. The Brand\\n * indicates the kind of\\n * digital asset and is shared by the mint, the issuer, and any purses\\n * and payments of this particular kind. The brand is not closely\\n * held, so this function should not be trusted to identify an issuer\\n * alone. Fake digital assets and amount can use another issuer's brand.\\n *\\n * @property {() => string} getAllegedName Get the allegedName for this mint/issuer\\n * @property {() => AmountMathKind} getAmountMathKind Get the kind of\\n * MathHelpers used by this Issuer.\\n * @property {() => Purse} makeEmptyPurse Make an empty purse of this brand.\\n * @property {(payment: PaymentP) => Promise<boolean>} isLive\\n * Return true if the payment continues to exist.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {(payment: PaymentP) => Promise<Amount>} getAmountOf\\n * Get the amount of digital assets in the payment. Because the\\n * payment is not trusted, we cannot call a method on it directly,\\n * and must use the issuer instead.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {IssuerBurn} burn\\n * Burn all of the digital assets in the payment. `optAmount` is optional.\\n * If `optAmount` is present, the code will insist that the amount of\\n * the digital assets in the payment is equal to `optAmount`, to\\n * prevent sending the wrong payment and other confusion.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {IssuerClaim} claim\\n * Transfer all digital assets from the payment to a new payment and\\n * delete the original. `optAmount` is optional.\\n * If `optAmount` is present, the code will insist that the amount of\\n * digital assets in the payment is equal to `optAmount`, to prevent\\n * sending the wrong  payment and other confusion.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {(paymentsArray: PaymentP[]) => Promise<Payment>} combine\\n * Combine multiple payments into one payment.\\n *\\n * If any of the payments is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @property {(payment: PaymentP, paymentAmountA: Amount) => Promise<Payment[]>} split\\n * Split a single payment into two payments, A and B, according to the\\n * paymentAmountA passed in.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n *\\n * @property {(payment: PaymentP, amounts: Amount[]) => Promise<Payment[]>} splitMany\\n * Split a single payment into many payments, according to the\\n * amounts passed in.\\n *\\n * If the payment is a promise, the operation will proceed upon resolution.\\n */ /**\\n * @callback MakeIssuerKit\\n * @param {string} allegedName\\n * @param {AmountMathKind} [amountMathKind=MathKind.NAT]\\n * @param {DisplayInfo=} [displayInfo=undefined]\\n * @returns {IssuerKit}\\n *\\n * The allegedName becomes part of the brand in asset descriptions. The\\n * allegedName doesn't have to be a string, but it will only be used for\\n * its value. The allegedName is useful for debugging and double-checking\\n * assumptions, but should not be trusted.\\n *\\n * The amountMathKind will be used to import a specific mathHelpers\\n * from the mathHelpers library. For example, natMathHelpers, the\\n * default, is used for basic fungible tokens.\\n *\\n *  `displayInfo` gives information to UI on how to display the amount.\\n *\\n * @typedef {Object} IssuerKit\\n * The return value of makeIssuerKit\\n *\\n * @property {Mint} mint\\n * @property {Issuer} issuer\\n * @property {DeprecatedAmountMath} amountMath\\n * @property {Brand} brand\\n * @property {AmountMathKind} amountMathKind\\n */ /**\\n * @typedef {Object} Mint\\n * Holding a Mint carries the right to issue new digital assets. These\\n * assets all have the same kind, which is called a Brand.\\n *\\n * @property {() => Issuer} getIssuer Gets the Issuer for this mint.\\n * @property {(newAmount: Amount) => Payment} mintPayment\\n * Creates a new Payment containing newly minted amount.\\n */ /**\\n * @callback DepositFacetReceive\\n * @param {Payment} payment\\n * @param {Amount=} optAmount\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} DepositFacet\\n * @property {DepositFacetReceive} receive\\n * Deposit all the contents of payment into the purse that made this facet,\\n * returning the amount. If the optional argument `optAmount` does not equal the\\n * amount of digital assets in the payment, throw an error.\\n *\\n * If payment is a promise, throw an error.\\n */ /**\\n * @callback PurseDeposit\\n * @param {Payment} payment\\n * @param {Amount=} optAmount\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} Purse\\n * Purses hold amount of digital assets of the same brand, but unlike Payments, they are\\n * not meant to be sent to others. To transfer digital assets, a\\n * Payment should be withdrawn from a Purse. The amount of digital\\n * assets in a purse can change through the action of deposit() and withdraw().\\n *\\n * The primary use for Purses and Payments is for currency-like and goods-like\\n * digital assets, but they can also be used to represent other kinds of rights, such\\n * as the right to participate in a particular contract.\\n *\\n * @property {() => Brand} getAllegedBrand Get the alleged Brand for this Purse\\n *\\n * @property {() => Amount} getCurrentAmount\\n * Get the amount contained in this purse.\\n *\\n * @property {() => Notifier<Amount>} getCurrentAmountNotifier\\n * Get a lossy notifier for changes to this purse's balance.\\n *\\n * @property {PurseDeposit} deposit\\n * Deposit all the contents of payment into this purse, returning the\\n * amount. If the optional argument `optAmount` does not equal the\\n * amount of digital assets in the payment, throw an error.\\n *\\n * If payment is a promise, throw an error.\\n *\\n * @property {() => DepositFacet} getDepositFacet\\n * Return an object whose `receive` method deposits to the current Purse.\\n *\\n * @property {(amount: Amount) => Payment} withdraw\\n * Withdraw amount from this purse into a new Payment.\\n */ /**\\n * @typedef {Object} Payment\\n * Payments hold amount of digital assets of the same brand in transit. Payments can\\n * be deposited in purses, split into multiple payments, combined, and\\n * claimed (getting an exclusive payment). Payments are linear, meaning\\n * that either a payment has the same amount of digital assets it\\n * started with, or it is used up entirely. It is impossible to partially use a payment.\\n *\\n * Payments are often received from other actors and therefore should\\n * not be trusted themselves. To get the amount of digital assets in a payment, use the\\n * trusted issuer: issuer.getAmountOf(payment),\\n *\\n * Payments can be converted to Purses by getting a trusted issuer and\\n * calling `issuer.makeEmptyPurse()` to create a purse, then `purse.deposit(payment)`.\\n *\\n * @property {() => Brand} getAllegedBrand\\n * Get the allegedBrand, indicating the kind of digital asset this\\n * payment purports to be, and which issuer to use. Because payments\\n * are not trusted, any method calls on payments should be treated\\n * with suspicion and verified elsewhere.\\n */ /**\\n * @template V\\n * @typedef {Object} MathHelpers<V>\\n * All of the difference in how digital asset amount are manipulated can be reduced to\\n * the behavior of the math on values. We extract this\\n * custom logic into mathHelpers. MathHelpers are about value\\n * arithmetic, whereas AmountMath is about amounts, which are the\\n * values labeled with a brand. AmountMath use mathHelpers to do their value arithmetic,\\n * and then brand the results, making a new amount.\\n *\\n * The MathHelpers are designed to be called only from AmountMath, and so\\n * all methods but coerce can assume their inputs are valid. They only\\n * need to do output validation, and only when there is a possibility of\\n * invalid output.\\n *\\n * @property {(allegedValue: V) => V} doCoerce\\n * Check the kind of this value and throw if it is not the\\n * expected kind.\\n *\\n * @property {() => V} doMakeEmpty\\n * Get the representation for the identity element (often 0 or an\\n * empty array)\\n *\\n * @property {(value: V) => boolean} doIsEmpty\\n * Is the value the identity element?\\n *\\n * @property {(left: V, right: V) => boolean} doIsGTE\\n * Is the left greater than or equal to the right?\\n *\\n * @property {(left: V, right: V) => boolean} doIsEqual\\n * Does left equal right?\\n *\\n * @property {(left: V, right: V) => Value} doAdd\\n * Return the left combined with the right.\\n *\\n * @property {(left: V, right: V) => V} doSubtract\\n * Return what remains after removing the right from the left. If\\n * something in the right was not in the left, we throw an error.\\n */ /**\\n * @typedef {bigint} NatValue\\n */ /**\\n * @typedef {Array<Comparable>} SetValue\\n */ /**\\n * @typedef {MathHelpers<NatValue>} NatMathHelpers\\n */ /**\\n * @typedef {MathHelpers<SetValue>} SetMathHelpers\\n */ /**\\n * @typedef {{ISSUER: 'issuer', BRAND: 'brand', PURSE: 'purse', PAYMENT:\\n * 'payment', MINT: 'mint', DEPOSIT_FACET: 'depositFacet' }} ERTPKind\\n */ /**\\n * @callback MakeInterface\\n * Make the interface using the allegedName and kind. The particular\\n * structure may change in the future to be more sophisticated.\\n * Therefore, ERTP and Zoe should not depend on this particular\\n * implementation.\\n *\\n * @param {string} allegedName The allegedName, as passed to\\n *  `makeIssuerKit`\\n * @param {string} kind The ERTPKind\\n * @returns {InterfaceSpec}\\n */ /**\\n * @callback MakeFarName\\n * Make the farName using the allegedName and kind. The particular\\n * structure may change in the future to be more sophisticated.\\n * Therefore, ERTP and Zoe should not depend on this particular\\n * implementation. `makeFar` converts its farName argument into\\n * the iface argument it passes to `Remotable`.\\n *\\n * @param {string} allegedName The allegedName, as passed to\\n *  `makeIssuerKit`\\n * @param {string} kind The ERTPKind\\n * @returns {string}\\n */ /**\\n * @typedef {Object} DeprecatedAmountMath\\n * This version of amountMath is deprecated. Please use `amountMath` directly\\n * as exported by `@agoric/ertp`.\\n *\\n * @property {() => Brand} getBrand Deprecated\\n * @property {() => AmountMathKind} getAmountMathKind  Deprecated\\n * @property {(allegedValue: Value) => Amount} make Deprecated\\n * @property {(allegedAmount: Amount) => Amount} coerce Deprecated\\n * @property {(amount: Amount) => Value} getValue Deprecated\\n * @property {() => Amount} getEmpty Deprecated\\n * @property {(amount: Amount) => boolean} isEmpty Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => boolean} isGTE Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => boolean} isEqual Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => Amount} add Deprecated\\n * @property {(leftAmount: Amount, rightAmount: Amount) => Amount} subtract Deprecated\\n */\",\n  \"ertp/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"store/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {Record<string, Function>} ExternalInstance\\n */ /**\\n * @template K,V\\n * @typedef {Object} Store - A safety wrapper around a Map\\n * @property {(key: K) => boolean} has - Check if a key exists\\n * @property {(key: K, value: V) => void} init - Initialize the key only if it\\n * doesn't already exist\\n * @property {(key: K) => V} get - Return a value for the key. Throws if not\\n * found.\\n * @property {(key: K, value: V) => void} set - Set the key. Throws if not\\n * found.\\n * @property {(key: K) => void} delete - Remove the key. Throws if not found.\\n * @property {() => K[]} keys - Return an array of keys\\n * @property {() => V[]} values - Return an array of values\\n * @property {() => [K, V][]} entries - Return an array of entries\\n */ /**\\n * @template K,V\\n * @typedef {Object} WeakStore - A safety wrapper around a WeakMap\\n * @property {(key: any) => boolean} has - Check if a key exists\\n * @property {(key: K, value: V) => void} init - Initialize the key only if it\\n * doesn't already exist\\n * @property {(key: any) => V} get - Return a value for the key. Throws if not\\n * found.\\n * @property {(key: K, value: V) => void} set - Set the key. Throws if not\\n * found.\\n * @property {(key: K) => void} delete - Remove the key. Throws if not found.\\n */ /**\\n * Distinguishes between adding a new key (init) and updating or\\n * referencing a key (get, set, delete).\\n *\\n * `init` is only allowed if the key does not already exist. `Get`,\\n * `set` and `delete` are only allowed if the key does already exist.\\n *\\n * @template K,V\\n * @callback MakeWeakStore\\n * @param {string} [keyName='key'] - the column name for the key\\n * @returns {WeakStore<K,V>}\\n */ /**\\n * An external store for a given maker function.\\n * TODO: We should provide makers for other kinds of data structures.\\n * Weak sorted lists, weak priority queues, and many others.\\n *\\n * @template {(...args: Array<any>) => ExternalInstance} M\\n * @typedef {Object} ExternalStore\\n * @property {M} makeInstance Create a fresh instance\\n * @property {MakeWeakStore<ReturnType<M>, any>} makeWeakStore Create an\\n * external weak store indexed by an instance\\n */ /**\\n * @typedef {Record<string, any>} HydrateData\\n */ /**\\n * @typedef {[number, number]} HydrateKey\\n * @typedef {true} HydrateInit\\n * @typedef {Object} HydrateHook\\n * @property {(value: any) => HydrateKey} getKey\\n * @property {(key: HydrateKey) => any} load\\n * @property {(storeId: number) => void} drop\\n */ /**\\n * An external store that decouples the closure data from the returned\\n * \\\"representative\\\" instance.\\n *\\n * @template {Array<any>} A\\n * @template {ExternalInstance} T\\n * @callback MakeHydrateExternalStore\\n * @param {string} instanceKind\\n * @param {(...args: A) => HydrateData} adaptArguments\\n * @param {(init?: HydrateInit) => (data: HydrateData) => T} makeHydrate\\n * @returns {ExternalStore<(...args: A) => T>}\\n */ /**\\n * @typedef {Object} HydrateStore The store needed to save closed-over\\n * per-instance data\\n * @property {(id: number, data: HydrateData) => void} init\\n * @property {(id: number) => HydrateData} get\\n * @property {(id: number, data: HydrateData) => void} set\\n * @property {() => WeakStore<ExternalInstance, any>} makeWeakStore\\n */ /**\\n * @typedef {Object} BackingStore This is the master store that reifies storeIds\\n * @property {(storeId: number, instanceKind: string) => HydrateStore} makeHydrateStore\\n * @property {(storeId: number) => HydrateStore} getHydrateStore\\n */\",\n  \"store/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"swingset-vat/src/vats/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} TimerService Gives the ability to get the current time,\\n * schedule a single wake() call, create a repeater that will allow scheduling\\n * of events at regular intervals, or remove scheduled calls.\\n * @property {() => Timestamp} getCurrentTimestamp Retrieve the latest timestamp\\n * @property {(baseTime: Timestamp, waker: ERef<TimerWaker>) => Timestamp} setWakeup Return\\n * value is the time at which the call is scheduled to take place\\n * @property {(waker: ERef<TimerWaker>) => Array<Timestamp>} removeWakeup Remove the waker\\n * from all its scheduled wakeups, whether produced by `timer.setWakeup(h)` or\\n * `repeater.schedule(h)`.\\n * @property {(delay: RelativeTime, interval: RelativeTime) => TimerRepeater} createRepeater\\n * DEPRECATED: use makeRepeater instead.\\n * @property {(delaySecs: RelativeTime, interval: RelativeTime) => TimerRepeater} makeRepeater\\n * Create and return a repeater that will schedule `wake()` calls\\n * repeatedly at times that are a multiple of interval following delay.\\n * Interval is the difference between successive times at which wake will be\\n * called.  When `schedule(w)` is called, `w.wake()` will be scheduled to be\\n * called after the next multiple of interval from the base. Since times can be\\n * coarse-grained, the actual call may occur later, but this won't change when\\n * the next event will be called.\\n * @property {(delaySecs: RelativeTime, interval: RelativeTime) => Notifier<Timestamp>} makeNotifier\\n * Create and return a Notifier that will deliver updates repeatedly at times\\n * that are a multiple of interval following delay.\\n */ /**\\n * @typedef {bigint} Timestamp An absolute individual stamp returned by a\\n * TimerService.  Note that different timer services may have different\\n * interpretations of actual Timestamp values.\\n * @typedef {bigint} RelativeTime Difference between two Timestamps.  Note that\\n * different timer services may have different interpretations of actual\\n * RelativeTime values.\\n */ /**\\n * @typedef {Object} TimerWaker\\n * @property {(timestamp: Timestamp) => void} wake The timestamp passed to\\n * `wake()` is the time that the call was scheduled to occur.\\n */ /**\\n * @typedef {Object} TimerRepeater\\n * @property {(waker: ERef<TimerWaker>) => Timestamp} schedule Returns the time scheduled for\\n * the first call to `E(waker).wake()`.  The waker will continue to be scheduled\\n * every interval until the repeater is disabled.\\n * @property {() => void} disable Disable this repeater, so `schedule(w)` can't\\n * be called, and wakers already scheduled with this repeater won't be\\n * rescheduled again after `E(waker).wake()` is next called on them.\\n */\",\n  \"swingset-vat/exported.js\": \"'use strict';require('./src/vats/types.js');\",\n  \"zoe/exported.js\": \"'use strict';require('./src/contractFacet/types.js');require('./src/zoeService/types.js');require('./src/contractSupport/types.js');require('./src/contracts/exported.js');require('./src/types.js');require('./tools/types.js');require('../notifier/exported.js');require('../ertp/exported.js');require('../store/exported.js');require('../swingset-vat/exported.js');\"\n};\n  const nsBundle = {};\n\n  function createEvalString(filename) {\n      const code = sourceBundle[filename];\n      if (!code) {\n        return undefined;\n      }\n      return `\\\n(function getExport(require, exports) { \\\n  'use strict'; \\\n  const module = { exports }; \\\n  \\\n  ${code}\n  return module.exports;\n})\n//# sourceURL=${filePrefix}/${filename}\n`;\n    }\n\n  function computeExports(filename, exportPowers, exports) {\n      const { require: systemRequire, _log } = exportPowers;\n      // This captures the endowed require.\n      const match = filename.match(/^(.*)\\/[^/]+$/);\n      const thisdir = match ? match[1] : '.';\n      const contextRequire = mod => {\n        // Do path algebra to find the actual source.\n        const els = mod.split('/');\n        let prefix;\n        if (els[0][0] === '@') {\n          // Scoped name.\n          prefix = els.splice(0, 2).join('/');\n        } else if (els[0][0] === '.') {\n          // Relative.\n          els.unshift(...thisdir.split('/'));\n        } else {\n          // Bare or absolute.\n          prefix = els.splice(0, 1);\n        }\n\n        const suffix = [];\n        for (const el of els) {\n          if (el === '.' || el === '') {\n            // Do nothing.\n          } else if (el === '..') {\n            // Traverse upwards.\n            suffix.pop();\n          } else {\n            suffix.push(el);\n          }\n        }\n\n        // log(mod, prefix, suffix);\n        if (prefix !== undefined) {\n          suffix.unshift(prefix);\n        }\n        let modPath = suffix.join('/');\n        if (modPath.startsWith('./')) {\n          modPath = modPath.slice(2);\n        }\n        // log('requiring', modPath);\n        if (!(modPath in nsBundle)) {\n          // log('evaluating', modPath);\n          // Break cycles, but be tolerant of modules\n          // that completely override their exports object.\n          nsBundle[modPath] = {};\n          nsBundle[modPath] = computeExports(\n            modPath,\n            exportPowers,\n            nsBundle[modPath],\n          );\n        }\n\n        // log('returning', nsBundle[modPath]);\n        return nsBundle[modPath];\n      };\n\n      const code = createEvalString(filename);\n      if (!code) {\n        // log('missing code for', filename, sourceBundle);\n        if (systemRequire) {\n          return systemRequire(filename);\n        }\n        throw Error(\n          `require(${JSON.stringify(\n            filename,\n          )}) failed; no toplevel require endowment`,\n        );\n      }\n\n      // log('evaluating', code);\n      return nestedEvaluate(code)(contextRequire, exports);\n    }\n\n  // Evaluate the entrypoint recursively, seeding the exports.\n  const systemRequire = typeof require === 'undefined' ? undefined : require;\n  return computeExports(entrypoint, { require: systemRequire }, {});\n}\n//# sourceURL=/bundled-source/...-preamble.js\n","sourceMap":"//# sourceURL=/bundled-source/...-preamble.js\n","moduleFormat":"nestedEvaluate"},"bundleName":"automaticRefund"};